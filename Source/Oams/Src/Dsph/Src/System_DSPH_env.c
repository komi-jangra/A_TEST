
/* SKELETON for env functions */
/* Program generated by Cadvanced 3.0.0.0.2032 */
#define XSCT_CADVANCED

#define C_TRANSLATOR_2_6
#include "scttypes.h"
#ifdef XUSE_SIGNAL_NUMBERS
#include "System_DSPH.hs"
#endif
#ifdef XENV_INC
#include XENV_INC
#endif
#include "System_DSPH.ifc"


#define SELF_ENTITY_NAME "DSPH"


#include <pthread.h>
#include "dbsxxx_commonwrappers.h"
#include "bpmxxx_commonDef.h"
#include "bpmxxx_platformLib.h"
#include "bpmxxx_OAM_commonDef.h"
#include "oamsxxx_semaphore.h"
#include "dbsxxx_grhm_dbwrapper.h"
//#include "oams_sig_handler.h"                  //R2.9 change

/**
 * Interface with Base Platform Module (BPM)
 * Note1: BPM is an optional feature in the system.
 * All code pertaining to BPM interface should be under a compile time
 * flag.
 */
#define MAX_DSP                    6
#define MAX_CORE                   4
#define MAX_DSP_TRAU_INDEX        32


I_S32  selfEntIdG ;
I_S32 gCurrentCardState = CARDSTATE_INIT;
I_S32 gNewCardState = BSC_APP_CARDSTATE_INVALID;
I_S32 gInvocation;
I_U32 gInstancesCreated = I_FALSE;
I_U32 gMsgsSent = 0;
I_U16	gInstCount = 0;
sem_t gSemHandler;
I_U32 gMaxNumDspMsgRetrans = ZERO;
I_U32 gTimerVal = ZERO;
I_U32 gMapDspIdCoreIdWithTid[MAX_DSP][MAX_CORE][MAX_DSP_TRAU_INDEX];


extern "C" void bpmGetComponentReg (char selfEntityId, void (*funcPtr)(struct sAisParam*));



#if BPM_PRESENT != 1

#define RegisterDsphWithBpm() bpmGetComponentReg(ENT_OAMS_SWMH_STUB, &DsphBpmCallbackFunc);
#warning "BPM support not compiled"
#define bpmRespondToAis(a,b) do{\
	;}while(0);


#else
void DsphBpmCallbackFunc (struct sAisParam *param);

void RegisterDsphWithBpm(void) 
{
	bpmGetComponentRegister (DsphBpmCallbackFunc, APPID_OAMS_DSPH);
	bpmComponentConfigure ();
}

#endif /* BPM_PRESENT */



void cardStateChangeHandler(struct sAisParam *param)
{
	xSignalNode         S;
	I_S32 result        = ZERO;
	I_U32 outCount=0;
	I_U16 counter;
	I_U32  refId = 0 ;
	I_U32 lclPidPtr = 0 ;
	I_S32 retVal;
	I_S32 instId = 0 ;
	InstMapTbl *instMapTblPtr_i;
	SDL_Pid             rcvr;
	I_U16	instCount = 0;
	I_S32 errCode = 0;
	I_U16 outSize = ZERO;
	I_U32 outRows = ZERO;
	BssCsPreConfigTableApi  *bssCsPreConfigTableOutData;


	rcvr.GlobalNodeNr = (I_S32)selfEntIdG;
	rcvr.LocalPId = (xLocalPIdNode)0;


	if ( (param->cardState == CARDSTATE_IN_SERVICE) && (gCurrentCardState == CARDSTATE_INIT) )
	{
		LOG_PRINT(INFO,"STATE TRANSITION INIT -> INSERVICE");
		gNewCardState = CARDSTATE_IN_SERVICE;
		LOG_PRINT(DEBUG,"Registering with DB Server...");

		result = dbConnect();
		if ( result != DBLIB_SUCCESS )
		{
			LOG_PRINT(CRITICAL,"DSPH: Unable to Register itself with DBServer:Exiting");
			exit(0);
		}
		LOG_PRINT(DEBUG,"Successfully Registered with DB Server.");

   /* R2.9 changes - starts */
    
		if(gInstancesCreated == I_FALSE)
		{	
			//send cre_insts signal to state machine
			LOG_PRINT(INFO,"No instances found in TauInst table so sending signal CRE_INSTS_REQ to Model");
			LOG_PRINT(INFO,"Initializing Inst Map Table...");
			InitInstMap(ENT_OAMS_DSPH,DSPH_HANDLER);
			result = GetInstCount(ENT_OAMS_DSPH, DSPH_HANDLER , &instCount);
			if ( result != INST_SUCCESS )
			{
				LOG_PRINT(MAJOR,"[ENV] GetInstCount Db call failed.. ");
				return;
			}
			gInstCount = instCount;
			S = xGetSignal( sig_CRE_INST_REQ, xNotDefPId, xEnv);
			SDL_Output( S xSigPrioPar(xDefaultPrioSignal), (xIdNode *)0 );

		}
		else
		{
			gCurrentCardState = CARDSTATE_IN_SERVICE;
			gNewCardState = BSC_APP_CARDSTATE_INVALID;
			LOG_PRINT(INFO,"Releasing semaphore.. ");
			SEM_POST(&gSemHandler);
		}
	/*
    gCurrentCardState = CARDSTATE_IN_SERVICE;
		gNewCardState = BSC_APP_CARDSTATE_INVALID;
		LOG_PRINT(INFO,"Releasing semaphore.. ");
		SEM_POST(&gSemHandler);
  */
	/* R2.9 changes ends */
  
  }
	else if ( (param->cardState == CARDSTATE_STANDBY) && (gCurrentCardState == CARDSTATE_IN_SERVICE) )
	{
		LOG_PRINT(INFO,"STATE TRANSITION INSERVICE -> STANDBY");
    gCurrentCardState = CARDSTATE_STANDBY;
	  gNewCardState = BSC_APP_CARDSTATE_INVALID;
		LOG_PRINT(INFO,"Releasing semaphore.. ");
		SEM_POST(&gSemHandler);
	}
	else if ( (param->cardState == CARDSTATE_ACTIVE_IN_PROGRESS) && (gCurrentCardState == CARDSTATE_IN_SERVICE) )
	{
		LOG_PRINT(INFO,"STATE TRANSITION INSERVICE -> ACTIVE_IN_PROGRESS");
		gCurrentCardState = CARDSTATE_ACTIVE_IN_PROGRESS;
		gNewCardState = BSC_APP_CARDSTATE_INVALID;
		LOG_PRINT(INFO,"Releasing semaphore.. ");
		SEM_POST(&gSemHandler);
	}
	else if ( (param->cardState == CARDSTATE_ACTIVE) && (gCurrentCardState == CARDSTATE_ACTIVE_IN_PROGRESS) )
	{
		LOG_PRINT(INFO,"STATE TRANSITION ACTIVE_IN_PROGRESS -> ACTIVE");

	/* R2.9 changes starts */
  
  /*if(gInstancesCreated == I_FALSE)
		{	
			//send cre_insts signal to state machine
			LOG_PRINT(INFO,"No instances found in TauInst table so sending signal CRE_INSTS_REQ to Model");
			LOG_PRINT(INFO,"Initializing Inst Map Table...");
			InitInstMap(ENT_OAMS_DSPH,DSPH_HANDLER);
			result = GetInstCount(ENT_OAMS_DSPH, DSPH_HANDLER , &instCount);
			if ( result != INST_SUCCESS )
			{
				LOG_PRINT(MAJOR,"[ENV] GetInstCount Db call failed.. ");
				return;
			}
			gInstCount = instCount;
			S = xGetSignal( sig_CRE_INST_REQ, xNotDefPId, xEnv);
			SDL_Output( S xSigPrioPar(xDefaultPrioSignal), (xIdNode *)0 );

		}
		else 
		{*/
	/* R2.9 changes ends */		
      
      gCurrentCardState = CARDSTATE_ACTIVE;
			gNewCardState = BSC_APP_CARDSTATE_INVALID;
			LOG_PRINT(INFO,"Releasing semaphore.. ");
			SEM_POST(&gSemHandler);
//  }

		errCode = getallBssCsPreConfigTable( &bssCsPreConfigTableOutData, &outRows, &outSize);
		if (errCode != CLIB_SUCCESS)
		{
			LOG_PRINT(CRITICAL,"Setting default timer value and retry");
			gTimerVal = DEFAULT_TIMERVAL;
			gMaxNumDspMsgRetrans = DEFAULT_MAX_RETRY;
		}
		else
		{
			gTimerVal = (I_U32)(bssCsPreConfigTableOutData->tWaitDspResp);
			gMaxNumDspMsgRetrans = (I_U32)(bssCsPreConfigTableOutData->maxNumDspMsgRetrans);
			free(bssCsPreConfigTableOutData);
		}
	}
	else if ( (param->cardState == CARDSTATE_IN_SERVICE) && (gCurrentCardState == CARDSTATE_ACTIVE) )
	{
		LOG_PRINT(INFO,"STATE TRANSITION ACTIVE -> INSERVICE");
		S = xGetSignal( sig_STATE_CHANGE_ACTIVE_TO_INSERVICE, xNotDefPId, xEnv);
		SDL_Output( S xSigPrioPar(xDefaultPrioSignal), (xIdNode *)0 );
		gCurrentCardState = CARDSTATE_IN_SERVICE;
		gNewCardState = BSC_APP_CARDSTATE_INVALID;
		LOG_PRINT(INFO,"Releasing semaphore.. ");
		SEM_POST(&gSemHandler);
	}
	else if ( (param->cardState == CARDSTATE_ACTIVE_IN_PROGRESS) && (gCurrentCardState == CARDSTATE_STANDBY) )
	{
    /* R2.9 changes starts */
     I_U32 outRows = 0, i = 0;
     I_U16 outSize = 0;
     I_U8  slotId;
     I_U8  frameId;
     DspStatusTableApi *outData, *tmpPtr ;
		 LOG_PRINT(INFO,"STATE TRANSITION STANDBY -> ACTIVE_IN_PROGRESS"); 
		 
  /* Getting DspInfoTable, DspStatusTable and BssTable to get EIC DSP's status */
       
      if( getallDspStatusTable(&outData,&outRows,&outSize) != CLIB_SUCCESS)
      {
        LOG_PRINT(DEBUG,"getallDspStatusTable failed");       
        gCurrentCardState = CARDSTATE_ACTIVE_IN_PROGRESS;
        gNewCardState = BSC_APP_CARDSTATE_INVALID;
        LOG_PRINT(INFO,"Releasing semaphore.. ");
        SEM_POST(&gSemHandler);
        return;
      }
      else
      {
        for(i = 0; i < outRows; i++)
        {
          tmpPtr = (DspStatusTableApi *)(((I_U8 *) outData) + i * outSize);
          /* Mantis ID 0027830 & 27833 Start*/
          if ((tmpPtr->slotId == 5) ||(tmpPtr->slotId == 6) || (tmpPtr->slotId == 3) ||(tmpPtr->slotId == 4)) // Added Allocation of instances for SlotId 3(ICC0) and SlotId 4(ICC1) 
          /* Mantis ID 0027830 & 27833 End*/
          {

            refId = tmpPtr->dspId;
            frameId = tmpPtr->chasisFrameId;
            slotId = tmpPtr->slotId;
            refId++;
            if (SearchAlocatedInst(&lclPidPtr,&instId,ENT_OAMS_DSPH,DSPH_HANDLER,refId,0,0,0,0) != INST_SUCCESS)
            {
		         LOG_PRINT(CRITICAL,"No DSPH Ins found for DSP = [%d]\n",refId);
			       if (AlocNewInst(&lclPidPtr, &instId, ENT_OAMS_DSPH,
				        DSPH_HANDLER,refId,
				        ZERO, ZERO, ZERO, ZERO)  != INST_SUCCESS)
             {
               LOG_PRINT(CRITICAL, "xInEnv : AlocNewInst() Failed for DSPH");
               gCurrentCardState = CARDSTATE_ACTIVE_IN_PROGRESS;
               gNewCardState = BSC_APP_CARDSTATE_INVALID;
               LOG_PRINT(INFO,"Releasing semaphore.. ");
               SEM_POST(&gSemHandler);
               return;
             }
             else
             {
              LOG_PRINT(DEBUG, "xInEnv : NEW INSTANCE ALLOCATED FOR DSPH  \
				       LCLPID: 0x%0x, INSTANCE-ID: %d, DSP-ID: %d",
				       lclPidPtr, instId, tmpPtr->dspId);
             }          
           }
           else
           {
             LOG_PRINT(DEBUG, "xInEnv : ALLOCATED INSTANCE IS SEARCHED FOR DSPH  \
				      LCLPID: 0x%0x, INSTANCE-ID: %d, DSP-ID: %d",
				      lclPidPtr, instId, tmpPtr->dspId);
           } 
          if (lclPidPtr == 0)
	        {
		        LOG_PRINT(CRITICAL,"Invalid Instance Found...\n");
		        continue;
          } 
          else
          {
            LOG_PRINT(DEBUG,"Sending DSPH_INT_STANDBY_TO_AIP");
            rcvr.LocalPId = (xLocalPIdNode)lclPidPtr;
            S = xGetSignal( sig_DSPH_INT_STANDBY_TO_AIP, rcvr, xEnv);
            (((yPDP_sig_DSPH_INT_STANDBY_TO_AIP)S)->Param1) = frameId;                                                       (((yPDP_sig_DSPH_INT_STANDBY_TO_AIP)S)->Param2) = slotId;
            (((yPDP_sig_DSPH_INT_STANDBY_TO_AIP)S)->Param3) = tmpPtr->dspId;
            SDL_Output( S xSigPrioPar(xDefaultPrioSignal), (xIdNode *)ZERO);
          }  
         }
        }
      }
       free(outData);
     
    /* R2.9 changes ends */
    
    gCurrentCardState = CARDSTATE_ACTIVE_IN_PROGRESS;
		gNewCardState = BSC_APP_CARDSTATE_INVALID;
		LOG_PRINT(INFO,"Releasing semaphore.. ");
		SEM_POST(&gSemHandler);
	}
	else if ( (param->cardState == CARDSTATE_RECOVERY) && (gCurrentCardState == CARDSTATE_STANDBY) )
	{
		LOG_PRINT(INFO,"STATE TRANSITION STANDBY -> RECOVERY");
		gCurrentCardState = CARDSTATE_RECOVERY;
		gNewCardState = BSC_APP_CARDSTATE_INVALID;
		LOG_PRINT(INFO,"Releasing semaphore.. ");
		SEM_POST(&gSemHandler);
	}
	else if ( (param->cardState == CARDSTATE_RECOVERY) && (gCurrentCardState == CARDSTATE_ACTIVE) )
	{
		LOG_PRINT(INFO,"STATE TRANSITION ACTIVE -> RECOVERY");
	/* R2.9 changes starts */	
    S = xGetSignal( sig_STATE_CHANGE_ACTIVE_TO_INSERVICE, xNotDefPId, xEnv);
		SDL_Output( S xSigPrioPar(xDefaultPrioSignal), (xIdNode *)0 );
	/* R2.9 changes ends */	
    gCurrentCardState = CARDSTATE_RECOVERY;
		gNewCardState = BSC_APP_CARDSTATE_INVALID;
		LOG_PRINT(INFO,"Releasing semaphore.. ");
		SEM_POST(&gSemHandler);
	}
	else if ( (param->cardState == CARDSTATE_IN_SERVICE) && (gCurrentCardState == CARDSTATE_RECOVERY) )
	{
		LOG_PRINT(INFO,"STATE TRANSITION RECOVERY -> INSERVICE");
		gCurrentCardState = CARDSTATE_IN_SERVICE;
		gNewCardState = BSC_APP_CARDSTATE_INVALID;
		LOG_PRINT(INFO,"Releasing semaphore.. ");
		SEM_POST(&gSemHandler);
	}
	else if ( (param->cardState == CARDSTATE_OUT_OF_SERVICE) && (gCurrentCardState == CARDSTATE_ACTIVE) )
	{
		LOG_PRINT(INFO,"STATE TRANSITION ACTIVE -> OUT_OF_SERVICE");
		gCurrentCardState = CARDSTATE_OUT_OF_SERVICE;
		gNewCardState = BSC_APP_CARDSTATE_INVALID;
		LOG_PRINT(INFO,"Releasing semaphore.. ");
		SEM_POST(&gSemHandler);
	}
	else if ( (param->cardState == CARDSTATE_OUT_OF_SERVICE) && (gCurrentCardState == CARDSTATE_STANDBY) )
	{
		LOG_PRINT(INFO,"STATE TRANSITION STANDBY -> OUT_OF_SERVICE");
		gCurrentCardState = CARDSTATE_OUT_OF_SERVICE;
		gNewCardState = BSC_APP_CARDSTATE_INVALID;
		LOG_PRINT(INFO,"Releasing semaphore.. ");
		SEM_POST(&gSemHandler);
	}
	else if ( (param->cardState == CARDSTATE_IN_SERVICE) && (gCurrentCardState == CARDSTATE_OUT_OF_SERVICE) )
	{
		LOG_PRINT(INFO,"STATE TRANSITION OUT_OF_SERVICE -> INSERVICE");
		gCurrentCardState = CARDSTATE_IN_SERVICE;
		gNewCardState = BSC_APP_CARDSTATE_INVALID;
		LOG_PRINT(INFO,"Releasing semaphore.. ");
		SEM_POST(&gSemHandler);
	}
	else if (param->cardState == CARDSTATE_PLATFORM_INS)
	{
		LOG_PRINT(INFO,"STATE TRANSITION to PLATFOMR_INS");
		gCurrentCardState = CARDSTATE_PLATFORM_INS;
		gNewCardState = BSC_APP_CARDSTATE_INVALID;
		LOG_PRINT(INFO,"Releasing semaphore.. ");
		SEM_POST(&gSemHandler);
	}
	else if (param->cardState == CARDSTATE_UPGRADE)
	{
		LOG_PRINT(INFO,"STATE TRANSITION CARDSTATE_UPGRADE");
		gCurrentCardState = CARDSTATE_UPGRADE;
		gNewCardState = BSC_APP_CARDSTATE_INVALID;
		LOG_PRINT(DEBUG,"Relasing semaphore");
		SEM_POST(&gSemHandler);
	}
/* Changes for Diagnostics 23/09/2010 */
	else if ( (param->cardState == CARDSTATE_DIAGNOSTIC) && (gCurrentCardState == CARDSTATE_STANDBY) )
	{
		LOG_PRINT(INFO,"STATE TRANSITION STANDBY -> DIAGNOSTIC");
		gCurrentCardState = CARDSTATE_DIAGNOSTIC;
		gNewCardState = BSC_APP_CARDSTATE_INVALID;
		LOG_PRINT(INFO,"Releasing semaphore.. ");
		SEM_POST(&gSemHandler);
	}
	else if ( (param->cardState == CARDSTATE_IN_SERVICE) && (gCurrentCardState == CARDSTATE_DIAGNOSTIC) )
	{
		LOG_PRINT(INFO,"STATE TRANSITION  DIAGNOSTIC -> INSERVICE");
		gCurrentCardState = CARDSTATE_IN_SERVICE;
		gNewCardState = BSC_APP_CARDSTATE_INVALID;
		LOG_PRINT(INFO,"Releasing semaphore.. ");
		SEM_POST(&gSemHandler);
	}
/* Changes for Diagnostics 23/09/2010 Ends*/
	else
	{
		LOG_PRINT(INFO,"Can't handle this STATE_CHANGE combination");
	}
}

void DsphBpmCallbackFunc (struct sAisParam *param)
{

	switch (param->messageId)
	{
		case BPM_HEALTHCHECK_MESSAGE:
			bpmRespondToAis (param->invocation, OK);
			break;

		case BPM_SELFCARD_STATE_CHANGE:
			//HA-CS4.0 changes start
			//LOG_PRINT(INFO, "BPM_SELFCARD_STATE_CHANGE recd, No Action Taken");
			if( SEM_WAIT(&gSemHandler) !=0)
				LOG_PRINT(DEBUG,"SEM_WAIT failed ");
			LOG_PRINT(DEBUG,"BPM_SELFCARD_STATE_CHANGE received ");
			cardStateChangeHandler(param);
			LOG_PRINT(DEBUG,"WAITING FOR SEMAPHORE...");
			if( SEM_TIMED_WAIT(&gSemHandler) != SEMAPHORE_WAIT_COMPLETE)
			{
				LOG_PRINT(INFO,"Got Sempahore.. ");
				LOG_PRINT(INFO,"calling bpmRespondToAis.. ");
				bpmRespondToAis (param->invocation, OK);
				LOG_PRINT(INFO,"Response sent to BPM.. ");
				LOG_PRINT(INFO,"Releasing Sempahore.. ");
				SEM_POST(&gSemHandler);
			}
			else
			{
				LOG_PRINT(INFO,"SEMAPHORE Wait Timed Out(4 secs).. ");
				LOG_PRINT(INFO,"Releasing semaphore.. ");
				SEM_POST(&gSemHandler);
			}
			//HA-CS4.0 changes end
			break;

		case BPM_PEERCARD_STATE_CHANGE:
			LOG_PRINT(INFO, "BPM_PEERCARD_STATE_CHANGE recvd, No Action Taken");
			bpmRespondToAis (param->invocation, OK);
			break;

		case BPM_MSG_ACK_PEER_HEALTH_BAD:
			LOG_PRINT(INFO, "BPM_MSG_ACK_PEER_HEALTH_BAD recvd, Not Expected");
			break;

		case BPM_MSG_ACK_CONFIGURE:
			LOG_PRINT(INFO, "BPM_MSG_ACK_CONFIGURE recvd");
			break;

		case BPM_MSG_ACK_CONFIGURE_RESET:
			LOG_PRINT(INFO, "BPM_MSG_ACK_CONFIGURE_RESET recvd, No Action Taken");
			break;

		case BPM_SHUTDOWN:
			LOG_PRINT(INFO, "BPM_SHUTDOWN recvd, Exiting");
			exit (1);
			break;

		default:
			LOG_PRINT(MAJOR, "Unexpected msg from BPM: %d", param->messageId);
			break;
	}
}

#define GET_REFID(inputStr)\
{\
	refId = ((inputStr *)rcvPtr)->dspId;\
	refId++;\
	LOG_PRINT(INFO,"[ENV.] RefId (%d)", refId);\
}


I_U32 GetRefIdByDspId(I_Void *rcvPtr)
{
   SysHdr          *sysHdr ;
   I_U16           msgType ;
   I_U32           refId = 0 ;

   LOG_PRINT(INFO,"In Function GetRefIdByDspId To Find RefId by DspId...");
   sysHdr = (SysHdr *)rcvPtr ;
   msgType = sysHdr->msgType ;
   switch(msgType)
   {
      case OAMS_CFG_DSPH_DSP_AVAIL_STATUS:
	 GET_REFID(OamsCfgDsphDspAvailStatus)
	    break;

      case OAMS_CFG_DSPH_DSP_BOOT_INFO:
	 GET_REFID(OamsCfgDsphDspBootInfo)
	    break;

      case OAMS_CFG_DSPH_DSP_DOWN_INFO:
	 GET_REFID(OamsCfgDsphDspDownInfo)
	    break;

      case OAMS_CFG_DSPH_DSP_LOCK_REQ:
	 GET_REFID(OamsCfgDsphDspLockReq)
	    break;

      case OAMS_CFG_DSPH_DSP_UNLOCK_REQ:
	 GET_REFID(OamsCfgDsphDspUnlockReq)
	    break;

      case OAMS_CFG_DSPH_DSP_RESET_REQ:
	 GET_REFID(OamsCfgDsphDspResetReq)
	    break;

      case OAMS_CFG_DSPH_BSS_ADMINSTATE_IND:
	 GET_REFID(OamsCfgDsphBssAdminStateInd)
	    break;

      case OAMS_OIL_DSPH_DSP_RESET_RESP:
	 GET_REFID(OamsOilDsphResetAck)
	    break;

      case OAMS_CFG_DSPH_RESET_FAIL_INFO:
	 GET_REFID(OamsCfgDsphDspResetFailInfo)
	    break;

	 /* R2.4 Changes : Starts */
      case CSAPP_GRHM_DSPH_TRAU_CHAN_CONF_REQ:
	 refId = ((CsappGrhmDsphTrauChanConfReq *)rcvPtr)->trauHdr.DSP_Id;
         refId++; 
	 LOG_PRINT(INFO,"[ENV.] RefId (%d)", refId);
	    break;

      case CSAPP_GRHM_DSPH_TRAU_CHAN_DECONF_REQ:
	 refId = ((CsappGrhmDsphTrauChanDeconfReq *)rcvPtr)->trauHdr.DSP_Id;
         refId++; 
	 LOG_PRINT(INFO,"[ENV.] RefId (%d)", refId);
	    break;

	 /* R2.4 Changes : Ends */

      case CSAPP_GRHM_DSPH_ADD_TRAU_RESOURCE_RESP:
           GET_REFID(CsappGrhmDsphAddTrauResourceResp)
           break;
   /*R2.8 Changes : Starts*/ 
      case OAMS_CFG_DSPH_RTP_DSP_BOOT_INFO:
	 GET_REFID(OamsCfgDsphRtpDspBootInfo)
	    break;

      case CSAPP_GRHM_DSPH_RTP_TRAU_CHAN_CONF_REQ:
	 refId = ((CsappGrhmDsphRtpTrauChanConfReq *)rcvPtr)->trauHdr.DSP_Id;
         refId++; 
	 LOG_PRINT(INFO,"[ENV.] RefId (%d)", refId);
	    break;

      case CSAPP_GRHM_DSPH_RTP_TRAU_CHAN_DECONF_REQ:
	 refId = ((CsappGrhmDsphRtpTrauChanDeconfReq *)rcvPtr)->trauHdr.DSP_Id;
         refId++; 
	 LOG_PRINT(INFO,"[ENV.] RefId (%d)", refId);
	    break;
    
      case CSAPP_GRHM_DSPH_ADD_RTP_TRAU_RESOURCE_RESP:
           GET_REFID(CsappGrhmDsphAddRtpTrauResourceResp)
           break;
    /*R2.8 Changes :Ends*/ 
      case EXT_TSM_MSG:
	 refId = ((DTrauMgsDspTriggerResp *)rcvPtr)->trauHdr.DSP_Id;
	 refId++;
	 LOG_PRINT(INFO,"[ENV.] RefId (%d)", refId);
	 break;

      
      
      default:
	 refId = 0;
   }
   LOG_PRINT(INFO,"Returning From Function GetRefIdByDspId...\n");
   return refId ;
}


I_U32 FindDsphLocalPidByDspId(I_Void *rcvPtr)
{
	I_U32 lclPidPtr = 0 ;
	I_S32 instId = 0 ;
	I_U32 refId = 0 ;
	refId = GetRefIdByDspId(rcvPtr) ;
	if (SearchAlocatedInst(&lclPidPtr,&instId,ENT_OAMS_DSPH,DSPH_HANDLER,refId,0,0,0,0) != INST_SUCCESS)
	{
		LOG_PRINT(CRITICAL,"No DSPH Ins found for DSP = [%d]\n",refId);
		return 0;
	}
	if (lclPidPtr == 0)
	{
		LOG_PRINT(CRITICAL,"Invalid Instance Found...\n");
		return 0;
	}
	return lclPidPtr ;
}


void mapTidWithDspIdAndCoreId(I_U8 dspId, I_U8 coreId, I_U8 trauIndex, I_U32 tag)
{
	//  I_U16 indexId = 0;
	//  I_U16 dID = (I_U16)dspId;
	//  I_U16 tIdx = (I_U16)trauIndex;
	//  indexId = (dID<<7)|tIdx;
	LOG_PRINT(INFO,"Mapping dspId (0x%x) coreId (0x%x) trauIndex (0x%x) with tag (0x%x)", 
			dspId, coreId, trauIndex, tag);
	gMapDspIdCoreIdWithTid[dspId][coreId][trauIndex] = tag;
}

void dsphStopTimer(I_U8 dspId, I_U8 coreId, I_U8 trauIndex)
{
	LOG_PRINT(LOG_INFO," Stopping the Timer \n");
	I_S8 sts;
	I_U32 tid;                // timer ID for timer
	//  I_U16 indexId = 0;
	//  I_U16 dID = (I_U16)dspId;
	//  I_U16 tIdx = (I_U16)trauIndex;
	//  indexId = ((dID<<7)|tIdx);

	tid = gMapDspIdCoreIdWithTid[dspId][coreId][trauIndex];

	LOG_PRINT(INFO,"Stopping timer, dspId (0x%x) coreId (0x%x) trauIndex (0x%x) with tid (0x%x) ", 
			dspId, coreId, trauIndex, tid);
	if((sts = StopTimerFrmwrk(tid)) >= 0 )
	{
		LOG_PRINT(INITLVL,"timer stopped Successfully tid(hex)=0x%x tid(decimal)=%d",tid,tid);
	}
	else
	{
		LOG_PRINT(CRITICAL,"Error : Timer stop failed sts = %d",sts);
	}
}


void dsphStartTimer(TrauConfigDeConfigStruct *payLoad, I_U32 timerVal)
{
	LOG_PRINT(LOG_INFO," Starting the Timer \n");
	I_U32 tid, i;                // timer ID for timer
	I_S8 sts;
	I_U8 dspId, coreId, trauIndex;
	SysAddr slfAddr;
	TmrPayLoad tmrPayLoad;
	slfAddr.entity= ENT_OAMS_DSPH;
	memcpy(tmrPayLoad.payLoad, payLoad, sizeof(TrauConfigDeConfigStruct));
	dspId = payLoad->dspId;
	coreId = payLoad->coreId;
	trauIndex = payLoad->trauIndex;
	if((sts = StartTimerFrmwrk( &slfAddr, timerVal, &tmrPayLoad, &tid)) >= 0 )
	{
		LOG_PRINT(INITLVL,"timer started Successfully tid(hex)=0x%x tid(decimal)=%d",tid,tid);
		LOG_PRINT(INITLVL,"timerVal = %d  ",timerVal);
		mapTidWithDspIdAndCoreId(dspId, coreId, trauIndex, tid);
	}
	else
	{
		LOG_PRINT(CRITICAL,"Error : Timer failed sts = %d",sts);
	}
}

#define FILL_LOCAL_VAR()\
{\
	dspId = ((TrauConfigDeConfigStruct*)searchPtr)->dspId;\
	coreId = ((TrauConfigDeConfigStruct*)searchPtr)->coreId;\
	trauIndex = ((TrauConfigDeConfigStruct*)searchPtr)->trauIndex;\
	ptrxId = ((TrauConfigDeConfigStruct*)searchPtr)->ptrxId;\
	retrans = ((TrauConfigDeConfigStruct*)searchPtr)->retrans;\
	ts = ((TrauConfigDeConfigStruct*)searchPtr)->ts;\
	subTs = ((TrauConfigDeConfigStruct*)searchPtr)->subTs;\
	msgId = ((TrauConfigDeConfigStruct*)searchPtr)->msgId;\
	msgType = ((TrauConfigDeConfigStruct*)searchPtr)->msgType;\
}

#if 0
void trauConfigDeConfigTimeOutHandler(I_U8* searchPtr)
{
	I_U8 dspId, coreId, trauIndex, ptrxId, retrans, ts, subTs, msgId;
	I_U16 msgType;
	I_U16 msgSize = ZERO;
	I_PVoid sendPtr = NULL;
	FILL_LOCAL_VAR()
		LOG_PRINT(INFO,"Handling Time Out for Config/DeConfig resp");
	LOG_PRINT(INFO,"dspId (0x%x) coreId (0x%x) trauIndex (0x%x) ptrxId (0x%x)",
			dspId, coreId, trauIndex, ptrxId);
	LOG_PRINT(INFO,"msgType (0x%x) retrans (0x%x) ts (0x%x) subTs (0x%x) msgId (0x%x)",
			msgType, retrans, ts, subTs, msgId);
	if (retrans == ZERO )
	{
		DTrauMgsTrxhTrauChanConfResp *trauMgsTrxhTrauChanConfRespPtr;
		msgSize = (I_U16)(sizeof(DTrauMgsTrxhTrauChanConfResp));
		trauMgsTrxhTrauChanConfRespPtr = (DTrauMgsTrxhTrauChanConfResp*)(AlocMsgBuf(msgSize));
		if (OAMS_TRXH_DSPH_TRAU_CHAN_CONF_REQ == msgType)
		{
			FILL_SYS_HDR(trauMgsTrxhTrauChanConfRespPtr,OAMS_DSPH_TRXH_TRAU_CHAN_CONF_RESP,MSG_SUB_TYPE,PRCR_CP,ENT_OAMS_DSPH,0,PRCR_CP,ENT_OAMS_TRXH,0);
		}
		else
		{
			FILL_SYS_HDR(trauMgsTrxhTrauChanConfRespPtr,OAMS_DSPH_TRXH_TRAU_CHAN_DECONF_RESP,MSG_SUB_TYPE,PRCR_CP,ENT_OAMS_DSPH,0,PRCR_CP,ENT_OAMS_TRXH,0);
		}

		trauMgsTrxhTrauChanConfRespPtr->hdr.DestId = MGS_DEST_TRAU;
		trauMgsTrxhTrauChanConfRespPtr->hdr.TotalLength = DSP_TRAU_CONF_DECONF_RESP_SIZE;

		FILL_TRAU_HDR(trauMgsTrxhTrauChanConfRespPtr->trauHdr,dspId, coreId, ENT_MGS_TSM, DSP_COM_MSG_BCAST, DSP_ALL_SERVICE, trauIndex, msgId, DSP_TRAU_CONF_DECONF_RESP_SIZE);

		trauMgsTrxhTrauChanConfRespPtr->response = DSP_FAILURE;
		trauMgsTrxhTrauChanConfRespPtr->ptrxId = ptrxId;

		sendPtr = (I_PVoid)trauMgsTrxhTrauChanConfRespPtr;
		if (SendMsg(sendPtr, MSG_ORD_PRIO, msgSize) == SND_FAIL)
		{
			LOG_PRINT(INFO," SENDING FAILED ");
			DalocMsgBuf((I_Void *)sendPtr);
			return;
		}
		else
		{
			LOG_PRINT(INFO,"Successfully sent message out ");
			return;
		}
	}
	else
	{
		LOG_PRINT(INFO,"Retransmission count is retrans (%d)", retrans);
		retrans--;
		if ( INVALID != ts )
		{
			LOG_PRINT(INFO,"Sending TrauChanConfReq Again");
			DTrauMgsTrxhTrauChanConfReq *trauMgsTrxhTrauChanConfReqPtr;
			msgSize = (I_U16)(sizeof(DTrauMgsTrxhTrauChanConfReq));
			TrauConfigDeConfigStruct timerPayLoad;

			trauMgsTrxhTrauChanConfReqPtr = (DTrauMgsTrxhTrauChanConfReq*)(AlocMsgBuf(msgSize));

			FILL_SYS_HDR(trauMgsTrxhTrauChanConfReqPtr,EXT_TSM_MSG,MSG_SUB_TYPE,PRCR_CP,ENT_OAMS_DSPH,0,PRCR_CP,ENT_IPC_TSMIF,0);

			trauMgsTrxhTrauChanConfReqPtr->hdr.DestId = MGS_DEST_TRAU;
			trauMgsTrxhTrauChanConfReqPtr->hdr.TotalLength = DSP_TRAU_CONF_REQ_SIZE;

			FILL_TRAU_HDR(trauMgsTrxhTrauChanConfReqPtr->trauHdr,dspId, coreId, ENT_MGS_TSM, DSP_COM_MSG_BCAST, DSP_ALL_SERVICE, trauIndex, msgId, DSP_TRAU_CONF_REQ_SIZE);

			trauMgsTrxhTrauChanConfReqPtr->timeSlot = ts;
			trauMgsTrxhTrauChanConfReqPtr->subTimeSlot = subTs;
			trauMgsTrxhTrauChanConfReqPtr->ptrxId = ptrxId;

			timerPayLoad.dspId     = dspId;
			timerPayLoad.coreId    = coreId;
			timerPayLoad.trauIndex = trauIndex;
			timerPayLoad.ptrxId    = ptrxId;
			timerPayLoad.msgType   = msgType;
			timerPayLoad.retrans   = retrans;
			timerPayLoad.ts        = ts;
			timerPayLoad.subTs     = subTs;
			timerPayLoad.msgId     = msgId;
			LOG_PRINT(INFO,"timerPayLoad.dspId     (0x%x)",timerPayLoad.dspId    );
			LOG_PRINT(INFO,"timerPayLoad.coreId    (0x%x)",timerPayLoad.coreId   );
			LOG_PRINT(INFO,"timerPayLoad.trauIndex (0x%x)",timerPayLoad.trauIndex);
			LOG_PRINT(INFO,"timerPayLoad.ptrxId    (0x%x)",timerPayLoad.ptrxId   );
			LOG_PRINT(INFO,"timerPayLoad.msgType   (0x%x)",timerPayLoad.msgType  );
			LOG_PRINT(INFO,"timerPayLoad.retrans   (0x%x)",timerPayLoad.retrans  );
			LOG_PRINT(INFO,"timerPayLoad.ts        (0x%x)",timerPayLoad.ts       );
			LOG_PRINT(INFO,"timerPayLoad.subTs     (0x%x)",timerPayLoad.subTs    );
			LOG_PRINT(INFO,"timerPayLoad.msgId     (0x%x)",timerPayLoad.msgId    );
			dsphStartTimer(&timerPayLoad, gTimerVal);
			sendPtr = (I_PVoid)trauMgsTrxhTrauChanConfReqPtr;
			if (SendMsg(sendPtr, MSG_ORD_PRIO, msgSize) == SND_FAIL)
			{
				LOG_PRINT(INFO," SENDING FAILED ");
				DalocMsgBuf((I_Void *)sendPtr);
				return;
			}
			else
			{
				LOG_PRINT(INFO,"Successfully sent message out ");
				return;
			}
		}// if INVALID != ts
		else
		{
			LOG_PRINT(INFO,"Sending TrauChanDeconfReq Again");
			DTrauMgsTrxhTrauChanDeconfReq *trauMgsTrxhTrauChanDeconfReqPtr;
			msgSize = (I_U16)(sizeof(DTrauMgsTrxhTrauChanDeconfReq));
			TrauConfigDeConfigStruct timerPayLoad;

			trauMgsTrxhTrauChanDeconfReqPtr = (DTrauMgsTrxhTrauChanDeconfReq*)(AlocMsgBuf(msgSize));

			FILL_SYS_HDR(trauMgsTrxhTrauChanDeconfReqPtr,EXT_TSM_MSG,MSG_SUB_TYPE,PRCR_CP,ENT_OAMS_DSPH,0,PRCR_CP,ENT_IPC_TSMIF,0);

			trauMgsTrxhTrauChanDeconfReqPtr->hdr.DestId = MGS_DEST_TRAU;
			trauMgsTrxhTrauChanDeconfReqPtr->hdr.TotalLength = DSP_TRAU_DECONF_REQ_SIZE;

			FILL_TRAU_HDR(trauMgsTrxhTrauChanDeconfReqPtr->trauHdr,dspId, coreId, ENT_MGS_TSM, DSP_COM_MSG_BCAST, DSP_ALL_SERVICE, trauIndex, msgId, DSP_TRAU_DECONF_REQ_SIZE);

			trauMgsTrxhTrauChanDeconfReqPtr->ptrxId = ptrxId;

			timerPayLoad.dspId     = dspId;
			timerPayLoad.coreId    = coreId;
			timerPayLoad.trauIndex = trauIndex;
			timerPayLoad.ptrxId    = ptrxId;
			timerPayLoad.msgType   = msgType;
			timerPayLoad.retrans   = retrans;
			timerPayLoad.ts        = INVALID;
			timerPayLoad.subTs     = INVALID;
			timerPayLoad.msgId     = msgId;
			LOG_PRINT(INFO,"timerPayLoad.dspId     (0x%x)",timerPayLoad.dspId    );
			LOG_PRINT(INFO,"timerPayLoad.coreId    (0x%x)",timerPayLoad.coreId   );
			LOG_PRINT(INFO,"timerPayLoad.trauIndex (0x%x)",timerPayLoad.trauIndex);
			LOG_PRINT(INFO,"timerPayLoad.ptrxId    (0x%x)",timerPayLoad.ptrxId   );
			LOG_PRINT(INFO,"timerPayLoad.msgType   (0x%x)",timerPayLoad.msgType  );
			LOG_PRINT(INFO,"timerPayLoad.retrans   (0x%x)",timerPayLoad.retrans  );
			LOG_PRINT(INFO,"timerPayLoad.ts        (0x%x)",timerPayLoad.ts       );
			LOG_PRINT(INFO,"timerPayLoad.subTs     (0x%x)",timerPayLoad.subTs    );
			LOG_PRINT(INFO,"timerPayLoad.msgId     (0x%x)",timerPayLoad.msgId    );
			dsphStartTimer(&timerPayLoad, gTimerVal);
			sendPtr = (I_PVoid)trauMgsTrxhTrauChanDeconfReqPtr;
			if (SendMsg(sendPtr, MSG_ORD_PRIO, msgSize) == SND_FAIL)
			{
				LOG_PRINT(INFO," SENDING FAILED ");
				DalocMsgBuf((I_Void *)sendPtr);
				return;
			}
			else
			{
				LOG_PRINT(INFO,"Successfully sent message out ");
				return;
			}
		}// else INAVLID != ts
	}// else retrans == ZERO
}
#endif



#ifndef XNOGLOBALNODENUMBER
/*---+---------------------------------------------------------------
  xGlobalNodeNumber  extern
  -------------------------------------------------------------------*/
#ifndef XENV_NODENUMBER
#define XENV_NODENUMBER return 1;
#endif


extern int xGlobalNodeNumber(void)
{
	/* Assign a unique global system Id to each SDL system in a cluster of systems. */
	return ENT_OAMS_DSPH;
	XENV_NODENUMBER
}
#endif


#ifndef XNOINITENV
/*---+---------------------------------------------------------------
  xInitEnv  extern
  -------------------------------------------------------------------*/
#ifndef XENV_INIT
#define XENV_INIT
#endif

extern void xInitEnv(void)
{
	/* Code to initialize your SDL-system environment may be inserted here */
	XENV_INIT
		I_S32          result;
	selfEntIdG = (int)ENT_OAMS_DSPH;

	//RegisterDsphWithBpm();CLOUD
	if (RegisterWithIpcFrmwrk(selfEntIdG, (I_S8 *)"DSPH") < 0)
	{
		LOG_PRINT(CRITICAL,"Unable to Register itself with IPC FrameWork : Exiting");
		exit(0) ;
	}
	RegisterDsphWithBpm();
	LOG_PRINT(INFO,"** SystemName=%s, ModuleName=%s, Version=%s **",SYSTEM_NAME,SELF_ENTITY_NAME,VERSION);
	LOG_PRINT(INFO,"Registering with IPC FramWork Complete...");
  SEM_INIT(&gSemHandler);
	LOG_PRINT(INFO, "SEMAPHORE INITIALIZED SUCCESSFULLY with pointer :: %d",&gSemHandler)

		// This portion of code is added for UT only.
#ifndef BPM_PRESENT

		I_U16 instCount = 0;
	xSignalNode         S;
	LOG_PRINT(INFO,"STATE TRANSITION INIT -> INSERVICE");
	gNewCardState = CARDSTATE_IN_SERVICE;
	LOG_PRINT(DEBUG,"Registering with DB Server...");

	result = dbConnect();
	if ( result != DBLIB_SUCCESS )
	{
		LOG_PRINT(CRITICAL,"DSPH: Unable to Register itself with DBServer:Exiting");
		exit(0);
	}
	LOG_PRINT(DEBUG,"Successfully Registered with DB Server.");
  
#if 0
  /* R2.9 changes start */
  REGISTER_SIGNAL_HANDLER();                 
  LOG_PRINT(INFO,"xInitEnv: registered signal handler");
 /* R2.9 changes end */
#endif
#endif 

#ifdef XTRACE
	xPrintString("xInitEnv called\n");
#endif
}
#endif


#ifndef XNOCLOSEENV
/*---+---------------------------------------------------------------
  xCloseEnv  extern
  -------------------------------------------------------------------*/
#ifndef XENV_CLOSE
#define XENV_CLOSE
#endif

extern void xCloseEnv(void)
{
	/* Code to bring down the environment in a controlled manner
	   may be inserted here. */
	XENV_CLOSE

#ifdef XTRACE
		xPrintString("xCloseEnv called\n");
#endif
}
#endif


/*---+---------------------------------------------------------------
  Macros for xOutEnv
  -------------------------------------------------------------------*/
#ifndef OUT_LOCAL_VARIABLES
#define OUT_LOCAL_VARIABLES
#endif

#ifndef IF_OUT_SIGNAL
#define IF_OUT_SIGNAL(SIGNAL_NAME, SIGNAL_NAME_STRING) \
	if (((*SignalOut)->NameNode) == SIGNAL_NAME) {
#define END_IF_OUT_SIGNAL(SIGNAL_NAME, SIGNAL_NAME_STRING) \
	}
#endif

#ifndef OUT_SIGNAL1
#define OUT_SIGNAL1(SIGNAL_NAME, SIGNAL_NAME_STRING)
#endif

#ifndef OUT_SIGNAL2
#define OUT_SIGNAL2(SIGNAL_NAME, SIGNAL_NAME_STRING)
#endif

#ifndef XENV_ENC
#define XENV_ENC(stmt) stmt
#endif

#ifndef XENV_OUT_START
#define XENV_OUT_START
#endif

#ifndef RELEASE_SIGNAL
#define RELEASE_SIGNAL   xReleaseSignal(SignalOut); return;
#endif


#define FETCH_PARAM1_PARAM2(str_i)\
{\
	sndPtr = ((yPDP_sig_##str_i)(*SignalOut))->Param1;\
	msgSize = ((yPDP_sig_##str_i)(*SignalOut))->Param2;\
}

/*---+---------------------------------------------------------------
  xOutEnv  extern
  -------------------------------------------------------------------*/
extern void xOutEnv( xSignalNode *SignalOut
#ifdef XPATH_INFO_IN_ENV_FUNC
		, xChannelIdNode Port
#endif
		)
{
	// OUT_LOCAL_VARIABLES
	I_Void  *sndPtr;
	I_S32   msgSize;
	I_U32   lclPidPtr;
	I_S32   retVal;
	I_U8    actClsId = 0;
	static I_U8 	  recvdMsgs = 0;

#ifdef XTRACE
#ifdef XIDNAMES
	char  Temp[100];
	sprintf(Temp, "xOutEnv:  %s has been received by env\n", (*SignalOut)->NameNode->Name );
	xPrintString(Temp);
	LOG_PRINT(INFO," Signal Number Received :::: [[%d]] : xOutEnv \n", (*SignalOut)->NameNode->SignalNumber);
#else
	xPrintString("xOutEnv:  One signal has been received by env\n");
#endif
#endif

	switch((*SignalOut)->NameNode->SignalNumber)
	{

		case SN_OAMS_ADD_TAU_INST_IN_INSTMAP :
			actClsId = DSPH_HANDLER ;
			lclPidPtr = (I_U32)((*SignalOut)->Sender.LocalPId);
			LOG_PRINT(INFO,"xOutEnv: Received OAMS_ADD_TAU_INST_IN_INSTMAP with lclPidPtr (0x%x)", lclPidPtr);
			if ((retVal = AddTauInst(lclPidPtr, ENT_OAMS_DSPH, actClsId)) != INST_SUCCESS)
			{
				LOG_PRINT(CRITICAL,"xOutEnv: AddTauInstId Failed lclPid = " \
						"0x%x, [Act Cls Id = %d], [errCode = %d]",(I_U32)lclPidPtr,actClsId ,retVal);
			}
			else
			{
				LOG_PRINT(DEBUG,"xOutEnv :AddTauInstId Success lclPid = " \
						"0x%x, [Act Cls Id = %d]",(I_U32)lclPidPtr, actClsId);
			}
			recvdMsgs++;
			LOG_PRINT(INFO,"Here recvDMsgs are :: %d and gInstCount is :: %d ", recvdMsgs, gInstCount);
			if( recvdMsgs == gInstCount && gInstancesCreated == I_FALSE)
			{
				gCurrentCardState = CARDSTATE_IN_SERVICE;
				gNewCardState = BSC_APP_CARDSTATE_INVALID;
				gInstancesCreated = I_TRUE;
				LOG_PRINT(INFO,"CurrentCardState = %d", gCurrentCardState) ;
				LOG_PRINT(INFO,"NewCardState = %d", gNewCardState) ;
				SEM_POST(&gSemHandler);
				LOG_PRINT(INFO,"Releasing semaphore.. ");
				LOG_PRINT(INFO,"Moving to INSERVICE.. ");
				recvdMsgs = 0;
				gInstCount = 0;
			}

			xReleaseSignal(SignalOut);
			return;

		case SN_OAMS_DSPH_CFG_DSP_LOCK_RESP:
			FETCH_PARAM1_PARAM2(OAMS_DSPH_CFG_DSP_LOCK_RESP)
				if (sndPtr == NULL)
				{
					LOG_PRINT(INFO,"Received NULL Pointer from module,Returning without sending to CFG..\n") ;
					xReleaseSignal(SignalOut);
					return;
				}
			LOG_PRINT(INFO," Send OAMS_DSPH_CFG_DSP_LOCK_RESP :: msgSize = %d  msgType = 0x%x \n",msgSize , ((SysHdr *)sndPtr)->msgType);
			break;

		case SN_OAMS_DSPH_CFG_DSP_UNLOCK_RESP:
			FETCH_PARAM1_PARAM2(OAMS_DSPH_CFG_DSP_UNLOCK_RESP)
				if (sndPtr == NULL)
				{
					LOG_PRINT(INFO,"Received NULL Pointer from module,Returning without sending to CFG..\n") ;
					xReleaseSignal(SignalOut);
					return;
				}
			LOG_PRINT(INFO," Send OAMS_DSPH_CFG_DSP_UNLOCK_RESP :: msgSize = %d  msgType = 0x%x \n",msgSize , ((SysHdr *)sndPtr)->msgType);
			break;

		case SN_OAMS_DSPH_CFG_DSP_RESET_RESP:
			FETCH_PARAM1_PARAM2(OAMS_DSPH_CFG_DSP_RESET_RESP)
				if (sndPtr == NULL)
				{
					LOG_PRINT(INFO,"Received NULL Pointer from module,Returning without sending to CFG..\n") ;
					xReleaseSignal(SignalOut);
					return;
				}
			LOG_PRINT(INFO," Send OAMS_DSPH_CFG_DSP_RESET_RESP :: msgSize = %d  msgType = 0x%x \n",msgSize , ((SysHdr *)sndPtr)->msgType);
			break;

		case SN_OAMS_DSPH_CFG_DSP_INIT_TRAU_SUCCESS:
			FETCH_PARAM1_PARAM2(OAMS_DSPH_CFG_DSP_INIT_TRAU_SUCCESS)
				if (sndPtr == NULL)
				{
					LOG_PRINT(INFO,"Received NULL Pointer from module,Returning without sending to CFG..\n") ;
					xReleaseSignal(SignalOut);
					return;
				}
			LOG_PRINT(INFO," Send OAMS_DSPH_CFG_DSP_INIT_TRAU_SUCCESS :: msgSize = %d  msgType = 0x%x \n",msgSize , ((SysHdr *)sndPtr)->msgType);
			break;

		case SN_OAMS_DSPH_CFG_DSP_INIT_TRAU_FAIL:
			FETCH_PARAM1_PARAM2(OAMS_DSPH_CFG_DSP_INIT_TRAU_FAIL)
				if (sndPtr == NULL)
				{
					LOG_PRINT(INFO,"Received NULL Pointer from module,Returning without sending to CFG..\n") ;
					xReleaseSignal(SignalOut);
					return;
				}
			LOG_PRINT(INFO," Send OAMS_DSPH_CFG_DSP_INIT_TRAU_FAIL :: msgSize = %d  msgType = 0x%x \n",msgSize , ((SysHdr *)sndPtr)->msgType);
			break;

		case SN_OAMS_DSPH_CFG_ALARM_IND:
			FETCH_PARAM1_PARAM2(OAMS_DSPH_CFG_ALARM_IND)
				if (sndPtr == NULL)
				{
					LOG_PRINT(INFO,"Received NULL Pointer from module,Returning without sending to CFG..\n") ;
					xReleaseSignal(SignalOut);
					return;
				}
			LOG_PRINT(INFO," Send OAMS_DSPH_CFG_ALARM_IND :: msgSize = %d  msgType = 0x%x \n",msgSize , ((SysHdr *)sndPtr)->msgType);
			break;
#if 0
		case SN_OAMS_DSPH_TRXH_DSP_STATUS_IND:
			FETCH_PARAM1_PARAM2(OAMS_DSPH_TRXH_DSP_STATUS_IND)
				if (sndPtr == NULL)
				{
					LOG_PRINT(INFO,"Received NULL Pointer from module,Returning without sending to TRXH..\n") ;
					xReleaseSignal(SignalOut);
					return;
				}
			LOG_PRINT(INFO," Send OAMS_DSPH_TRXH_DSP_STATUS_IND :: msgSize = %d  msgType = 0x%x \n",msgSize , ((SysHdr *)sndPtr)->msgType);
			break;
#endif
		case SN_OAMS_DSPH_GRHM_ADD_TRAU_RESOURCE:
			FETCH_PARAM1_PARAM2(OAMS_DSPH_GRHM_ADD_TRAU_RESOURCE)
				if (sndPtr == NULL)
				{
					LOG_PRINT(INFO,"Received NULL Pointer from module,Returning without sending to GRHM..\n") ;
					xReleaseSignal(SignalOut);
					return;
				}
			LOG_PRINT(INFO," Send OAMS_DSPH_GRHM_ADD_TRAU_RESOURCE :: msgSize = %d  msgType = 0x%x \n",msgSize , ((SysHdr *)sndPtr)->msgType);
			break;

		case SN_OAMS_DSPH_GRHM_DEL_TRAU_RESOURCE:
			FETCH_PARAM1_PARAM2(OAMS_DSPH_GRHM_DEL_TRAU_RESOURCE)
				if (sndPtr == NULL)
				{
					LOG_PRINT(INFO,"Received NULL Pointer from module,Returning without sending to GRHM..\n") ;
					xReleaseSignal(SignalOut);
					return;
				}
			LOG_PRINT(INFO," Send OAMS_DSPH_GRHM_DEL_TRAU_RESOURCE :: msgSize = %d  msgType = 0x%x \n",msgSize , ((SysHdr *)sndPtr)->msgType);
			break;

    /*R2.8 changes :starts*/  
		case SN_OAMS_DSPH_GRHM_ADD_RTP_TRAU_RESOURCE:
			FETCH_PARAM1_PARAM2(OAMS_DSPH_GRHM_ADD_RTP_TRAU_RESOURCE)
				if (sndPtr == NULL)
				{
					LOG_PRINT(INFO,"Received NULL Pointer from module,Returning without sending to GRHM..\n") ;
					xReleaseSignal(SignalOut);
					return;
				}
			LOG_PRINT(INFO," Send OAMS_DSPH_GRHM_ADD_TRAU_RTP_RESOURCE :: msgSize = %d  msgType = 0x%x \n",msgSize , ((SysHdr *)sndPtr)->msgType);
			break;

		case SN_OAMS_DSPH_GRHM_DEL_RTP_TRAU_RESOURCE:
			FETCH_PARAM1_PARAM2(OAMS_DSPH_GRHM_DEL_RTP_TRAU_RESOURCE)
				if (sndPtr == NULL)
				{
					LOG_PRINT(INFO,"Received NULL Pointer from module,Returning without sending to GRHM..\n") ;
					xReleaseSignal(SignalOut);
					return;
				}
			LOG_PRINT(INFO," Send OAMS_DSPH_GRHM_DEL_RTP_TRAU_RESOURCE :: msgSize = %d  msgType = 0x%x \n",msgSize , ((SysHdr *)sndPtr)->msgType);
			break;
  /*R2.8 changes :ends*/
      
      
      /* R2.4 Changes : Starts */
		case SN_OAMS_DSPH_GRHM_TRAU_CHAN_CONF_FAIL:
                {  
		   FETCH_PARAM1_PARAM2(OAMS_DSPH_GRHM_TRAU_CHAN_CONF_FAIL)
		   if (sndPtr == NULL)
		   {
		      LOG_PRINT(INFO,"Received NULL Pointer from module,Returning without sending to GRHM..\n") ;
		      xReleaseSignal(SignalOut);
		      return;
		   }

		   LOG_PRINT(INFO," Send OAMS_DSPH_GRHM_TRAU_CHAN_CONF_FAIL :: msgSize = %d  msgType = 0x%x \n",msgSize , ((SysHdr *)sndPtr)->msgType);
                   break;
                }

		case SN_OAMS_DSPH_GRHM_TRAU_CHAN_DECONF_RESP:
                {  
		   FETCH_PARAM1_PARAM2(OAMS_DSPH_GRHM_TRAU_CHAN_DECONF_RESP)
		   if (sndPtr == NULL)
		   {
		      LOG_PRINT(INFO,"Received NULL Pointer from module,Returning without sending to GRHM..\n") ;
		      xReleaseSignal(SignalOut);
		      return;
		   }

		   LOG_PRINT(INFO," Send OAMS_DSPH_GRHM_TRAU_CHAN_DECONF_RESP :: msgSize = %d  msgType = 0x%x \n",msgSize , ((SysHdr *)sndPtr)->msgType);
                   break;
                }

		case SN_OAMS_DSPH_TSM_TRAU_CHAN_CONF_REQ:
                {  
		   FETCH_PARAM1_PARAM2(OAMS_DSPH_TSM_TRAU_CHAN_CONF_REQ)
		   if (sndPtr == NULL)
		   {
		      LOG_PRINT(INFO,"Received NULL Pointer from module,Returning without sending to TSM..\n") ;
		      xReleaseSignal(SignalOut);
		      return;
		   }

		   LOG_PRINT(INFO," Send OAMS_DSPH_TSM_TRAU_CHAN_CONF_REQ :: msgSize = %d  msgType = 0x%x \n",msgSize , ((SysHdr *)sndPtr)->msgType);
                   break;
                }

		case SN_OAMS_DSPH_TSM_TRAU_CHAN_DECONF_REQ:
                {  
		   FETCH_PARAM1_PARAM2(OAMS_DSPH_TSM_TRAU_CHAN_DECONF_REQ)
		   if (sndPtr == NULL)
		   {
		      LOG_PRINT(INFO,"Received NULL Pointer from module,Returning without sending to TSM..\n") ;
		      xReleaseSignal(SignalOut);
		      return;
		   }

		   LOG_PRINT(INFO," Send OAMS_DSPH_TSM_TRAU_CHAN_DECONF_REQ :: msgSize = %d  msgType = 0x%x \n",msgSize , ((SysHdr *)sndPtr)->msgType);
                   break;
                }
      /* R2.4 Changes : Ends */

		case SN_OAMS_DSPH_OIL_DSP_RESET_REQ:
			FETCH_PARAM1_PARAM2(OAMS_DSPH_OIL_DSP_RESET_REQ)
				if (sndPtr == NULL)
				{
					LOG_PRINT(INFO,"Received NULL Pointer from module,Returning without sending to OIL..\n") ;
					xReleaseSignal(SignalOut);
					return;
				}
			LOG_PRINT(INFO," Send OAMS_DSPH_OIL_DSP_RESET_REQ :: msgSize = %d  msgType = 0x%x \n",msgSize , ((SysHdr *)sndPtr)->msgType);
			break;

		case SN_OAMS_DSPH_TSM_DSP_IP_INFO_TRIGGER:
			FETCH_PARAM1_PARAM2(OAMS_DSPH_TSM_DSP_IP_INFO_TRIGGER)
				if (sndPtr == NULL)
				{
					LOG_PRINT(INFO,"Received NULL Pointer from module,Returning without sending to TSM..\n") ;
					xReleaseSignal(SignalOut);
					return;
				}
			LOG_PRINT(INFO," Send OAMS_DSPH_TSM_DSP_IP_INFO_TRIGGER :: msgSize = %d  msgType = 0x%x \n",msgSize , ((SysHdr *)sndPtr)->msgType);
			break;

		case SN_OAMS_DSPH_TSM_DSP_INIT:
			FETCH_PARAM1_PARAM2(OAMS_DSPH_TSM_DSP_INIT)
				if (sndPtr == NULL)
				{
					LOG_PRINT(INFO,"Received NULL Pointer from module,Returning without sending to TSM..\n") ;
					xReleaseSignal(SignalOut);
					return;
				}
			LOG_PRINT(INFO," Send OAMS_DSPH_TSM_DSP_INIT :: msgSize = %d  msgType = 0x%x \n",msgSize , ((SysHdr *)sndPtr)->msgType);
			break;

		case SN_OAMS_DSPH_TSM_TRAU_START:
			FETCH_PARAM1_PARAM2(OAMS_DSPH_TSM_TRAU_START)
				if (sndPtr == NULL)
				{
					LOG_PRINT(INFO,"Received NULL Pointer from module,Returning without sending to TSM..\n") ;
					xReleaseSignal(SignalOut);
					return;
				}
			LOG_PRINT(INFO," Send OAMS_DSPH_TSM_TRAU_START :: msgSize = %d  msgType = 0x%x \n",msgSize , ((SysHdr *)sndPtr)->msgType);
			break;

		/*R2.8 changes :Starts*/
    case SN_OAMS_DSPH_GRHM_RTP_TRAU_CHAN_CONF_FAIL:
                {  
		   FETCH_PARAM1_PARAM2(OAMS_DSPH_GRHM_RTP_TRAU_CHAN_CONF_FAIL)
		   if (sndPtr == NULL)
		   {
		      LOG_PRINT(INFO,"Received NULL Pointer from module,Returning without sending to GRHM..\n") ;
		      xReleaseSignal(SignalOut);
		      return;
		   }

		   LOG_PRINT(INFO," Send OAMS_DSPH_GRHM_RTP_TRAU_CHAN_CONF_FAIL :: msgSize = %d  msgType = 0x%x \n",msgSize , ((SysHdr *)sndPtr)->msgType);
                   break;
                }

		case SN_OAMS_DSPH_GRHM_RTP_TRAU_CHAN_DECONF_RESP:
                {  
		   FETCH_PARAM1_PARAM2(OAMS_DSPH_GRHM_RTP_TRAU_CHAN_DECONF_RESP)
		   if (sndPtr == NULL)
		   {
		      LOG_PRINT(INFO,"Received NULL Pointer from module,Returning without sending to GRHM..\n") ;
		      xReleaseSignal(SignalOut);
		      return;
       }		
 		   LOG_PRINT(INFO," Send OAMS_DSPH_GRHM_RTP_TRAU_CHAN_DECONF_RESP :: msgSize = %d  msgType = 0x%x \n",msgSize , ((SysHdr *)sndPtr)->msgType);
                   break;
                }
      /*R2.8 changes: Ends*/
    default:
			LOG_PRINT(INFO," Entered Default Case : xOutEnv \n");
			sndPtr = ((yPDP_sig_OAMS_DSPH_CFG_ALARM_IND)(*SignalOut))->Param1;
			if (sndPtr!=NULL)
			{
				DalocMsgBuf((I_Void *)sndPtr);
			}
			xReleaseSignal(SignalOut);
			return;

	}/*switch */

	LOG_PRINT(INFO," OUT OF SWITCH XOUT::ENV  ");
	if (sndPtr != NULL)
	{
		if (SendMsg(sndPtr, MSG_ORD_PRIO, msgSize) == SND_FAIL)
		{
			LOG_PRINT(INFO," SENDING FAILED ");
			DalocMsgBuf((I_Void *)sndPtr);
			xReleaseSignal(SignalOut);
			return;
		}
		else
		{
			LOG_PRINT(INFO,"Successfully sent message out ");
			xReleaseSignal(SignalOut);
			return;
		}
	}
	else
	{
		LOG_PRINT(CRITICAL,"DSPH: UNABLE TO ALLOCATE MEMORY FOR THE MESSAGE, sndPtr is NULL ");
	}

	//  XENV_OUT_START

}


/*---+---------------------------------------------------------------
  Macros for xInEnv
  -------------------------------------------------------------------*/
#ifndef IN_LOCAL_VARIABLES
#define IN_LOCAL_VARIABLES \
	xSignalNode S;
#endif

#ifndef IN_SIGNAL1
#define IN_SIGNAL1(SIGNAL_NAME, SIGNAL_NAME_STRING) \
	SignalIn = xGetSignal(SIGNAL_NAME, xNotDefPId, xEnv);
#endif

#ifndef IN_SIGNAL2
#define IN_SIGNAL2(SIGNAL_NAME, SIGNAL_NAME_STRING) \
	SDL_Output(SignalIn xSigPrioPar(xDefaultPrioSignal), (xIdNode *)0);
#endif

#ifndef IF_IN_SIGNAL
#define IF_IN_SIGNAL(SIGNAL_NAME, SIGNAL_NAME_STRING) \
	if (TEST_IF_IN_SIGNAL(SIGNAL_NAME)) {
#define END_IF_IN_SIGNAL(SIGNAL_NAME, SIGNAL_NAME_STRING) \
	}
#endif

#ifndef TEST_IF_IN_SIGNAL
#define TEST_IF_IN_SIGNAL(SIGNAL_NAME)  0
#endif

#ifndef XENV_DEC
#define XENV_DEC(stmt) stmt
#endif

#ifndef XENV_IN_START
#define XENV_IN_START
#endif

#ifndef XENV_IN_END
#define XENV_IN_END
#endif


/*---+---------------------------------------------------------------
  xInEnv  extern
  -------------------------------------------------------------------*/

#define GET_SIGNAL(input)\
{\
	S = xGetSignal( sig_##input, rcvr, xEnv);\
	(((yPDP_sig_##input)S)->Param1) = rcvPtr;\
}\

#define FILL_TIMER_DATA()\
{\
	searchPtr = (I_U8*)((I_U8*)rcvPtr + sizeof(SysHdr) + 12 );\
	trauConfigDeConfigTimeOutHandler(searchPtr);\
}


#ifndef XTENV
extern void xInEnv ( SDL_Time Time_for_next_event )
#else
extern SDL_Duration xInEnv ( SDL_Time Time_for_next_event )
#endif
{
	IN_LOCAL_VARIABLES

#ifdef XTRACE
#ifndef XNOXINENVTRACE
		xPrintString( "xInEnv: Called!\n");
#endif
#endif

	//  XENV_IN_START

	I_Void         *rcvPtr;
	I_S32          msgSize;
	I_S32          instId;
	I_U16          msgType;
	I_U8           subType;
	SDL_Pid        rcvr;
	I_U32          lclPidPtr;
	I_S32          errCode=ZERO;
	I_U32          dspId=ZERO;
	I_U8           messageId = ZERO;
	I_U8*          searchPtr=NULL;
	I_U32          refId = ZERO;
	I_U16          outSize = ZERO;
	I_U32          outRows = ZERO;
	TrauConfigDeConfigStruct     timerPayLoad;

	struct sAisParam *param;


	if ((rcvPtr = (I_Void *)RecvMsg(selfEntIdG, &msgSize)) != NULL)
  {
    msgType = ((SysHdr *)rcvPtr)->msgType;
    subType = ((SysHdr *)rcvPtr)->subType;
    instId = ((SysHdr *)rcvPtr)->dest.inst;
    LOG_PRINT(INFO,"Messgae Received for DSPH msgTyp = 0x%x and subType = %d",msgType,subType);
    rcvr.GlobalNodeNr = (I_S32)selfEntIdG;
    rcvr.LocalPId = (xLocalPIdNode)0;
    lclPidPtr = 0;

    //#ifndef BPM_PRESENT
    //      gCurrentCardState = CARDSTATE_ACTIVE;
    //#endif

    if ( gCurrentCardState == CARDSTATE_ACTIVE)
    {
      switch(msgType)
      {
        case OAMS_CFG_DSPH_DSP_AVAIL_STATUS:
          {  
            /*#ifndef BPM_PRESENT

              if(gInstancesCreated == I_FALSE)
              {	
              I_U16 instCount = 0, result=0;
              gCurrentCardState = CARDSTATE_IN_SERVICE;
              gNewCardState = BSC_APP_CARDSTATE_INVALID;
              LOG_PRINT(INFO,"No instances found in TauInst table so sending signal CRE_INSTS_REQ to Model");
              LOG_PRINT(INFO,"Initializing Inst Map Table...");
              InitInstMap(ENT_OAMS_DSPH,DSPH_HANDLER);
              result = GetInstCount(ENT_OAMS_DSPH, DSPH_HANDLER , &instCount);
              if ( result != INST_SUCCESS )
              {
              LOG_PRINT(MAJOR,"[ENV] GetInstCount Db call failed ");
            //return;
            }
            gInstCount = instCount;
            LOG_PRINT(MAJOR,"[ENV] After GetInstCount instCount(%d)", instCount);
            S = xGetSignal( sig_CRE_INST_REQ, xNotDefPId, xEnv);
            SDL_Output( S xSigPrioPar (xDefaultPrioSignal), (xIdNode *)0 );
            gInstancesCreated = I_TRUE;
            DalocMsgBuf((I_Void *)rcvPtr) ;
            return;  
            }
#endif
             */
            LOG_PRINT(DEBUG,"xInEnv : OAMS_CFG_DSPH_DSP_AVAIL_STATUS received");
            if ((rcvr.LocalPId = (xLocalPIdNode)FindDsphLocalPidByDspId(rcvPtr)) == 0)
            {
              LOG_PRINT(CRITICAL,"Failed to find Instance for OAMS_CFG_DSPH_DSP_AVAIL_STATUS request");
              refId = (I_U32)(((OamsCfgDsphDspAvailStatus*)rcvPtr)->dspId) + 1;
              LOG_PRINT(CRITICAL,"Allocating Instance with refId (%d)", refId);
              if (AlocNewInst(&lclPidPtr, &instId, ENT_OAMS_DSPH,
                    DSPH_HANDLER,refId,
                    ZERO, ZERO, ZERO, ZERO)  != INST_SUCCESS)
              {
                LOG_PRINT(CRITICAL, "xInEnv : AlocNewInst() Failed for DSPH");
                return;
              }
              LOG_PRINT(DEBUG, "xInEnv : NEW INSTANCE ALLOCATED FOR DSPH  \
                  LCLPID: 0x%0x, INSTANCE-ID: %d, DSP-ID: %d",
                  lclPidPtr, instId, dspId);
              rcvr.LocalPId = (xLocalPIdNode)lclPidPtr;
            }
            GET_SIGNAL(OAMS_CFG_DSPH_DSP_AVAIL_STATUS)
              break;
          }

        case OAMS_CFG_DSPH_DSP_BOOT_INFO:
          {
            LOG_PRINT(INFO,"OAMS_CFG_DSPH_DSP_BOOT_INFO: signal received from CFG");
            if ((rcvr.LocalPId = (xLocalPIdNode)FindDsphLocalPidByDspId(rcvPtr)) == 0)
            {
              LOG_PRINT(CRITICAL,"Failed to find Instance for Incoming request\n");
              DalocMsgBuf((I_Void *)rcvPtr) ;
              return ;
            }
            GET_SIGNAL(OAMS_CFG_DSPH_DSP_BOOT_INFO)
              break;
          }

        case OAMS_CFG_DSPH_DSP_DOWN_INFO:
          {
            LOG_PRINT(INFO,"OAMS_CFG_DSPH_DSP_DOWN_INFO: signal received from CFG");
            if ((rcvr.LocalPId = (xLocalPIdNode)FindDsphLocalPidByDspId(rcvPtr)) == 0)
            {
              LOG_PRINT(CRITICAL,"Failed to find Instance for Incoming request\n");
              DalocMsgBuf((I_Void *)rcvPtr) ;
              return ;
            }
            GET_SIGNAL(OAMS_CFG_DSPH_DSP_DOWN_INFO)
              break;
          }

        case OAMS_CFG_DSPH_DSP_LOCK_REQ:
          {
            LOG_PRINT(INFO,"OAMS_CFG_DSPH_DSP_LOCK_REQ: signal received from CFG");
            if ((rcvr.LocalPId = (xLocalPIdNode)FindDsphLocalPidByDspId(rcvPtr)) == 0)
            {
              LOG_PRINT(CRITICAL,"Failed to find Instance for Incoming request\n");
              DalocMsgBuf((I_Void *)rcvPtr) ;
              return ;
            }
            GET_SIGNAL(OAMS_CFG_DSPH_DSP_LOCK_REQ)
              break;
          }

        case OAMS_CFG_DSPH_DSP_UNLOCK_REQ:
          {
            LOG_PRINT(INFO,"OAMS_CFG_DSPH_DSP_UNLOCK_REQ: signal received from CFG");
            if ((rcvr.LocalPId = (xLocalPIdNode)FindDsphLocalPidByDspId(rcvPtr)) == 0)
            {
              LOG_PRINT(CRITICAL,"Failed to find Instance for Incoming request\n");
              DalocMsgBuf((I_Void *)rcvPtr) ;
              return ;
            }
            GET_SIGNAL(OAMS_CFG_DSPH_DSP_UNLOCK_REQ)
              break;
          }

        case OAMS_CFG_DSPH_DSP_RESET_REQ:
          {
            LOG_PRINT(INFO,"OAMS_CFG_DSPH_DSP_RESET_REQ: signal received from CFG");
            if ((rcvr.LocalPId = (xLocalPIdNode)FindDsphLocalPidByDspId(rcvPtr)) == 0)
            {
              LOG_PRINT(CRITICAL,"Failed to find Instance for Incoming request\n");
              DalocMsgBuf((I_Void *)rcvPtr) ;
              return ;
            }
            GET_SIGNAL(OAMS_CFG_DSPH_DSP_RESET_REQ)
              break;
          }

        case OAMS_CFG_DSPH_BSS_ADMINSTATE_IND:
          {
            LOG_PRINT(INFO,"OAMS_CFG_DSPH_BSS_ADMINSTATE_IND: signal received from CFG");
            if ((rcvr.LocalPId = (xLocalPIdNode)FindDsphLocalPidByDspId(rcvPtr)) == 0)
            {
              LOG_PRINT(CRITICAL,"Failed to find Instance for Incoming request\n");
              DalocMsgBuf((I_Void *)rcvPtr) ;
              return ;
            }
            GET_SIGNAL(OAMS_CFG_DSPH_BSS_ADMINSTATE_IND)
              break;
          }

        case OAMS_CFG_DSPH_RESET_FAIL_INFO:
          {
            LOG_PRINT(INFO,"OAMS_CFG_DSPH_RESET_FAIL_INFO: signal received from CFG");
            if ((rcvr.LocalPId = (xLocalPIdNode)FindDsphLocalPidByDspId(rcvPtr)) == 0)
            {
              LOG_PRINT(CRITICAL,"Failed to find Instance for Incoming request\n");
              DalocMsgBuf((I_Void *)rcvPtr) ;
              return ;
            }
            GET_SIGNAL(OAMS_CFG_DSPH_RESET_FAIL_INFO)
              break;
          }
#if 0	
        case OAMS_TRXH_DSPH_TRAU_CHAN_CONF_REQ:
          {
            LOG_PRINT(INFO,"OAMS_TRXH_DSPH_TRAU_CHAN_CONF_REQ: signal received from TRXH");
            ((SysHdr *)rcvPtr)->src.entity = ENT_OAMS_DSPH;
            ((SysHdr *)rcvPtr)->dest.entity = ENT_IPC_TSMIF;
            ((SysHdr *)rcvPtr)->msgType = EXT_TSM_MSG;
            /*             errCode = getallBssCsPreConfigTable( &bssCsPreConfigTableOutData, &outRows, &outSize);
                           if (errCode != CLIB_SUCCESS)
                           {
                           LOG_PRINT(CRITICAL,"Sending TRAU_CHAN_CONF_REQ to TSM without starting timer");
                           }
                           else
                           {
                           gTimerVal = (I_U32)(bssCsPreConfigTableOutData->tWaitDspResp);
                           gMaxNumDspMsgRetrans = (I_U32)(bssCsPreConfigTableOutData->maxNumDspMsgRetrans);
             */
            timerPayLoad.dspId     = ((DTrauMgsTrxhTrauChanConfReq *)rcvPtr)->trauHdr.DSP_Id;
            timerPayLoad.coreId    = ((DTrauMgsTrxhTrauChanConfReq *)rcvPtr)->trauHdr.Core_Id;
            timerPayLoad.trauIndex = ((DTrauMgsTrxhTrauChanConfReq *)rcvPtr)->trauHdr.Index;
            timerPayLoad.ptrxId    = (I_U8)((DTrauMgsTrxhTrauChanConfReq *)rcvPtr)->ptrxId;
            timerPayLoad.msgType   = OAMS_TRXH_DSPH_TRAU_CHAN_CONF_REQ;
            timerPayLoad.retrans   = (I_U8)gMaxNumDspMsgRetrans;
            timerPayLoad.ts        = ((DTrauMgsTrxhTrauChanConfReq *)rcvPtr)->timeSlot;
            ((DTrauMgsTrxhTrauChanConfReq *)rcvPtr)->subTimeSlot--; // Bug Fix 
            timerPayLoad.subTs     = ((DTrauMgsTrxhTrauChanConfReq *)rcvPtr)->subTimeSlot;
            timerPayLoad.msgId     = ((DTrauMgsTrxhTrauChanConfReq *)rcvPtr)->trauHdr.Msg_Id;
            LOG_PRINT(INFO,"timerPayLoad.dspId     (0x%x)",timerPayLoad.dspId    );
            LOG_PRINT(INFO,"timerPayLoad.coreId    (0x%x)",timerPayLoad.coreId   );
            LOG_PRINT(INFO,"timerPayLoad.trauIndex (0x%x)",timerPayLoad.trauIndex);
            LOG_PRINT(INFO,"timerPayLoad.ptrxId    (0x%x)",timerPayLoad.ptrxId   );
            LOG_PRINT(INFO,"timerPayLoad.msgType   (0x%x)",timerPayLoad.msgType  );
            LOG_PRINT(INFO,"timerPayLoad.retrans   (0x%x)",timerPayLoad.retrans  );
            LOG_PRINT(INFO,"timerPayLoad.ts        (0x%x)",timerPayLoad.ts       );
            LOG_PRINT(INFO,"timerPayLoad.subTs     (0x%x)",timerPayLoad.subTs    );
            LOG_PRINT(INFO,"timerPayLoad.msgId     (0x%x)",timerPayLoad.msgId    );
            dsphStartTimer(&timerPayLoad, gTimerVal);
            //             }
            if (SendMsg(rcvPtr, MSG_ORD_PRIO, msgSize) == SND_FAIL)
            {
              LOG_PRINT(INFO," SENDING FAILED ");
              DalocMsgBuf((I_Void *)rcvPtr);
              return;
            }
            else
            {
              LOG_PRINT(INFO,"Successfully sent message out ");
              return;
            }
            break;
          }

        case OAMS_TRXH_DSPH_TRAU_CHAN_DECONF_REQ:
          {
            LOG_PRINT(INFO,"OAMS_TRXH_DSPH_TRAU_CHAN_DECONF_REQ: signal received from TRXH");
            ((SysHdr *)rcvPtr)->src.entity = ENT_OAMS_DSPH;
            ((SysHdr *)rcvPtr)->dest.entity = ENT_IPC_TSMIF;
            ((SysHdr *)rcvPtr)->msgType = EXT_TSM_MSG;
            /*             errCode = getallBssCsPreConfigTable( &bssCsPreConfigTableOutData, &outRows, &outSize);
                           if (errCode != CLIB_SUCCESS)
                           {
                           LOG_PRINT(CRITICAL,"Sending TRAU_CHAN_DECONF_REQ to TSM without starting timer");
                           }
                           else
                           {
                           gTimerVal = (I_U32)(bssCsPreConfigTableOutData->tWaitDspResp);
                           gMaxNumDspMsgRetrans = (I_U32)(bssCsPreConfigTableOutData->maxNumDspMsgRetrans);
             */             timerPayLoad.dspId     = ((DTrauMgsTrxhTrauChanDeconfReq *)rcvPtr)->trauHdr.DSP_Id;
            timerPayLoad.coreId    = ((DTrauMgsTrxhTrauChanDeconfReq *)rcvPtr)->trauHdr.Core_Id;
            timerPayLoad.trauIndex = ((DTrauMgsTrxhTrauChanDeconfReq *)rcvPtr)->trauHdr.Index;
            timerPayLoad.ptrxId    = (I_U8)((DTrauMgsTrxhTrauChanDeconfReq *)rcvPtr)->ptrxId;
            timerPayLoad.msgType   = OAMS_TRXH_DSPH_TRAU_CHAN_DECONF_REQ;
            timerPayLoad.retrans   = (I_U8)gMaxNumDspMsgRetrans;
            timerPayLoad.ts        = INVALID;
            timerPayLoad.subTs     = INVALID;
            timerPayLoad.msgId     = ((DTrauMgsTrxhTrauChanDeconfReq *)rcvPtr)->trauHdr.Msg_Id;
            LOG_PRINT(INFO,"timerPayLoad.dspId     (0x%x)",timerPayLoad.dspId    );
            LOG_PRINT(INFO,"timerPayLoad.coreId    (0x%x)",timerPayLoad.coreId   );
            LOG_PRINT(INFO,"timerPayLoad.trauIndex (0x%x)",timerPayLoad.trauIndex);
            LOG_PRINT(INFO,"timerPayLoad.ptrxId    (0x%x)",timerPayLoad.ptrxId   );
            LOG_PRINT(INFO,"timerPayLoad.msgType   (0x%x)",timerPayLoad.msgType  );
            LOG_PRINT(INFO,"timerPayLoad.retrans   (0x%x)",timerPayLoad.retrans  );
            LOG_PRINT(INFO,"timerPayLoad.ts        (0x%x)",timerPayLoad.ts       );
            LOG_PRINT(INFO,"timerPayLoad.subTs     (0x%x)",timerPayLoad.subTs    );
            LOG_PRINT(INFO,"timerPayLoad.msgId     (0x%x)",timerPayLoad.msgId    );
            dsphStartTimer(&timerPayLoad, gTimerVal);
            //             }
            if (SendMsg(rcvPtr, MSG_ORD_PRIO, msgSize) == SND_FAIL)
            {
              LOG_PRINT(INFO," SENDING FAILED ");
              DalocMsgBuf((I_Void *)rcvPtr);
              return;
            }
            else
            {
              LOG_PRINT(INFO,"Successfully sent message out ");
              return;
            }
            break;
          }
#endif

          /* R2.4 Changes : Starts */
        case CSAPP_GRHM_DSPH_TRAU_CHAN_CONF_REQ:
          {
            LOG_PRINT(INFO,"CSAPP_GRHM_DSPH_TRAU_CHAN_CONF_REQ: signal received from GRHM");
            if ((rcvr.LocalPId = (xLocalPIdNode)FindDsphLocalPidByDspId(rcvPtr)) == 0)
            {
              LOG_PRINT(CRITICAL,"Failed to find Instance for Incoming request\n");
              DalocMsgBuf((I_Void *)rcvPtr) ;
              return ;
            }
            GET_SIGNAL(CSAPP_GRHM_DSPH_TRAU_CHAN_CONF_REQ)
              break;
          }

        case CSAPP_GRHM_DSPH_TRAU_CHAN_DECONF_REQ:
          {
            LOG_PRINT(INFO,"CSAPP_GRHM_DSPH_TRAU_CHAN_DECONF_REQ: signal received from GRHM");
            if ((rcvr.LocalPId = (xLocalPIdNode)FindDsphLocalPidByDspId(rcvPtr)) == 0)
            {
              LOG_PRINT(CRITICAL,"Failed to find Instance for Incoming request\n");
              DalocMsgBuf((I_Void *)rcvPtr) ;
              return ;
            }
            GET_SIGNAL(CSAPP_GRHM_DSPH_TRAU_CHAN_DECONF_REQ)
              break;
          }

          /* R2.4 Changes : Ends */

        case OAMS_OIL_DSPH_DSP_RESET_RESP:
          {
            LOG_PRINT(INFO,"OAMS_OIL_DSPH_DSP_RESET_RESP: signal received from OIL");
            if ((rcvr.LocalPId = (xLocalPIdNode)FindDsphLocalPidByDspId(rcvPtr)) == 0)
            {
              LOG_PRINT(CRITICAL,"Failed to find Instance for Incoming request\n");
              DalocMsgBuf((I_Void *)rcvPtr) ;
              return ;
            }
            GET_SIGNAL(OAMS_OIL_DSPH_DSP_RESET_RESP)
              break;
          }

#if 0
        case IPC_TIMER:
          {
            LOG_PRINT(INFO,"Timer Expiry received for Trau (Config/DeConfig) response");
            //FILL_TIMER_DATA()
            DalocMsgBuf((I_Void *)rcvPtr) ;
            return ;
          }
#endif

          /*R2.8 Changes : Starts*/
        case OAMS_CFG_DSPH_RTP_DSP_BOOT_INFO:
          {
            LOG_PRINT(INFO,"OAMS_CFG_DSPH_RTP_DSP_BOOT_INFO: signal received from CFG");
            if ((rcvr.LocalPId = (xLocalPIdNode)FindDsphLocalPidByDspId(rcvPtr)) == 0)
            {
              LOG_PRINT(CRITICAL,"Failed to find Instance for Incoming request\n");
              DalocMsgBuf((I_Void *)rcvPtr) ;
              return ;
            }
            GET_SIGNAL(OAMS_CFG_DSPH_RTP_DSP_BOOT_INFO)
              break;
          }

        case CSAPP_GRHM_DSPH_RTP_TRAU_CHAN_CONF_REQ:
          {
            LOG_PRINT(INFO,"CSAPP_GRHM_DSPH_RTP_TRAU_CHAN_CONF_REQ: signal received from GRHM");
            if ((rcvr.LocalPId = (xLocalPIdNode)FindDsphLocalPidByDspId(rcvPtr)) == 0)
            {
              LOG_PRINT(CRITICAL,"Failed to find Instance for Incoming request\n");
              DalocMsgBuf((I_Void *)rcvPtr) ;
              return ;
            }
            GET_SIGNAL(CSAPP_GRHM_DSPH_RTP_TRAU_CHAN_CONF_REQ)
              break;
          }

        case CSAPP_GRHM_DSPH_RTP_TRAU_CHAN_DECONF_REQ:
          {
            LOG_PRINT(INFO,"CSAPP_GRHM_DSPH_RTP_TRAU_CHAN_DECONF_REQ: signal received from GRHM");
            if ((rcvr.LocalPId = (xLocalPIdNode)FindDsphLocalPidByDspId(rcvPtr)) == 0)
            {
              LOG_PRINT(CRITICAL,"Failed to find Instance for Incoming request\n");
              DalocMsgBuf((I_Void *)rcvPtr) ;
              return ;
            }
            GET_SIGNAL(CSAPP_GRHM_DSPH_RTP_TRAU_CHAN_DECONF_REQ)
              break;
          }
          /*R2.8 Changes : Ends*/ 

        case EXT_TSM_MSG:
          {
            LOG_PRINT(INFO,"EXT_TSM_MSG: signal received from TSM");
            if ((rcvr.LocalPId = (xLocalPIdNode)FindDsphLocalPidByDspId(rcvPtr)) == 0)
            {
              LOG_PRINT(CRITICAL,"Failed to find Instance for Incoming request\n");
              DalocMsgBuf((I_Void *)rcvPtr) ;
              return ;
            }
            searchPtr = (I_U8*)((I_U8*)rcvPtr + sizeof(SysHdr) + sizeof(tHdr));
            messageId = (I_U8)(searchPtr[6]);

            LOG_PRINT(DEBUG,"\nMessageId - %d",messageId);

            PRINT_HEX_DUMP(DEBUG,(I_U8 *)rcvPtr,(I_U16)msgSize);
            switch (messageId)
            {
              case  GET_DSP_INFO_TRIGGER :
                dspId = ((DTrauMgsDspTriggerResp *)rcvPtr)->trauHdr.DSP_Id;
                LOG_PRINT(INFO,"GET_DSP_INFO_TRIGGER message id response: received from TSM for dspId (%d)", dspId);
                DalocMsgBuf((I_Void *)rcvPtr) ;
                return ;

              case  DSP_INIT_MSG_ID : 
                LOG_PRINT(INFO,"DSP_INIT_MSG_ID message id response: received from TSM for dspId (%d)", dspId);
                GET_SIGNAL(OAMS_TSM_DSPH_DSP_INIT_ACK)
                  break;

              case  DSP_TRAU_START_MSG_ID :
                LOG_PRINT(INFO,"DSP_TRAU_START_MSG_ID message id response: received from TSM for dspId (%d)", dspId);
                GET_SIGNAL(OAMS_TSM_DSPH_TRAU_START_ACK)
                  break;

                /* R2.4 Changes : Starts */
              case  TRAU_TS_CONF :
                LOG_PRINT(INFO,"TRAU_TS_CONF message id response: received from TSM ");

                GET_SIGNAL(OAMS_TSM_DSPH_TRAU_CHAN_CONF_RESP)
                  break;

#if 0
                dsphStopTimer(((DTrauMgsTrxhTrauChanConfResp *)rcvPtr)->trauHdr.DSP_Id,
                    ((DTrauMgsTrxhTrauChanConfResp *)rcvPtr)->trauHdr.Core_Id,
                    ((DTrauMgsTrxhTrauChanConfResp *)rcvPtr)->trauHdr.Index);

                ((SysHdr *)rcvPtr)->msgType = OAMS_DSPH_TRXH_TRAU_CHAN_CONF_RESP;
                ((SysHdr *)rcvPtr)->src.entity = ENT_OAMS_DSPH;
                ((SysHdr *)rcvPtr)->dest.entity = ENT_OAMS_TRXH;
                if (SendMsg(rcvPtr, MSG_ORD_PRIO, msgSize) == SND_FAIL)
                {
                  LOG_PRINT(INFO," SENDING FAILED ");
                  DalocMsgBuf((I_Void *)rcvPtr);
                  return;
                }
                else
                {
                  LOG_PRINT(INFO,"Successfully sent message out ");
                  return;
                }
#endif

              case  TRAU_TS_DECONF :
                LOG_PRINT(INFO,"TRAU_TS_DECONF message id response: received from TSM ");

                GET_SIGNAL(OAMS_TSM_DSPH_TRAU_CHAN_DECONF_RESP)
                  break;
#if 0			
                dsphStopTimer(((DTrauMgsTrxhTrauChanDeconfResp *)rcvPtr)->trauHdr.DSP_Id,
                    ((DTrauMgsTrxhTrauChanDeconfResp *)rcvPtr)->trauHdr.Core_Id,
                    ((DTrauMgsTrxhTrauChanDeconfResp *)rcvPtr)->trauHdr.Index);

                ((SysHdr *)rcvPtr)->msgType = OAMS_DSPH_TRXH_TRAU_CHAN_DECONF_RESP;
                ((SysHdr *)rcvPtr)->src.entity = ENT_OAMS_DSPH;
                ((SysHdr *)rcvPtr)->dest.entity = ENT_OAMS_TRXH;
                if (SendMsg(rcvPtr, MSG_ORD_PRIO, msgSize) == SND_FAIL)
                {
                  LOG_PRINT(INFO," SENDING FAILED ");
                  DalocMsgBuf((I_Void *)rcvPtr);
                  return;
                }
                else
                {
                  LOG_PRINT(INFO,"Successfully sent message out ");
                  return;
                }
#endif
                /* R2.4 Changes : Ends */

              default :
                LOG_PRINT(CRITICAL,"Invalid Msg Id (0x%x) is received from TSM", messageId);
                DalocMsgBuf((I_Void *)rcvPtr) ;
                return ;
            }// switch (messageId)
            break;
          }

          //BSC4.0 HA-Redundancy changes
#ifdef BPM_PRESENT
        case BPM_SELFCARD_STATE_CHANGE :


          LOG_PRINT(DEBUG,"xInEnv : LOCKING SEMAPHORE");
          if( SEM_WAIT(&gSemHandler) !=0)
            LOG_PRINT(DEBUG,"SEM_WAIT failed ");

          LOG_PRINT(DEBUG,"xInEnv : BPM_SELFCARD_STATE_CHANGE received ");
          param = (struct sAisParam *)((I_U8*)rcvPtr+sizeof(SysHdr));
          cardStateChangeHandler(param);
          LOG_PRINT(DEBUG,"xInEnv : WAITING FOR SEMAPHORE....");
          if( SEM_TIMED_WAIT(&gSemHandler) != SEMAPHORE_WAIT_COMPLETE)
          {
            LOG_PRINT(INFO,"Got Sempahore.. ");
            LOG_PRINT(INFO,"calling bpmRespondToAis.. ");
            bpmRespondToAis (param->invocation, OK);
            LOG_PRINT(INFO,"Response sent to BPM.. ");
            LOG_PRINT(INFO,"Releasing Sempahore.. ");
            SEM_POST(&gSemHandler);
          }
          else
          {
            LOG_PRINT(INFO,"Semaphore Wait Timed Out(4secs).. ");
            LOG_PRINT(INFO,"Releasing semaphore.. ");
            SEM_POST(&gSemHandler);
          }


          DalocMsgBuf((I_Void *)rcvPtr) ;
          return;
#endif

        case CSAPP_GRHM_DSPH_ADD_TRAU_RESOURCE_RESP:
          {
            LOG_PRINT(INFO,"CSAPP_GRHM_DSPH_ADD_TRAU_RESOURCE_RESP signal received from GRHM");
            if ((rcvr.LocalPId = (xLocalPIdNode)FindDsphLocalPidByDspId(rcvPtr)) == 0)
            {
              LOG_PRINT(CRITICAL,"Failed to find Instance for Incoming request\n");
              DalocMsgBuf((I_Void *)rcvPtr) ;
              return ;
            }
            GET_SIGNAL(CSAPP_GRHM_DSPH_ADD_TRAU_RESOURCE_RESP)
              break;
          }

        case CSAPP_GRHM_DSPH_ADD_RTP_TRAU_RESOURCE_RESP:
          {
            LOG_PRINT(INFO,"CSAPP_GRHM_DSPH_ADD_RTP_TRAU_RESOURCE_RESP signal received from GRHM");
            if ((rcvr.LocalPId = (xLocalPIdNode)FindDsphLocalPidByDspId(rcvPtr)) == 0)
            {
              LOG_PRINT(CRITICAL,"Failed to find Instance for Incoming request\n");
              DalocMsgBuf((I_Void *)rcvPtr) ;
              return ;
            }
            GET_SIGNAL(CSAPP_GRHM_DSPH_ADD_RTP_TRAU_RESOURCE_RESP)
              break;
          }

        default:
          LOG_PRINT(INFO," Entered Default Case : xInEnv ");
          DalocMsgBuf((I_Void *)rcvPtr) ;
          return ;
      } //switch(msgType) 
      SDL_Output( S xSigPrioPar(xDefaultPrioSignal), (xIdNode *)0 );
    } // if  gCurrentCardState == CARDSTATE_ACTIVE
    else
    {
      if (msgType == BPM_SELFCARD_STATE_CHANGE)
      {
#ifdef BPM_PRESENT
        LOG_PRINT(DEBUG,"xInEnv : LOCKING SEMAPHORE");
        if( SEM_WAIT(&gSemHandler) !=0)
          LOG_PRINT(DEBUG,"SEM_WAIT failed ");

        LOG_PRINT(DEBUG,"xInEnv : BPM_SELFCARD_STATE_CHANGE received ");
        param = (struct sAisParam *)((I_U8*)rcvPtr+sizeof(SysHdr));
        cardStateChangeHandler(param);
        LOG_PRINT(DEBUG,"xInEnv : WAITING FOR SEMAPHORE....");
        if( SEM_TIMED_WAIT(&gSemHandler) != SEMAPHORE_WAIT_COMPLETE)
        {
          LOG_PRINT(INFO,"Got Sempahore.. ");
          LOG_PRINT(INFO,"calling bpmRespondToAis.. ");
          bpmRespondToAis (param->invocation, OK);
          LOG_PRINT(INFO,"Response sent to BPM.. ");
          LOG_PRINT(INFO,"Releasing Sempahore.. ");
          SEM_POST(&gSemHandler);
        }
        else
        {
          LOG_PRINT(INFO,"Semaphore Wait Timed Out(4secs).. ");
          LOG_PRINT(INFO,"Releasing semaphore.. ");
          SEM_POST(&gSemHandler);
        }
#endif
      }
      else if (EXT_TSM_MSG == msgType)
      {
        LOG_PRINT(INFO,"EXT_TSM_MSG: signal received from TSM");
        searchPtr = (I_U8*)((I_U8*)rcvPtr + sizeof(SysHdr) + sizeof(tHdr));
        messageId = (I_U8)(searchPtr[6]);

        LOG_PRINT(DEBUG,"\nMessageId - %d",messageId);

        PRINT_HEX_DUMP(DEBUG,(I_U8 *)rcvPtr,(I_U16)msgSize);
        if (messageId == GET_DSP_INFO_TRIGGER)
        {
          dspId = ((DTrauMgsDspTriggerResp *)rcvPtr)->trauHdr.DSP_Id;
          LOG_PRINT(INFO,"GET_DSP_INFO_TRIGGER message id response: received from TSM for dspId (%d)", dspId);
          DalocMsgBuf((I_Void *)rcvPtr) ;
          return ;
        }
        else
        {
          LOG_PRINT(DEBUG,"Only GET_DSP_INFO_TRIGGER can be handled in non-ACTIVE state, So discarding the received message..... ");
          DalocMsgBuf((I_Void *)rcvPtr) ;
        }
      }
      else
      { 
        LOG_PRINT(DEBUG,"Card neither in Active State nor it is EXT_TSM_MSG, So discarding the received message..... ");
        DalocMsgBuf((I_Void *)rcvPtr) ;
      }
    } // else gCurrentCardState == CARDSTATE_ACTIVE
  }// if (rcvPtr = (I_Void *)RecvMsg(selfEntIdG, &msgSize)

	   //  XENV_IN_END

#ifdef XTENV
	   return SDL_Time_Lit((xint32)0,(xint32)0);
#endif

	}
