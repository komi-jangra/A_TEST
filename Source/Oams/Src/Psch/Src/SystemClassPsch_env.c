
/* SKELETON for env functions */
/* Program generated by Cadvanced 4.3.0.0.14276 */
#define XSCT_CADVANCED
#define XUSE_SIGNAL_NUMBERS

#ifndef XENV
#define XENV
#endif

/* To be placed in top level header file by Vihaan  */
#define DB_FAILURE_EXIT_CODE 0
#define BPM_FAILURE_EXIT_CODE 1
#define FRMWRK_FAILURE_EXIT_CODE 2
#define GETINST_FAILURE_EXIT_CODE 3
#define INVALID_REFERENCE_ID 100
#define REF_ID_ZERO 0

#define C_TRANSLATOR_4_1
#include "scttypes.h"
#ifdef XUSE_SIGNAL_NUMBERS
#include "SystemClassPsch.hs"
#endif
#ifdef XENV_INC
#include XENV_INC
#endif
#include "SystemClassPsch.ifc"

#define SELF_ENTITY_NAME "PSCH" 
#include <pthread.h>
#include "bpmxxx_platformLib.h"
#include "bpmxxx_OAM_commonDef.h"
#include "bpmxxx_commonDef.h"
#include "dbsxxx_commonwrappers.h"
#include "oamsxxx_semaphore.h" 
#include "oams_psch_datastruct.h" 
#include "oams_sig_handler.h" 

I_S32 gCurrentCardState = CARDSTATE_INIT;
I_S32 gNewCardState = BSC_APP_CARDSTATE_INVALID;
I_U32 gInstancesCreated = I_FALSE;
I_S32 gSignalSent = 0;
I_U16 gInstCount = 0;
I_U16 gPschInstCount = 0;
sem_t gSemHandler;
I_U32* gBvciList ;
I_S32 selfEntIdG = (int)ENT_OAMS_PSCH;

/*nse feature*/
I_U32 gNumPsCellNseLockUnlock = 0;
I_U16 gNsei;
I_U16 gNseProc = I_FALSE;
I_U32 gNseStatus = LOCKED;
#define PSCH_CLASS_ID 1
#define INVALID_BVCI  0

I_U32  systemLclPidPtr = INVALID_LCL_PID_PTR;
I_Void sendCfgNseLockUnlockResp(I_U16 nsei,I_U8 lockResp)
{
  OamsPschCfgNseLockResp *pNseLockResp = NULL;
  OamsPschCfgNseUnlockResp *pNseUnlockResp = NULL;   
  I_U32 msgSize;
  I_Void *sndPtr     = NULL;

  gNseProc = I_FALSE;
  /* same size as OamsPschCfgNseUnlockResp */
  msgSize = sizeof(OamsPschCfgNseLockResp);
  sndPtr = AlocMsgBuf(msgSize);
  if(sndPtr == NULL)
  { 
	LOG_PRINT(MAJOR,"Failure in allocating memory to outbound signal");
	return(PSCH_FAILURE);
  }
  if(lockResp == I_TRUE)
  {
	pNseLockResp = (OamsPschCfgNseLockResp *)(sndPtr);
	pNseLockResp->nsei = gNsei;
	FILL_SYS_HDR(pNseLockResp,OAMS_PSCH_CFG_NSE_LOCK_RESP,0,PRCR_PP,ENT_OAMS_PSCH,0,PRCR_CP,ENT_OAMS_CFG,0);
  }
  else	
  { 
	pNseUnlockResp = (OamsPschCfgNseUnlockResp *)(sndPtr);
	pNseUnlockResp->nsei = gNsei;
	FILL_SYS_HDR(pNseUnlockResp,OAMS_PSCH_CFG_NSE_UNLOCK_RESP,0,PRCR_PP,ENT_OAMS_PSCH,0,PRCR_CP,ENT_OAMS_CFG,0);
  }
  PRINT_HEX_DUMP(DEBUG,sndPtr,msgSize);

  if (SendMsg(sndPtr,MSG_ORD_PRIO,msgSize) == SND_FAIL)
  {
	LOG_PRINT(CRITICAL,"Message Sending Failed \n");
	DalocMsgBuf(sndPtr);
	return(PSCH_FAILURE);
  }
  else
  {
	LOG_PRINT(INFO,"Successfully sent message out \n");
	if(lockResp == I_TRUE)
	{
	  LOG_PRINT(INFO,"Successfully sent message out:OAMS_PSCH_CFG_NSE_LOCK_RESP \n");	
	}
	else
	{
	  LOG_PRINT(INFO,"Successfully sent message out:OAMS_PSCH_CFG_NSE_UNLOCK_RESP \n");
	}
	return ;
  }
}

#ifndef XNOGLOBALNODENUMBER
/*---+---------------------------------------------------------------
     xGlobalNodeNumber  extern
-------------------------------------------------------------------*/
#ifndef XENV_NODENUMBER
#define XENV_NODENUMBER return 1;
#endif

extern int xGlobalNodeNumber(void)
{
  /* Assign a unique global system Id to each SDL system in a cluster of systems. */
   return ENT_OAMS_PSCH;
}
#endif

  /** 
  * Interface with Base Platform Module BPM
  * Note1: BPM is an optional feature in the system.
  * All code pertaining to BPM interface should be under a compile time
  * flag.
  */

#if BPM_PRESENT != 1

   #define RegisterPschWithBpm() bpmGetComponentReg(ENT_OAMS_PSCH_STUB,&PschBpmCallbackFunc); 
   /* Changes for HA Start */
   #define bpmRespondToAis(a,b)
   /* Changes for HA End */
   #warning "BPM support not compiled"

#else

void PschBpmCallbackFunc (struct sAisParam *param);
void RegisterPschWithBpm(void)
{
   bpmGetComponentRegister (PschBpmCallbackFunc, APPID_OAMS_PSCH);
   bpmComponentConfigure ();
}
#endif
 /* BPM_PRESENT */
/********************************************************************/
/* Changes for HA Start */
I_Void  updateCardStatus()
{
   LOG_PRINT(DEBUG,"inside updateCardStatus ");
   gCurrentCardState = gNewCardState;
   gNewCardState = BSC_APP_CARDSTATE_INVALID;
   LOG_PRINT(DEBUG,"inside updateCardStatus %d",gCurrentCardState);
}
I_U8* getCardStateNameStr(I_S32 cardState)
{
   I_U8 *pCardStateNameStr = "BSC_APP_CARDSTATE_INVALID" ;
   switch(cardState)
   {
      case CARDSTATE_INIT:
         pCardStateNameStr = "CARDSTATE_INIT";
	 break;
      case CARDSTATE_PLATFORM_INS:
         pCardStateNameStr = "CARDSTATE_PLATFORM_INS";
	 break;
      case CARDSTATE_IN_SERVICE:
         pCardStateNameStr = "CARDSTATE_IN_SERVICE";
	 break;
      case CARDSTATE_ACTIVE:
         pCardStateNameStr = "CARDSTATE_ACTIVE";
	 break;
      case CARDSTATE_STANDBY:
         pCardStateNameStr = "CARDSTATE_STANDBY";
	 break;
      case CARDSTATE_OUT_OF_SERVICE:
         pCardStateNameStr = "CARDSTATE_OUT_OF_SERVICE";
	 break;
      case CARDSTATE_RECOVERY:
         pCardStateNameStr = "CARDSTATE_RECOVERY";
	 break;
      case CARDSTATE_FAIL:
         pCardStateNameStr = "CARDSTATE_FAIL";
	 break;
      case CARDSTATE_TEST:
         pCardStateNameStr = "CARDSTATE_TEST";
	 break;
      case CARDSTATE_ABSENT:
         pCardStateNameStr = "CARDSTATE_ABSENT";
	 break;
      case CARDSTATE_ACTIVE_IN_PROGRESS:
         pCardStateNameStr = "CARDSTATE_ACTIVE_IN_PROGRESS";
	 break;
      case CARDSTATE_UPGRADE:
         pCardStateNameStr = "CARDSTATE_UPGRADE";
	 break;
      case CARDSTATE_RESTART:
         pCardStateNameStr = "CARD_RESTART";
	 break;
      default:
	 break;
   }
   return (pCardStateNameStr);
}
I_U32 sendCntxtDataToModel()
{
    LOG_PRINT(DEBUG,"in func sendCntxtDataToModel");
  xSignalNode     S;
  SDL_Pid         rcvr;
  I_U32           lclPidPtr = INVALID_LCL_PID_PTR ;
  I_S32           instId = ZERO;
  I_U16           instCount = ZERO;
  rcvr.GlobalNodeNr = (I_S32)selfEntIdG;
  I_S32 dbCallResult;
  I_U32 numRows;
  I_U16 dataSize;
  PschCtxtTableApi *pschCtxtbTable;
  PschRedCtxt *pschRedCtxt;
  I_U32 refId1,refId2;
  I_S32           index;
  /* Changes for HotStb start here     */
  //read db for context
  //getall new instance as the data is  

  dbCallResult = getallPschCtxtTable(&(pschCtxtbTable),&(numRows),&(dataSize));
  if (dbCallResult != DBLIB_SUCCESS)
  {
    LOG_PRINT(CRITICAL,"Failed: db call for PschCtxtTable, error code = [%d]",dbCallResult);
    return PSCH_FAILURE; 
  }
  else
  {
    LOG_PRINT(DEBUG,"db call for PschCtxtTable success %d",numRows);
    //send message allocate new instances 
    for(instCount=0;instCount<numRows;instCount++)
    {
      pschRedCtxt = AlocOrdBuf(sizeof(PschRedCtxt));
      memcpy(pschRedCtxt,  ((I_U8*)pschCtxtbTable + dataSize*instCount),sizeof(PschRedCtxt));   
      refId1 = pschRedCtxt->bvcId;
      refId2 = pschRedCtxt->cellIndex;
      refId2 = refId2 + 1 ;  //this is specific to PSCH 
      // As IPC replicats the instance map. It will be for allocated instance and lclpid ptr will be provided. 
      //Instead of allocatNewInstance it will be update lclpidptr for the instance Id 


      if (SearchAlocatedInst(&lclPidPtr,&instId,ENT_OAMS_PSCH,PSCH_CLASS_ID,refId1,refId2,0,0,0) != INST_SUCCESS)
      {
        LOG_PRINT(MAJOR,"(ENV:xInEnv)No PSCH Inst found for CellIndex - [%d]  = [%d] so allocting one \n",refId2,refId1);

        if (ZERO == gPschInstCount)
        {
          LOG_PRINT(CRITICAL,"(ENV:xInEnv)No PSCH Found...\n");
          free(pschCtxtbTable);
          DalocMsgBuf(pschRedCtxt);
          return PSCH_FAILURE; 
        }
        if (AlocNewInst(&lclPidPtr,&instId,ENT_OAMS_PSCH,PSCH_CLASS_ID,refId1,refId2,0,0,0) != INST_SUCCESS )
        {
          LOG_PRINT(CRITICAL,"(ENV:xInEnv)Unable to create New Instance...\n") ;
          free(pschCtxtbTable);
          DalocMsgBuf(pschRedCtxt);
          return PSCH_FAILURE; 
        }
        if (0 == lclPidPtr)
        {
          LOG_PRINT(CRITICAL,"(ENV:xInEnv)Invalid Instance Found...\n");
          free(pschCtxtbTable);
          DalocMsgBuf(pschRedCtxt);
          return PSCH_FAILURE; 
        }
        for (index = 0; index < gPschInstCount; index ++)
        {
          if (gBvciList[index] == INVALID_BVCI)
            break;
        }
        LOG_PRINT(DEBUG,"xInEnv: Storing bvci - [%u] at index [%d]", refId1, index);
        gBvciList[index] = refId1;
        rcvr.LocalPId = (xLocalPIdNode)lclPidPtr;
        LOG_PRINT(INFO,"(ENV:xInEnv)Value of Local Pid Pointer - [%d]",lclPidPtr)
          /* Send this Message into TAU model */
        S = xGetSignal( sig_PSCH_INT_STANDBY_TO_AIP, rcvr, xEnv);
        ((yPDP_sig_PSCH_INT_STANDBY_TO_AIP)S)->Param1 = pschRedCtxt;
        SDL_Output( S xSigPrioPar(xDefaultPrioSignal), (xIdNode *)0 );
      }//if search does fails
      else
      {
        if (0 == lclPidPtr)
        {
          LOG_PRINT(CRITICAL,"(ENV:xInEnv)Invalid Instance Found...\n");
          free(pschCtxtbTable);
          DalocMsgBuf(pschRedCtxt);
          return PSCH_FAILURE; 
        }
        for (index = 0; index < gPschInstCount; index ++)
        {
          if (gBvciList[index] == INVALID_BVCI)
            break;
        }
        LOG_PRINT(DEBUG,"xInEnv: Storing bvci - [%u] at index [%d]", refId1, index);
        gBvciList[index] = refId1;
        rcvr.LocalPId = (xLocalPIdNode)lclPidPtr;
         S = xGetSignal( sig_PSCH_INT_STANDBY_TO_AIP, rcvr, xEnv);
        ((yPDP_sig_PSCH_INT_STANDBY_TO_AIP)S)->Param1 = pschRedCtxt;
        SDL_Output( S xSigPrioPar(xDefaultPrioSignal), (xIdNode *)0 );
      }

#if 0
      if (AlocNewInst(&lclPidPtr,&instId,ENT_OAMS_PSCH,PSCH_CLASS_ID,refId1,refId2,0,0,0) != INST_SUCCESS ) 
      {
        LOG_PRINT(CRITICAL,"(ENV:xInEnv)Unable to create New Instance...\n") ;
        free(pschCtxtbTable);
        DalocMsgBuf(pschRedCtxt);
        return PSCH_FAILURE; 
      }
      if (0 == lclPidPtr)
      {
        LOG_PRINT(CRITICAL,"(ENV:xInEnv)Invalid Instance Found...\n");
        DalocMsgBuf(pschRedCtxt);
        free(pschCtxtbTable);
        return PSCH_FAILURE; 
      }
      for (index = 0; index < gPschInstCount; index++)
      {
        if (gBvciList[index] == INVALID_BVCI)
          break;
      }
      LOG_PRINT(DEBUG,"xInEnv: Storing bvci - [%u] at index [%d]", refId1, index);
      gBvciList[index] = refId1;
      rcvr.LocalPId = (xLocalPIdNode)lclPidPtr;
      LOG_PRINT(INFO,"(ENV:xInEnv)Value of Local Pid Pointer - [%d]",lclPidPtr)
        //send the data and move to the state in the model
        /* Send this Message into TAU model */
      LOG_PRINT(INFO,"(BPM)Sending signal PSCH_INT_STANDBY_TO_AIP to Model");
      S = xGetSignal( sig_PSCH_INT_STANDBY_TO_AIP, rcvr, xEnv);
      ((yPDP_sig_PSCH_INT_STANDBY_TO_AIP)S)->Param1 = pschRedCtxt;
      SDL_Output( S xSigPrioPar(xDefaultPrioSignal), (xIdNode *)0 );
 #endif
    }//end for loop
    free(pschCtxtbTable);
  }//else db call is success       
  return PSCH_SUCCESS; 
}
I_S32 sendSelfCardStateChange()
{
   xSignalNode     S;
   SDL_Pid         rcvr;
   I_U32           lclPidPtr = INVALID_LCL_PID_PTR ;
   I_S32           instId = ZERO;
   I_S8            instCountResult = ZERO;
   I_U16           instCount = ZERO;
   rcvr.GlobalNodeNr = (I_S32)selfEntIdG;

   instCountResult = GetInstCount(ENT_OAMS_PSCH, PSCH_CLASS_ID , &instCount);
   for ( instId = 1; instId <= instCount; instId ++ )
   {
      GetLclPidFrmInstId( &lclPidPtr, instId, (I_U8)ENT_OAMS_PSCH , 1);
      LOG_PRINT(DEBUG,"(BPM)findLclPidPtr Success lclPid = %d",(I_U32)lclPidPtr);
      if (lclPidPtr != INVALID_LCL_PID_PTR )
      {
         rcvr.LocalPId = (xLocalPIdNode)lclPidPtr;
         LOG_PRINT(INFO,"(BPM)Sending signal PSCH_INT_SELFCARD_STATE_CHANGE to Model");
         S = xGetSignal( sig_PSCH_INT_SELFCARD_STATE_CHANGE, rcvr, xEnv);
         SDL_Output( S xSigPrioPar(xDefaultPrioSignal), (xIdNode *)0 );
         gSignalSent ++;
      }
   }
   return(gSignalSent);
}


I_Void cardStateChangeHandler(struct sAisParam *param)
{
   xSignalNode     S;
   SDL_Pid         rcvr;
   I_S32           result = ZERO;
   I_S8            instCountResult = ZERO;
   I_U16           instCount = ZERO;
   I_S32           signalSentCount = ZERO;
   I_S32           index;
   rcvr.GlobalNodeNr = (I_S32)selfEntIdG;
   rcvr.LocalPId = (xLocalPIdNode)0;
   LOG_PRINT(INFO,"(BPM)BPM_SELFCARD_STATE_CHANGE received. Current State=[%s], Received State=[%s]",getCardStateNameStr(gCurrentCardState),getCardStateNameStr(param->cardState)) ;

   /* INIT -> INSERVICE */
   if ( (param->cardState == CARDSTATE_IN_SERVICE) && (gCurrentCardState == CARDSTATE_INIT) )
   {
      gNewCardState = CARDSTATE_IN_SERVICE;
      LOG_PRINT(DEBUG,"(BPM)Registering with DB Server...");
      result = dbConnect();
      if ( result != DBLIB_SUCCESS )
      {
         LOG_PRINT(CRITICAL,"(BPM)Unable to Register itself with DBServer:Exiting");
         exit(DB_FAILURE_EXIT_CODE);
      }
      LOG_PRINT(DEBUG,"(BPM)Successfully Registered with DB Server.");
/* Changes for HotStb start here     */
      if(gInstancesCreated == I_FALSE)
      {
         LOG_PRINT(INFO,"(BPM)No instances found in TauInst table so sending signal to Model to create instances");
         LOG_PRINT(INFO,"(BPM)Initializing Inst Map Table...\n");
         InitInstMap(ENT_OAMS_PSCH,PSCH_CLASS_ID);
         result = GetInstCount(ENT_OAMS_PSCH, PSCH_CLASS_ID , &instCount);
         if(result != INST_SUCCESS)
         {
           LOG_PRINT(MAJOR,"(BPM)GetInstCount Db call failed...... ");
           updateCardStatus();
           LOG_PRINT(INFO,"(BPM)Releasing semaphore.. ");
           SEM_POST(&gSemHandler);
           LOG_PRINT(CRITICAL,"Exiting ");
           exit(DB_FAILURE_EXIT_CODE);
         }
         else if(ZERO == instCount)
         {
           LOG_PRINT(MAJOR,"(BPM): Psch inst count in db = 0...... ");
           updateCardStatus();
           LOG_PRINT(INFO,"(BPM)Releasing semaphore.. ");
           SEM_POST(&gSemHandler);
           LOG_PRINT(CRITICAL,"Exiting ");
           exit(DB_FAILURE_EXIT_CODE);
         }
         else
         {
            gInstCount = instCount;
            gPschInstCount = instCount;
            LOG_PRINT(DEBUG,"(Env:) no of PSCH instances = %d",instCount);
            S = xGetSignal( sig_PSCH_INT_ADD_TAU_INSTANCE, xNotDefPId, xEnv);
            SDL_Output( S xSigPrioPar(xDefaultPrioSignal), (xIdNode *)0 );
            gBvciList = AlocOrdBuf(instCount*(sizeof(I_U32)));
            result = REGISTER_CONTEXT((I_Void *)gBvciList,instCount*(sizeof(I_U32)),1);
            if(result == -1){

               LOG_PRINT(MAJOR, "(Env:) Max 10 context can be registerd with signal handler"); 

            } 
            if (NULL == gBvciList)
            {
               LOG_PRINT(MAJOR, "(Env:) Sufficient memory not available");
            }
            else
            {
               for (index = 0; index < instCount; index ++)
               {
                  gBvciList[index] = INVALID_BVCI;
               }
            }
         }
      }
/* Changes for HotStb end here     */
   }

   /* ACTIVE -> INSERVICE*/
   else if ( (param->cardState == CARDSTATE_IN_SERVICE) && ( gCurrentCardState == CARDSTATE_ACTIVE) )
   {
      gNewCardState = CARDSTATE_IN_SERVICE;
      instCountResult = GetInstCount(ENT_OAMS_PSCH, PSCH_CLASS_ID , &instCount);
      if ( instCountResult != INST_SUCCESS )
      {
         LOG_PRINT(MAJOR,"(BPM)GetInstCount Db call failed.. ");
         instCount = 0 ;
      }
      signalSentCount = sendSelfCardStateChange();
      
      if (0 == signalSentCount)
      {
         updateCardStatus();
         LOG_PRINT(INFO,"(BPM)Moving from ACTIVE to INSERVICE.. ");
         LOG_PRINT(INFO,"(BPM)No messages sent so releasing semaphore ");
         SEM_POST(&gSemHandler);
      }
      DalocMsgBuf(gBvciList);
   }

   /* INSERVICE -> STANDBY*/
   else if ( (param->cardState == CARDSTATE_STANDBY) && (gCurrentCardState == CARDSTATE_IN_SERVICE) )
   {
      gNewCardState = CARDSTATE_STANDBY;
      updateCardStatus();
      LOG_PRINT(INFO,"(BPM)Moving from INSERVICE to STANDBY.. ");
      LOG_PRINT(INFO,"(BPM)Releasing semaphore.. ");
      SEM_POST(&gSemHandler);
   }

   /* INSERVICE -> ACTIVEINPROGRESS*/
   else if ( (param->cardState == CARDSTATE_ACTIVE_IN_PROGRESS) && ( gCurrentCardState == CARDSTATE_IN_SERVICE) )
   {
     gNewCardState = CARDSTATE_ACTIVE_IN_PROGRESS;

     updateCardStatus();
     LOG_PRINT(INFO,"(BPM)Moving from INSERVICE to ACTIVEINPROGRESS.. ");
     LOG_PRINT(INFO,"(BPM)Releasing semaphore.. ");
     SEM_POST(&gSemHandler);
   }
   /* STANDBY -> ACTIVEINPROGRESS*/
   else if ( (param->cardState == CARDSTATE_ACTIVE_IN_PROGRESS) && (gCurrentCardState == CARDSTATE_STANDBY ) )
   {
     /* Changes for HotStb end here     */
      sendCntxtDataToModel(); 

     gNewCardState = CARDSTATE_ACTIVE_IN_PROGRESS;
     updateCardStatus();
     LOG_PRINT(INFO,"(BPM)Moving from STANDBY to ACTIVEINPROGRESS.. ");
     LOG_PRINT(INFO,"(BPM)Releasing semaphore.. ");
     SEM_POST(&gSemHandler);
   }
   /* ACTIVEINPROGRESS -> ACTIVE */
   else if ( (param->cardState == CARDSTATE_ACTIVE) && (gCurrentCardState == CARDSTATE_ACTIVE_IN_PROGRESS) )
   {
      gNewCardState = CARDSTATE_ACTIVE;
/* Changes for HotStb start here     */
#if 0
      gNewCardState = CARDSTATE_ACTIVE;
      if(gInstancesCreated == I_FALSE)
      {
         LOG_PRINT(INFO,"(BPM)No instances found in TauInst table so sending signal to Model to create instances");
         LOG_PRINT(INFO,"(BPM)Initializing Inst Map Table...\n");
         InitInstMap(ENT_OAMS_PSCH,PSCH_CLASS_ID);
         result = GetInstCount(ENT_OAMS_PSCH, PSCH_CLASS_ID , &instCount);
         if(result != INST_SUCCESS)
         {
            LOG_PRINT(MAJOR,"(BPM)GetInstCount Db call failed...... ");
            updateCardStatus();
            LOG_PRINT(INFO,"(BPM)Moving from ACTIVEINPROGRESS to ACTIVE.. ");
            LOG_PRINT(INFO,"(BPM)Releasing semaphore.. ");
            SEM_POST(&gSemHandler);
         }
         else if(ZERO == instCount)
         {
            LOG_PRINT(MAJOR,"(BPM): Psch inst count in db = 0...... ");
            updateCardStatus();
            LOG_PRINT(INFO,"(BPM)Moving from ACTIVEINPROGRESS to ACTIVE.. ");
            LOG_PRINT(INFO,"(BPM)Releasing semaphore.. ");
            SEM_POST(&gSemHandler);
         }
         else
         {
            gInstCount = instCount;
            gPschInstCount = instCount;
            LOG_PRINT(DEBUG,"(Env:) no of PSCH instances = %d",instCount);
            S = xGetSignal( sig_PSCH_INT_ADD_TAU_INSTANCE, xNotDefPId, xEnv);
            SDL_Output( S xSigPrioPar(xDefaultPrioSignal), (xIdNode *)0 );
            gBvciList = AlocOrdBuf(instCount*(sizeof(I_U32)));
            if (NULL == gBvciList)
            {
               LOG_PRINT(MAJOR, "(Env:) Sufficient memory not available");
            }
            else
            {
               for (index = 0; index < instCount; index ++)
               {
                  gBvciList[index] = INVALID_BVCI;
               }
            }
         }
      }
      else
      {
#endif
/* Changes for HotStb end here     */
         updateCardStatus();
         LOG_PRINT(INFO,"(BPM)Moving from ACTIVEINPROGRESS to ACTIVE.. ");
         LOG_PRINT(INFO,"(BPM)Releasing semaphore.. ");
         SEM_POST(&gSemHandler);
/* Changes for HotStb start here     */
     // }
/* Changes for HotStb end here     */
   }

   /* STANDBY -> RECOVERY */
   else if ( (param->cardState == CARDSTATE_RECOVERY) && (gCurrentCardState == CARDSTATE_STANDBY) )
   {
      gNewCardState = CARDSTATE_RECOVERY;
      updateCardStatus();
      LOG_PRINT(INFO,"(BPM)Moving from STANDBY to RECOVERY.. ");
      LOG_PRINT(INFO,"(BPM)Releasing semaphore.. ");
      SEM_POST(&gSemHandler);
   }
   /* STANDBY -> OUTOFSERVICE */
   else if ( (param->cardState == CARDSTATE_OUT_OF_SERVICE) && (gCurrentCardState == CARDSTATE_STANDBY) )
   {
      gNewCardState = CARDSTATE_OUT_OF_SERVICE;
      updateCardStatus();
      LOG_PRINT(INFO,"(BPM)Moving from STANDBY to OUTOFSERVICE.. ");
      LOG_PRINT(INFO,"(BPM)Releasing semaphore.. ");
      SEM_POST(&gSemHandler);
   }

  /* ACTIVE -> RECOVERY */
   else if ( (param->cardState == CARDSTATE_RECOVERY) && (gCurrentCardState == CARDSTATE_ACTIVE) )
   {
      gNewCardState = CARDSTATE_RECOVERY;
      instCountResult = GetInstCount(ENT_OAMS_PSCH, PSCH_CLASS_ID , &instCount);
      if ( instCountResult != INST_SUCCESS )
      {
         LOG_PRINT(MAJOR,"(BPM)GetInstCount Db call failed.. ");
         instCount = 0 ;
      }
      signalSentCount = sendSelfCardStateChange();

      if (0 == signalSentCount)
      {
         updateCardStatus();
         LOG_PRINT(INFO,"(BPM)Moving from ACTIVE to RECOVERY.. ");
         LOG_PRINT(INFO,"(BPM)No messages sent so releasing semaphore ");
         SEM_POST(&gSemHandler);
      }
      DalocMsgBuf(gBvciList);
   }
   /* RECOVERY -> INSERVICE */
   else if ( (param->cardState == CARDSTATE_IN_SERVICE) && (gCurrentCardState == CARDSTATE_RECOVERY) )
   {
     gNewCardState = CARDSTATE_IN_SERVICE;
     /* DeRegister with DB */
     if ((result = dbDestroy()) != DBLIB_SUCCESS)
     {
       LOG_PRINT(MAJOR,"(BPM)dbDestroy failed for Module (Error = %d)",result);
       /* Need to re-confirm what to do in such case */
     }

     LOG_PRINT(DEBUG,"(BPM)Registering with DB Server...");
     result = dbConnect();
     if ( result != DBLIB_SUCCESS )
     {
       LOG_PRINT(CRITICAL,"(BPM)Unable to Register itself with DBServer:Exiting");
       exit(DB_FAILURE_EXIT_CODE);
     }
     LOG_PRINT(DEBUG,"(BPM)Successfully Registered with DB Server.");
/* Changes for HotStb start here     */
     gBvciList = AlocOrdBuf(instCount*(sizeof(I_U32)));
     if (NULL == gBvciList)
     {
       LOG_PRINT(MAJOR, "(Env:) Sufficient memory not available");
     }
     else
     {
       for (index = 0; index < instCount; index ++)
       {
         gBvciList[index] = INVALID_BVCI;
       }
     }
/* Changes for HotStb end here     */
     updateCardStatus();
     LOG_PRINT(INFO,"(BPM)Moving from RECOVERY to INSERVICE.. ");
     LOG_PRINT(INFO,"(BPM)Releasing semaphore.. ");
     SEM_POST(&gSemHandler);
   }
   /* OUTOFSERVICE -> INSERVICE */
   else if ( (param->cardState == CARDSTATE_IN_SERVICE) && (gCurrentCardState == CARDSTATE_OUT_OF_SERVICE) )
   {
     gNewCardState = CARDSTATE_IN_SERVICE;
     /* DeRegister with DB */
     if ((result = dbDestroy()) != DBLIB_SUCCESS)
     {
       LOG_PRINT(MAJOR,"(BPM)dbDestroy failed for Module (Error = %d)",result);
       /* Need to re-confirm what to do in such case */
     }

     LOG_PRINT(DEBUG,"(BPM)Registering with DB Server...");
     result = dbConnect();
     if ( result != DBLIB_SUCCESS )
     {
       LOG_PRINT(CRITICAL,"(BPM)Unable to Register itself with DBServer:Exiting");
       exit(DB_FAILURE_EXIT_CODE);
     }
     LOG_PRINT(DEBUG,"(BPM)Successfully Registered with DB Server.");
/* Changes for HotStb start here     */
     gBvciList = AlocOrdBuf(instCount*(sizeof(I_U32)));
     if (NULL == gBvciList)
     {
       LOG_PRINT(MAJOR, "(Env:) Sufficient memory not available");
     }
     else
     {
       for (index = 0; index < instCount; index ++)
       {
         gBvciList[index] = INVALID_BVCI;
       }
     }
/* Changes for HotStb end here     */
     updateCardStatus();
     LOG_PRINT(INFO,"(BPM)Moving from OUTOFSERVICE to INSERVICE.. ");
     LOG_PRINT(INFO,"(BPM)Releasing semaphore.. ");
     SEM_POST(&gSemHandler);
   }

   /* ACTIVE -> OUTOFSERVICE */
   else if ( (param->cardState == CARDSTATE_OUT_OF_SERVICE) && (gCurrentCardState == CARDSTATE_ACTIVE) )
   {
      gNewCardState = CARDSTATE_OUT_OF_SERVICE;
      instCountResult = GetInstCount(ENT_OAMS_PSCH, PSCH_CLASS_ID , &instCount);
      if ( instCountResult != INST_SUCCESS )
      {
         LOG_PRINT(MAJOR,"(BPM)GetInstCount Db call failed.. ");
         instCount = 0 ;
      }
      signalSentCount = sendSelfCardStateChange();

      if (0 == signalSentCount)
      {
         updateCardStatus();
         LOG_PRINT(INFO,"(BPM)Moving from ACTIVE to OUTOFSERVICE.. ");
         LOG_PRINT(INFO,"(BPM)No messages sent so releasing semaphore ");
         SEM_POST(&gSemHandler);
      }
      DalocMsgBuf(gBvciList);
   }   
   else
   {
      LOG_PRINT(INFO,"(BPM)cardStateChangeHandler: Unexpected state received  = %d",param->cardState) ;
      LOG_PRINT(INFO,"(BPM)Nothing to do...only releasing the semaphore") ;
      SEM_POST(&gSemHandler);
   }
}

void PschBpmCallbackFunc (struct sAisParam *param)
{
   switch (param->messageId)
   {
      case BPM_HEALTHCHECK_MESSAGE:
           bpmRespondToAis (param->invocation, OK);
           break;

      case BPM_SELFCARD_STATE_CHANGE:
           LOG_PRINT(DEBUG,"(BPM)BPM_SELFCARD_STATE_CHANGE received ");
           if( SEM_WAIT(&gSemHandler) !=0)
              LOG_PRINT(DEBUG,"(BPM)SEM_WAIT failed ");
           cardStateChangeHandler(param);
           LOG_PRINT(DEBUG,"(BPM)Waiting for Semaphore...");
           if( SEM_TIMED_WAIT(&gSemHandler) != SEMAPHORE_WAIT_COMPLETE)
           {
              LOG_PRINT(INFO,"(BPM)Got Sempahore.. ");
              LOG_PRINT(INFO,"(BPM)calling bpmRespondToAis.. ");
              bpmRespondToAis (param->invocation, OK);
              LOG_PRINT(INFO,"(BPM)Response sent to BPM.. ");
              LOG_PRINT(INFO,"(BPM)Releasing Sempahore.. ");
              SEM_POST(&gSemHandler);
           }
           else
           {
              LOG_PRINT(INFO,"(BPM)SEMAPHORE Wait Timed Out... ");
              LOG_PRINT(INFO,"(BPM)Releasing semaphore.. ");
              SEM_POST(&gSemHandler);
           }
           break;

      case BPM_PEERCARD_STATE_CHANGE:
           LOG_PRINT(INFO, "(BPM)BPM_PEERCARD_STATE_CHANGE recd, No Action Taken");
           bpmRespondToAis (param->invocation, OK);
           break;

      case BPM_MSG_ACK_PEER_HEALTH_BAD:
           LOG_PRINT(INFO, "(BPM)BPM_MSG_ACK_PEER_HEALTH_BAD recd, Not Expected");
           break;

      case BPM_MSG_ACK_CONFIGURE:
           LOG_PRINT(INFO, "(BPM)BPM_MSG_ACK_CONFIGURE recd");
           break;
      case BPM_MSG_ACK_CONFIGURE_RESET:
           LOG_PRINT(INFO, "(BPM)BPM_MSG_ACK_CONFIGURE_RESET recd, No Action Taken");
           break;

      case BPM_SHUTDOWN:
           LOG_PRINT(INFO, "(BPM)BPM_SHUTDOWN recd, Exiting");
           exit (BPM_FAILURE_EXIT_CODE);
           break;

      default:
           LOG_PRINT(MAJOR, "(BPM)Unexpected msg from BPM: %d", param->messageId);
           break;
   }
}



GetRefId(I_Void *rcvPtr ,I_U32 * refId1,I_U32 * refId2)
{
   /* Logic for getting the bvci or cellIndex from the Incoming Message*/

   SysHdr      *sysHdr ;
   I_U16       msgType ;
   sysHdr = (SysHdr *)rcvPtr ;
   msgType = sysHdr->msgType ;
  
   *refId1 = REF_ID_ZERO;
   *refId2 = REF_ID_ZERO;

   switch(msgType)
   {
      case OAMS_CFG_PSCH_UNLOCK_REQ:
           *refId1 = ((OamsCfgPschUnlockReq *)rcvPtr)->bvci ;
           *refId2 = ((OamsCfgPschUnlockReq *)rcvPtr)->cellIndex ;
           break ;

      case CSAPP_GRHM_PSCH_ACT_PDCH_IND:
           *refId1 = 0 ;
           *refId2 = ((CsappGrhmPschActPdchInd *)rcvPtr)->cellIndex ;
           break ;

      case PSSKS_BSSGP_PSCH_PTP_BVC_RESET_ACK:
           *refId1 = ((GsalMessage *)rcvPtr)->bssgpMessage.bvcResetAck.bvci ;
           *refId2 = INVALID_REFERENCE_ID ;
           break ;

      case PSSKS_BSSGP_PSCH_PTP_BVC_BLOCK_ACK:
           *refId1 = ((GsalMessage *)rcvPtr)->bssgpMessage.bvcBlockAck.bvci ;
           *refId2 = INVALID_REFERENCE_ID ;
           break ;

      case PSSKS_BSSGP_PSCH_PTP_BVC_UNBLOCK_ACK:
           *refId1 = ((GsalMessage *)rcvPtr)->bssgpMessage.bvcUnblockAck.bvci ;
           *refId2 = INVALID_REFERENCE_ID ;
           break ;

      case PSSKS_BSSGP_PSCH_PTP_BVC_FLOW_CTRL_ACK:
           *refId1 = ((GsalMessage *)rcvPtr)->bssgpMessage.nsBvci ;
           *refId2 = INVALID_REFERENCE_ID ;
           break ;

      case PSSKS_BSSGP_PSCH_PTP_BVC_RESET:
           *refId1 = ((GsalMessage *)rcvPtr)->bssgpMessage.bvcReset.bvci ;
           *refId2 = INVALID_REFERENCE_ID ;
           break ;

      case OAMS_TRXH_PSCH_PS_ALLOWED:
           *refId1 = 0 ;
           *refId2 = ((OamsTrxhPschPsAllowed *)rcvPtr)->cellIndex ;
           break ;

      case OAMS_TRXH_PSCH_PS_NOT_ALLOWED:
           *refId1 = 0 ;
           *refId2 = ((OamsTrxhPschPsNotAllowed *)rcvPtr)->cellIndex ;
           break ;

      case OAMS_PSSCM_PSCH_PROV_PTP_BVC_CNF:
           *refId1 = ((OamsPsscmPschProvPtpBvcCnf *)rcvPtr)->bvci ;
           *refId2 = INVALID_REFERENCE_ID ;
           break ;

      case OAMS_PSSCM_PSCH_UNPROV_PTP_BVC_CNF:
           *refId1 = ((OamsPsscmPschUnprovPtpBvcCnf *)rcvPtr)->bvci ;
           *refId2 = INVALID_REFERENCE_ID ;
           break ;

      case OAMS_CFG_PSCH_LOCK_REQ:
           *refId1 = 0 ;
           *refId2 = ((OamsCfgPschLockReq *)rcvPtr)->cellIndex ;
           break ;

      case OAMS_CFG_PSCH_SHUTDOWN_IND:
           *refId1 = 0 ;
           *refId2 = ((OamsCfgPschShutdownInd *)rcvPtr)->cellIndex ;
           break ;

      case OAMS_CFG_PSCH_CELL_BAR_ACCESS:
           *refId1 = 0 ;
           *refId2 = ((OamsCfgPschCellBarAccess *)rcvPtr)->cellIndex ;
           break ;

      case OAMS_CFG_PSCH_BVC_OP_FAILED:
           *refId1 = ((OamsCfgPschBvcOpFailed *)rcvPtr)->bvci ;
           *refId2 = ((OamsCfgPschBvcOpFailed *)rcvPtr)->cellIndex ;
           break ;
           
      default:
           *refId1 = 0;
           *refId2 = INVALID_REFERENCE_ID ;
     }
     /*Following is a hack in the code as libInst doesn't allow 0 as the key and cellIndex can start from 0.
So we are storing cellIndex in the db as cellIndex+1. This code shall be removed, once this issue is fixed in the 
libInst library*/
      if( *refId2 == INVALID_REFERENCE_ID)
         *refId2 = REF_ID_ZERO;
      else
         *refId2+=1;
return ;
}

#ifndef XNOINITENV
/*---+---------------------------------------------------------------
     xInitEnv extern
-------------------------------------------------------------------*/
#ifndef XENV_INIT
#define XENV_INIT
#endif

extern void xInitEnv(void)
{
  /* Code to initialize your SDL-system environment may be inserted here */
  I_S32         result;
#ifdef XTRACE
  xPrintString("(ENV:xInitEnv)xInitEnv called\n");
#endif

  /*#ifdef PLATFORM_IMR*/
//#ifdef XTRACE
//  xPrintString("(ENV:xInitEnv)Registering with BPM....\n");
//#endif
  //RegisterPschWithBpm();CLOUD
  /*#endif*/
#ifdef XTRACE
  xPrintString("(ENV:xInitEnv)Registering with IPC FramWork...\n");
#endif
  if (RegisterWithIpcFrmwrk(selfEntIdG, (I_S8 *)"ENT_OAMS_PSCH") < 0)
  {
#ifdef XTRACE
    xPrintString("(ENV:xInitEnv)Unable to Register itself with IPC FrameWork : Exiting");
#endif
    exit(FRMWRK_FAILURE_EXIT_CODE) ;
  }
#ifdef XTRACE
  xPrintString("(ENV:xInitEnv)Registering with BPM....\n");
#endif
  RegisterPschWithBpm();

  /*LOG_PRINT(INFO, "(ENV:xInitEnv)SystemName=%s, ModuleName=%s, Version=%s **",SYSTEM_NAME, selfEntIdG, VERSION);*/
  LOG_PRINT(INFO,"(ENV:xInitEnv)CurrentCardState at initialization: [%d]", gCurrentCardState) ;
  LOG_PRINT(INFO,"(ENV:xInitEnv)NewCardState at initialization: [%d]", gNewCardState) ;
  SEM_INIT(&gSemHandler);
  LOG_PRINT(INFO, "(ENV:xInitEnv)Semaphore Initialized Successfully with pointer :: [%d]",&gSemHandler);


#ifndef PLATFORM_IMR
  LOG_PRINT(INFO,"(ENV:xInitEnv)Registering with DB Server...\n");
  result = dbConnect();
  if (result != DBLIB_SUCCESS)
  {
    LOG_PRINT(CRITICAL,"(ENV:xInitEnv)Unable to Register itself with DBServer:Exiting");
    exit(DB_FAILURE_EXIT_CODE) ;
  }
  LOG_PRINT(INFO,"(ENV:xInitEnv)Successfully Registered with DB Server.\n");
  REGISTER_SIGNAL_HANDLER(); 
   LOG_PRINT(INFO,"xInitEnv: registered signal handler");
#endif

#ifdef XTRACE
  xPrintString("(ENV:xInitEnv)xInitEnv called\n");
#endif
}
#endif

#ifndef XNOCLOSEnv
/*---+---------------------------------------------------------------
     xCloseEnv  extern
-------------------------------------------------------------------*/
#ifndef XENV_CLOSE
#define XENV_CLOSE
#endif

extern void xCloseEnv(void)
{
   /* Code to bring down the environment in a controlled manner
     may be inserted here. */
   I_S32 retVal;

   /* DeRegister with DB */
   if ((retVal = dbDestroy()) != DBLIB_SUCCESS)
   {
      LOG_PRINT(MAJOR,"(ENV:xCloseEnv)dbDestroy failed for PSCH (Error = %d)",retVal);
      exit(DB_FAILURE_EXIT_CODE);
   }/*if retVal */


#ifdef XTRACE
   xPrintString("(ENV:xCloseEnv)xCloseEnv called\n");
#endif
}
#endif


/*---+---------------------------------------------------------------
     Macros for xOutEnv
-------------------------------------------------------------------*/
#ifndef OUT_LOCAL_VARIABLES
#define OUT_LOCAL_VARIABLES
#endif

#ifndef IF_OUT_SIGNAL
#define IF_OUT_SIGNAL(SIGNAL_NAME, SIGNAL_NAME_STRING) \
  if (((*SignalOut)->NameNode) == SIGNAL_NAME) {
#define END_IF_OUT_SIGNAL(SIGNAL_NAME, SIGNAL_NAME_STRING) \
  }
#endif

#ifndef OUT_SIGNAL1
#define OUT_SIGNAL1(SIGNAL_NAME, SIGNAL_NAME_STRING)
#endif

#ifndef OUT_SIGNAL2
#define OUT_SIGNAL2(SIGNAL_NAME, SIGNAL_NAME_STRING)
#endif

#ifndef XENV_ENC
#define XENV_ENC(stmt) stmt
#endif

#ifndef XENV_OUT_START
#define XENV_OUT_START
#endif

#ifndef RELEASE_SIGNAL
#define RELEASE_SIGNAL   xReleaseSignal(SignalOut); return;
#endif


/*---+---------------------------------------------------------------
     xOutEnv  extern
-------------------------------------------------------------------*/
extern void xOutEnv( xSignalNode *SignalOut
#ifdef XPATH_INFO_IN_ENV_FUNC
  , xChannelIdNode Port
#endif
 )
{
   I_Void             *sndPtr     = NULL;
   I_S32              msgSize     = 0;
   I_U32              lclPidPtr   = INVALID_LCL_PID_PTR;
   I_S32              retVal      = 0;
   I_U8               actClsId    = INVALID_LCL_PID_PTR;
   static I_U8        recvdMsgs = 0;
   I_U16              lac = 0;
   I_U16              cellId = 0;
   I_S32              index;
   I_S32              dbCallResult;
   I_U32              bvci;
   PsCellTableIndices psCellTableInputParams;
   PsCellTableApi     *psCellTableReference = NULL;    

   /* NSE feature */
#ifdef XTRACE
#ifdef XIDNAMES
   char  Temp[100];
   sprintf(Temp, " xOutEnv:  %s has been received by env\n",
	   (*SignalOut)->NameNode->Name );
   xPrintString(Temp);
#else
   xPrintString("(xOutEnv:  One signal has been received by env\n");
#endif
#endif

   if ( (gCurrentCardState != CARDSTATE_ACTIVE) && ((*SignalOut)->NameNode->SignalNumber != SN_PSCH_INT_SELFCARD_STATE_CHANGE_RESP) && ((*SignalOut)->NameNode->SignalNumber != SN_OAMS_PSCH_ADD_TAU_INST_IN_INSTMAP))
   {
	 LOG_PRINT(INFO,"(ENV:xOutEnv)Current Card status is not Active. Discarding the Message\n");
	 xReleaseSignal(SignalOut);
	 return;
   }

   switch((*SignalOut)->NameNode->SignalNumber)
   {
	 case SN_OAMS_PSCH_PSSCM_PROV_PTP_BVC:
	   {
		 sndPtr = ((yPDP_sig_OAMS_PSCH_PSSCM_PROV_PTP_BVC)(*SignalOut))->Param1;
		 msgSize = ((yPDP_sig_OAMS_PSCH_PSSCM_PROV_PTP_BVC)(*SignalOut))->Param2;
		 if (NULL == sndPtr)
		 {
		   LOG_PRINT(INFO,"(ENV:xOutEnv)Received NULL pointer from Module, Returning without Sending to FRAMEWORK");
		   xReleaseSignal(SignalOut);
		   return ;
		 }
		 LOG_PRINT(INFO,"ENV:(xOutEnv)OAMS_PSCH_PSSCM_PROV_PTP_BVC sent");
		 break;
	   }

	 case SN_OAMS_PSCH_PSSCM_UNPROV_PTP_BVC:
	   {
		 sndPtr = ((yPDP_sig_OAMS_PSCH_PSSCM_UNPROV_PTP_BVC)(*SignalOut))->Param1;
		 msgSize = ((yPDP_sig_OAMS_PSCH_PSSCM_UNPROV_PTP_BVC)(*SignalOut))->Param2;
		 if (NULL == sndPtr)
		 {
		   LOG_PRINT(INFO,"(ENV:xOutEnv)Received NULL pointer from Module, Returning without Sending to FRAMEWORK");
		   xReleaseSignal(SignalOut);
		   return ;
		 }
		 LOG_PRINT(INFO,"ENV:(xOutEnv)OAMS_PSCH_PSSCM_UNPROV_PTP_BVC sent");
		 break;

	   }

	 case SN_OAMS_PSCH_CELLH_PS_CELL_ENABLED:
	   {
		 sndPtr = ((yPDP_sig_OAMS_PSCH_CELLH_PS_CELL_ENABLED)(*SignalOut))->Param1;
		 msgSize = ((yPDP_sig_OAMS_PSCH_CELLH_PS_CELL_ENABLED)(*SignalOut))->Param2;
		 if (NULL == sndPtr)
		 {
		   LOG_PRINT(INFO,"(ENV:xOutEnv)Received NULL pointer from Module, Returning without Sending to FRAMEWORK");
		   xReleaseSignal(SignalOut);
		   return ;
		 }
		 LOG_PRINT(INFO,"ENV:(xOutEnv)OAMS_PSCH_CELLH_PS_CELL_ENABLED sent");
		 break;
	   }
	 case SN_OAMS_PSCH_CELLH_PS_CELL_DISABLED:
	   {
		 sndPtr = ((yPDP_sig_OAMS_PSCH_CELLH_PS_CELL_DISABLED)(*SignalOut))->Param1;
		 msgSize = ((yPDP_sig_OAMS_PSCH_CELLH_PS_CELL_DISABLED)(*SignalOut))->Param2;
		 if (NULL == sndPtr)
		 {
		   LOG_PRINT(INFO,"(ENV:xOutEnv)Received NULL pointer from Module, Returning without Sending to FRAMEWORK");
		   xReleaseSignal(SignalOut);
		   return ;
		 }
		 LOG_PRINT(INFO,"ENV:(xOutEnv)OAMS_PSCH_CELLH_PS_CELL_DISABLED sent");
		 break;
	   }

	 case SN_OAMS_PSCH_CFG_LOCK_RESP:
	   {

		 sndPtr = ((yPDP_sig_OAMS_PSCH_CFG_LOCK_RESP)(*SignalOut))->Param1;
		 msgSize = ((yPDP_sig_OAMS_PSCH_CFG_LOCK_RESP)(*SignalOut))->Param2;
		 gNseProc = ((yPDP_sig_OAMS_PSCH_CFG_LOCK_RESP)(*SignalOut))->Param3;

		 if (NULL == sndPtr)
		 {
		   LOG_PRINT(INFO,"(ENV:xOutEnv)Received NULL pointer from Module, Returning without Sending to FRAMEWORK");
		   xReleaseSignal(SignalOut);
		   gNumPsCellNseLockUnlock--;
		   return ;
		 }
		 if (gNseProc != I_TRUE)
		 {
		   actClsId = 1 ;
		   lclPidPtr = (I_U32)((*SignalOut)->Sender.LocalPId);
		   lac = ((OamsPschCfgLockResp *)sndPtr)->lac;
		   cellId = ((OamsPschCfgLockResp *)sndPtr)->cellId;
		   psCellTableInputParams.lac = lac;
		   psCellTableInputParams.cellId = cellId;
		   dbCallResult = getPsCellTable(&((psCellTableInputParams)),&((psCellTableReference)));
		   if (dbCallResult != DBLIB_SUCCESS)
		   {
			 LOG_PRINT(MAJOR,"xOutEnv: Failed db call getPsCellTable error code [%d]",dbCallResult);
		   }
		   else
		   {
			 bvci = (I_U32)(psCellTableReference->bvciId);
			 for (index = 0; index < gPschInstCount; index ++)
			 {
			   if (bvci == gBvciList[index])
			   {
				 gBvciList[index] = INVALID_BVCI;
				 LOG_PRINT(DEBUG,"(xOutEnv): Deleted bvci from bvci table [%u]",bvci);
				 break;
			   }
			 }
		   }
		   if ((retVal = FreInstId(lclPidPtr, ENT_OAMS_PSCH,actClsId)) < 0)
		   {
			 LOG_PRINT(CRITICAL, "(ENV:xOutEnv)FreeInstId() Failed lclPidPtr = %d [Act Cls Id = %d]",lclPidPtr, actClsId);
		   }
		   else
		   {
			 LOG_PRINT(INFO, "(ENV:xOutEnv)FreeInstId() Success lclPidPtr = %d [Act Cls Id = %d]",lclPidPtr, actClsId);
		   }
		   if (psCellTableReference != NULL)
		   {
			 free (psCellTableReference);
		   }
		   LOG_PRINT(INFO,"ENV:(xOutEnv)OAMS_PSCH_CFG_LOCK_RESP sent");
		 }
		 else// NSE_LOCK msg case
		 {
		   if(gNumPsCellNseLockUnlock > 0)
		   {
			 LOG_PRINT(DEBUG,"(xInEnv: NSE_LOCK_RESP received in env: gNumPsCellNseLockUnlock:[%d]",gNumPsCellNseLockUnlock);
			 if (sndPtr != NULL)
			 {
			   DalocMsgBuf(sndPtr);
			 }
			 gNumPsCellNseLockUnlock--;
			 if(0 == gNumPsCellNseLockUnlock)
			 {
			    sendCfgNseLockUnlockResp(gNsei,I_TRUE);
			 }
			 return;

		   }
		   else
		   {

			 LOG_PRINT(DEBUG,"(xOutEnv): Unexpected NSE_LOCK_RESP received:");
			 DalocMsgBuf(sndPtr);
			 xReleaseSignal(SignalOut);
			 return;
		   } 
		 }//gNseLockInProgress
		 break;
	   }
	 case SN_OAMS_PSCH_CFG_UNLOCK_RESP:
	   {
		 sndPtr = ((yPDP_sig_OAMS_PSCH_CFG_UNLOCK_RESP)(*SignalOut))->Param1;
		 msgSize = ((yPDP_sig_OAMS_PSCH_CFG_UNLOCK_RESP)(*SignalOut))->Param2;
		 gNseProc = ((yPDP_sig_OAMS_PSCH_CFG_UNLOCK_RESP)(*SignalOut))->Param3;
		 /*nse feature*/
		 gNseStatus = ((yPDP_sig_OAMS_PSCH_CFG_UNLOCK_RESP)(*SignalOut))->Param4;
		 if (NULL == sndPtr)
		 {
		   LOG_PRINT(INFO,"(ENV:xOutEnv)Received NULL pointer from Module, Returning without Sending to FRAMEWORK");
		   xReleaseSignal(SignalOut);
		   gNumPsCellNseLockUnlock--;
		   return ;
		 }

		 if (gNseProc != I_TRUE)
		 {
		   LOG_PRINT(INFO,"ENV:(xOutEnv)OAMS_PSCH_CFG_UNLOCK_RESP sent");
		   /*nse feature: check nse status with provision fails to delete the bvci list saved*/
		   if (((OamsPschCfgUnlockResp *)sndPtr)->result != BSS_SUCCESS && gNseStatus == UNLOCKED)
		   {
			 bvci =(I_U32) (((OamsPschCfgUnlockResp *)sndPtr)->bvci);
			 for (index = 0; index < gPschInstCount; index ++)
			 {
			   if (bvci == gBvciList[index])
			   {
				 gBvciList[index] = INVALID_BVCI;
				 LOG_PRINT(DEBUG,"(xOutEnv): Deleted bvci from bvci table [%u]",bvci);
				 break;
			   }
			 }
		   }
		 }
		 else //NSE_UNLOCK case
		 {
		   if(gNumPsCellNseLockUnlock > 0)
		   {
			 LOG_PRINT(DEBUG,"(xInEnv: NSE_UNLOCK_RESP received in env gNumPsCellNseLockUnlock [%d]",gNumPsCellNseLockUnlock);
			 if (sndPtr != NULL)
			 {
			   DalocMsgBuf(sndPtr);
			 }

			 gNumPsCellNseLockUnlock--;
			 if(0 == gNumPsCellNseLockUnlock)
			 {
			   sendCfgNseLockUnlockResp(gNsei,I_FALSE);
			 }
			 return;
		   }
		   else
		   {
			 LOG_PRINT(DEBUG,"(xOutEnv): Unexpected NSE_UNLOCK_RESP received:");
			 xReleaseSignal(SignalOut);
			 DalocMsgBuf(sndPtr);
			 return;
		   }
		 }
		 break;
	   }
	 case SN_OAMS_PSCH_CFG_ALARM_IND:
	   {
		 sndPtr = ((yPDP_sig_OAMS_PSCH_CFG_ALARM_IND)(*SignalOut))->Param1;
		 msgSize = ((yPDP_sig_OAMS_PSCH_CFG_ALARM_IND)(*SignalOut))->Param2;
		 if (NULL == sndPtr)
		 {
		   LOG_PRINT(INFO,"(ENV:xOutEnv)Received NULL pointer from Module, Returning without Sending to FRAMEWORK");
		   xReleaseSignal(SignalOut);
		   return ;
		 }
		 LOG_PRINT(INFO,"ENV:(xOutEnv)OAMS_PSCH_CFG_ALARM_IND sent");
		 break;
	   }
	 case SN_OAMS_PSCH_GRHM_CRS_IND:
	   {
		 sndPtr = ((yPDP_sig_OAMS_PSCH_GRHM_CRS_IND)(*SignalOut))->Param1;
		 msgSize = ((yPDP_sig_OAMS_PSCH_GRHM_CRS_IND)(*SignalOut))->Param2;
		 if (NULL == sndPtr)
		 {
		   LOG_PRINT(INFO,"(ENV:xOutEnv)Received NULL pointer from Module, Returning without Sending to FRAMEWORK");
		   xReleaseSignal(SignalOut);
		   return ;
		 }
		 LOG_PRINT(INFO,"ENV:(xOutEnv)OAMS_PSCH_GRHM_CRS_IND sent");
		 break;
	   }
	 case SN_OAMS_PSCH_BSSGP_PTP_BVC_RESET:
	   {
		 sndPtr = ((yPDP_sig_OAMS_PSCH_BSSGP_PTP_BVC_RESET)(*SignalOut))->Param1;
		 msgSize = ((yPDP_sig_OAMS_PSCH_BSSGP_PTP_BVC_RESET)(*SignalOut))->Param2;
		 if (NULL == sndPtr)
		 {
		   LOG_PRINT(INFO,"(ENV:xOutEnv)Received NULL pointer from Module, Returning without Sending to FRAMEWORK");
		   xReleaseSignal(SignalOut);
		   return ;
		 }
		 LOG_PRINT(INFO,"ENV:(xOutEnv)OAMS_PSCH_BSSGP_PTP_BVC_RESET sent");
		 break;
	   }
	 case SN_OAMS_PSCH_BSSGP_PTP_BVC_BLOCK:
	   {
		 sndPtr = ((yPDP_sig_OAMS_PSCH_BSSGP_PTP_BVC_BLOCK)(*SignalOut))->Param1;
		 msgSize = ((yPDP_sig_OAMS_PSCH_BSSGP_PTP_BVC_BLOCK)(*SignalOut))->Param2;
		 if (NULL == sndPtr)
		 {
		   LOG_PRINT(INFO,"(ENV:xOutEnv)Received NULL pointer from Module, Returning without Sending to FRAMEWORK");
		   xReleaseSignal(SignalOut);
		   return ;
		 }
		 LOG_PRINT(INFO,"ENV:(xOutEnv)OAMS_PSCH_BSSGP_PTP_BVC_BLOCK sent");
		 break;
	   }
	 case SN_OAMS_PSCH_BSSGP_PTP_BVC_UNBLOCK:
	   {
		 sndPtr = ((yPDP_sig_OAMS_PSCH_BSSGP_PTP_BVC_UNBLOCK)(*SignalOut))->Param1;
		 msgSize = ((yPDP_sig_OAMS_PSCH_BSSGP_PTP_BVC_UNBLOCK)(*SignalOut))->Param2;
		 if (NULL == sndPtr)
		 {
		   LOG_PRINT(INFO,"(ENV:xOutEnv)Received NULL pointer from Module, Returning without Sending to FRAMEWORK");
		   xReleaseSignal(SignalOut);
		   return ;
		 }
		 LOG_PRINT(INFO,"ENV:(xOutEnv)OAMS_PSCH_BSSGP_PTP_BVC_UNBLOCK sent");
		 break;
	   }
	 case SN_OAMS_PSCH_BSSGP_PTP_BVC_FLOW_CTRL_REQ:
	   {
		 sndPtr = ((yPDP_sig_OAMS_PSCH_BSSGP_PTP_BVC_FLOW_CTRL_REQ)(*SignalOut))->Param1;
		 msgSize = ((yPDP_sig_OAMS_PSCH_BSSGP_PTP_BVC_FLOW_CTRL_REQ)(*SignalOut))->Param2;
		 if (NULL == sndPtr)
		 {
		   LOG_PRINT(INFO,"(ENV:xOutEnv)Received NULL pointer from Module, Returning without Sending to FRAMEWORK");
		   xReleaseSignal(SignalOut);
		   return ;
		 }
		 LOG_PRINT(INFO,"ENV:(xOutEnv)OAMS_PSCH_BSSGP_PTP_BVC_FLOW_CTRL_REQ sent");
		 break;
	   }
	 case SN_OAMS_PSCH_BSSGP_PTP_BVC_RESET_ACK:
	   {
		 sndPtr = ((yPDP_sig_OAMS_PSCH_BSSGP_PTP_BVC_RESET_ACK)(*SignalOut))->Param1;
		 msgSize = ((yPDP_sig_OAMS_PSCH_BSSGP_PTP_BVC_RESET_ACK)(*SignalOut))->Param2;
		 if (NULL == sndPtr)
		 {
		   LOG_PRINT(INFO,"(ENV:xOutEnv)Received NULL pointer from Module, Returning without Sending to FRAMEWORK");
		   xReleaseSignal(SignalOut);
		   return ;
		 }
		 LOG_PRINT(INFO,"ENV:(xOutEnv)OAMS_PSCH_BSSGP_PTP_BVC_RESET_ACK sent");
		 break;
	   }
	 case SN_OAMS_PSCH_PSMSH_CRE_CELL_BVC_MAP:
	   {
		 sndPtr = ((yPDP_sig_OAMS_PSCH_PSMSH_CRE_CELL_BVC_MAP)(*SignalOut))->Param1;
		 msgSize = ((yPDP_sig_OAMS_PSCH_PSMSH_CRE_CELL_BVC_MAP)(*SignalOut))->Param2;
		 if (NULL == sndPtr)
		 {
		   LOG_PRINT(INFO,"(ENV:xOutEnv)Received NULL pointer from Module, Returning without Sending to FRAMEWORK");
		   xReleaseSignal(SignalOut);
		   return ;
		 }
		 LOG_PRINT(INFO,"ENV:(xOutEnv)OAMS_PSCH_PSMSH_CRE_CELL_BVC_MAP sent");
		 break;
	   }
	 case SN_OAMS_PSCH_PSMSH_DEL_CELL_BVC_MAP:
	   {
		 sndPtr = ((yPDP_sig_OAMS_PSCH_PSMSH_DEL_CELL_BVC_MAP)(*SignalOut))->Param1;
		 msgSize = ((yPDP_sig_OAMS_PSCH_PSMSH_DEL_CELL_BVC_MAP)(*SignalOut))->Param2;
		 if (NULL == sndPtr)
		 {
		   LOG_PRINT(INFO,"(ENV:xOutEnv)Received NULL pointer from Module, Returning without Sending to FRAMEWORK");
		   xReleaseSignal(SignalOut);
		   return ;
		 }
		 LOG_PRINT(INFO,"ENV:(xOutEnv)OAMS_PSCH_PSMSH_DEL_CELL_BVC_MAP sent");
		 break;
	   }
	 case SN_OAMS_PSCH_TRXH_PS_ATTR_CHANGE_IND:
	   {
		 sndPtr = ((yPDP_sig_OAMS_PSCH_TRXH_PS_ATTR_CHANGE_IND)(*SignalOut))->Param1;
		 msgSize = ((yPDP_sig_OAMS_PSCH_TRXH_PS_ATTR_CHANGE_IND)(*SignalOut))->Param2;
		 if (NULL == sndPtr)
		 {
		   LOG_PRINT(INFO,"(Env):Received NULL pointer from Module, Returning without Sending to FRAMEWORK");
		   xReleaseSignal(SignalOut);
		   return ;
		 }
		 LOG_PRINT(INFO,"xOutEnv:OAMS_PSCH_TRXH_PS_ATTR_CHANGE_IND sent");
		 break;
	   }


	 case SN_OAMS_PSCH_ADD_TAU_INST_IN_INSTMAP :
	   LOG_PRINT(INFO,"(ENV:xOutEnv)Received  Signal OAMS_PSCH_ADD_TAU_INST_IN_INSTMAP");
	   actClsId = PSCH_CLASS_ID ;
	   lclPidPtr = (I_U32)((*SignalOut)->Sender.LocalPId);
	   if ((retVal = AddTauInst(lclPidPtr,ENT_OAMS_PSCH, actClsId)) < 0)
	   {
		 LOG_PRINT(CRITICAL, "(ENV:xOutEnv)AddTauInstId() Failed lclPidPtr = %d [Act Cls Id = %d]",lclPidPtr, actClsId);
	   }
	   else
	   {
		 LOG_PRINT(INFO, "(ENV:xOutEnv)AddTauInstId() Success lclPidPtr = %d [Act Cls Id = %d]",lclPidPtr, actClsId);
	   }
	   recvdMsgs++;
	   LOG_PRINT(INFO,"(ENV:xOutEnv)Here recvDMsgs are :: %d and gInstCount is :: %d ", recvdMsgs, gInstCount);
	   if( recvdMsgs == gInstCount && gInstancesCreated == I_FALSE)
	   {
		 updateCardStatus();
		 gInstancesCreated = I_TRUE;
		 LOG_PRINT(INFO,"(ENV:xOutEnv)Releasing semaphore.. ");
		 SEM_POST(&gSemHandler);
		 LOG_PRINT(INFO,"(ENV:xOutEnv)Moving to INSERVICE.. ");
		 recvdMsgs = 0;
		 gInstCount = 0;
	   }
	   xReleaseSignal(SignalOut);
	   return;

	 case SN_PSCH_FREE_INST :
	   LOG_PRINT(INFO,"(ENV:xOutEnv)Received  Signal PSCH_FREE_INST");
	   actClsId = PSCH_CLASS_ID ;
	   lclPidPtr = (I_U32)((*SignalOut)->Sender.LocalPId);
	   if ((retVal = FreInstId(lclPidPtr,ENT_OAMS_PSCH, actClsId)) < 0)
	   {
		 LOG_PRINT(CRITICAL, "(ENV:xOutEnv)AddTauInstId() Failed lclPidPtr = %d [Act Cls Id = %d]",lclPidPtr, actClsId);
	   }
	   else
	   {
		 LOG_PRINT(INFO, "(ENV:xOutEnv)AddTauInstId() Success lclPidPtr = %d [Act Cls Id = %d]",lclPidPtr, actClsId);
	   }
	   xReleaseSignal(SignalOut);
	   return;
	 case SN_PSCH_INT_SELFCARD_STATE_CHANGE_RESP :
	   LOG_PRINT(DEBUG, "(ENV:xOutEnv)Received signal SN_PSCH_INT_SELFCARD_STATE_CHANGE_RESP");
	   recvdMsgs++ ;
	   if ( recvdMsgs == gSignalSent )
	   {
		 LOG_PRINT(INFO,"(ENV:xOutEnv)All instances goes to INIT State while going ACTIVE to INSERVICE/RECOVERY state. ");
		 updateCardStatus();
		 LOG_PRINT(INFO,"(ENV:xOutEnv)Releasing semaphore.. ");
		 SEM_POST(&gSemHandler);
		 recvdMsgs = 0;
		 gSignalSent = 0;
	   }
	   xReleaseSignal(SignalOut);
	   return;

	   /* Added for testing*/
	 case SN_PSCH_REG_SYS_CLASS :
	   LOG_PRINT(INFO, "(ENV:xOutEnv)Received signal SN_PSCH_REG_SYS_CLASS");
	   systemLclPidPtr    = (I_U32)((*SignalOut)->Sender.LocalPId);
	   LOG_PRINT(DEBUG,"(ENV:xOutEnv)Sys Class PId %d", systemLclPidPtr);
	   xReleaseSignal(SignalOut);
	   return;
	   /* Changes End*/
	 default:
	   LOG_PRINT(MAJOR,"(ENV:xOutEnv)Invalid Signal Rcvd From Model(Signal number=%d)",(*SignalOut)->NameNode->SignalNumber);
	   sndPtr = ((yPDP_sig_OAMS_PSCH_BSSGP_PTP_BVC_RESET_ACK)(*SignalOut))->Param1;
	   if (sndPtr !=NULL)
	   {
		 DalocMsgBuf(sndPtr);
	   }
	   xReleaseSignal(SignalOut);
	   return;
   } 

   LOG_PRINT(INFO,"(ENV:xOutEnv)Out Of Switch XOutEnv \n ");
   if (SendMsg(sndPtr,MSG_ORD_PRIO,msgSize) == SND_FAIL)
   {
	 LOG_PRINT(CRITICAL,"(ENV:xOutEnv)Message Senging Failed \n");
   }
   else
   {
	 LOG_PRINT(INFO,"(ENV:xOutEnv)Successfully sent message out \n");
   }
   xReleaseSignal(SignalOut);
   return;
}


/*---+---------------------------------------------------------------
  Macros for xInEnv
  -------------------------------------------------------------------*/
#ifndef IN_LOCAL_VARIABLES
#define IN_LOCAL_VARIABLES \
  xSignalNode SignalIn;
#endif

#ifndef IN_SIGNAL1
#define IN_SIGNAL1(SIGNAL_NAME, SIGNAL_NAME_STRING) \
  SignalIn = xGetSignal(SIGNAL_NAME, xNotDefPId, xEnv);
#endif

#ifndef IN_SIGNAL2
#define IN_SIGNAL2(SIGNAL_NAME, SIGNAL_NAME_STRING) \
  SDL_Output(SignalIn xSigPrioPar(xDefaultPrioSignal), (xIdNode *)0);
#endif

#ifndef IF_IN_SIGNAL
#define IF_IN_SIGNAL(SIGNAL_NAME, SIGNAL_NAME_STRING) \
  if (TEST_IF_IN_SIGNAL(SIGNAL_NAME)) {
#define END_IF_IN_SIGNAL(SIGNAL_NAME, SIGNAL_NAME_STRING) \
  }
#endif

#ifndef TEST_IF_IN_SIGNAL
#define TEST_IF_IN_SIGNAL(SIGNAL_NAME)  0
#endif

#ifndef XENV_DEC
#define XENV_DEC(stmt) stmt
#endif

#ifndef XENV_IN_START
#define XENV_IN_START
#endif

#ifndef XENV_IN_END
#define XENV_IN_END
#endif


/*---+---------------------------------------------------------------
  xInEnv  extern
  -------------------------------------------------------------------*/
#ifndef XTENV
extern void xInEnv ( SDL_Time Time_for_next_event )
#else
extern SDL_Duration xInEnv ( SDL_Time Time_for_next_event )
#endif
{
  xSignalNode        S;
  I_PVoid            rcvPtr = NULL;
  I_U32              msgSize;
  SDL_Pid            rcvr;
  I_U16              msgType;
  I_U32              refId1;
  I_U32              refId2;
  I_S32              instId;
  I_S8               instCountResult = ZERO;
  I_U16              instCount = ZERO;
  I_U32              lclPidPtr;
  I_S32              index;
  struct sAisParam   *param;
  PsCellTableIndices  psCellTableIndex;
  PsCellTableApi  *psCellTableApi;

  /*nse feature*/
  I_U32 outCount = 0;
  I_U16 outSize ;
  I_Void             *sndPtr     = NULL; 
  I_S32               ret;
  PsCellTableApi *tempOutData = NULL;

  CellNonPerTableIndices cellNonPerTableIndices;
  CellNonPerTableApi *cellNonPerTableApi = NULL;

  if ((rcvPtr = (I_Void *)RecvMsg(selfEntIdG, &msgSize)) != NULL)
  {
	msgType = ((SysHdr *)rcvPtr)->msgType;
	if ( gCurrentCardState == CARDSTATE_ACTIVE)
	{
	  rcvr.GlobalNodeNr = (I_S32)selfEntIdG;
	  switch(msgType)
	  {
		case OAMS_CFG_PSCH_NSE_LOCK_REQ:	
		  LOG_PRINT(INFO,"(ENV:xInEnv)OAMS_CFG_PSCH_NSE_LOCK_REQ: Signal Received ");
		  gNsei = ((OamsCfgPschNseLockReq *)rcvPtr)->nsei;
		  ret = getallPsCellTable(&psCellTableApi,&outCount,&outSize);

		  if((CLIB_SUCCESS != ret) || (outCount == 0))
		  {
			LOG_PRINT(INFO," inside if [ (CLIB_SUCCESS != result) ) ] ");
			sendCfgNseLockUnlockResp(gNsei,I_TRUE);
		  }
		  gNseProc = I_TRUE;
		  refId1 = 0;
		  gNumPsCellNseLockUnlock = 0;
		  LOG_PRINT(CRITICAL,"No.of PSCells get from db: %d \n",outCount);
		  for(index = 0 ; index < outCount  ;index++)
		  {
			tempOutData = (PsCellTableApi *)((I_U8*)psCellTableApi + (index * outSize));

			cellNonPerTableIndices.cellId = (I_U16)tempOutData->cellId; 
			cellNonPerTableIndices.lac =    (I_U16)tempOutData->lac ;
			ret = getCellNonPerTable(&cellNonPerTableIndices, &cellNonPerTableApi ); 
			if(CLIB_SUCCESS == ret )
			{
			  refId2 = cellNonPerTableApi->cellIndex + 1;
			  free(cellNonPerTableApi);
			}
			else
			{
			  LOG_PRINT(DEBUG,"xInEnv:  DBCall failed for cellNonPerTableIndices()"); 
			  free(psCellTableApi);
			  return(PSCH_FAILURE);
			}

			if (SearchAlocatedInst(&lclPidPtr,&instId,ENT_OAMS_PSCH,PSCH_CLASS_ID,refId1,refId2,0,0,0) != INST_SUCCESS)
			{
			  LOG_PRINT(MAJOR,"No PSCH Inst found for cellIndex - [%d]\n",refId2);
			  continue;
			}
			LOG_PRINT(CRITICAL,"PSCH inst found for cellId:[%d], lac:[%d] \n",cellNonPerTableIndices.cellId,cellNonPerTableIndices.lac);
			if (0 == lclPidPtr)
			{
			  LOG_PRINT(CRITICAL,"Invalid Instance Found...\n");
			  DalocMsgBuf(rcvPtr);
			  break;
			}
			
			gNumPsCellNseLockUnlock = gNumPsCellNseLockUnlock + 1;
			rcvr.LocalPId = (xLocalPIdNode)lclPidPtr;
			S = xGetSignal( sig_OAMS_CFG_PSCH_LOCK_REQ, rcvr, xEnv);
			((yPDP_sig_OAMS_CFG_PSCH_LOCK_REQ)S)->Param1 = rcvPtr;
			((yPDP_sig_OAMS_CFG_PSCH_LOCK_REQ)S)->Param2 = gNseProc;
			LOG_PRINT(INFO,"Successfully sent signal to MODEL with nseProc: %d\n",gNseProc);
			SDL_Output( S xSigPrioPar(xDefaultPrioSignal), (xIdNode *)0 );
		  }//end for loop index
		  DalocMsgBuf(rcvPtr);
		  if (psCellTableApi != NULL)
		  {
			free(psCellTableApi);
		  }
		  LOG_PRINT(DEBUG,"(xInEnv:no of signals sent to tau: gNumPsCellNseLockUnlock:[%d]",gNumPsCellNseLockUnlock);
		  if(gNumPsCellNseLockUnlock <= 0)
		  {
			sendCfgNseLockUnlockResp(gNsei,I_TRUE);
		  }
		  return;
		  // break;

		case OAMS_CFG_PSCH_NSE_UNLOCK_REQ :
		  LOG_PRINT(INFO,"(ENV:xInEnv)OAMS_CFG_NSE_UNLOCK_REQ Signal Received ");
		  gNsei = ((OamsCfgPschNseUnlockReq *)rcvPtr)->nsei;
		  ret = getallPsCellTable(&psCellTableApi,&outCount,&outSize);

		  if((CLIB_SUCCESS != ret) || (outCount == 0))
		  {
			LOG_PRINT(INFO," inside if [ (CLIB_SUCCESS != result) ) ] ");
			sendCfgNseLockUnlockResp(gNsei,I_FALSE);
		  }
		  refId1 = 0;
		  gNumPsCellNseLockUnlock = 0;
		  gNseProc = I_TRUE;
		  for(index = 0 ; index < outCount  ;index++)
		  {
			tempOutData = (PsCellTableApi *)((I_U8*)psCellTableApi + (index * outSize));

			cellNonPerTableIndices.cellId = (I_U16)tempOutData->cellId; 
			cellNonPerTableIndices.lac =    (I_U16)tempOutData->lac ;
			ret = getCellNonPerTable(&cellNonPerTableIndices, &cellNonPerTableApi ); 
			if(CLIB_SUCCESS == ret )
			{
			  refId2 = cellNonPerTableApi->cellIndex;
			  refId2 = refId2 + 1 ; 
			  free (cellNonPerTableApi);
			}
			else
			{
			  LOG_PRINT(DEBUG,"xInEnv:  DBCall failed for cellNonPerTableIndices()"); 
			  exit(0) ;
			}

			if (SearchAlocatedInst(&lclPidPtr,&instId,ENT_OAMS_PSCH,PSCH_CLASS_ID,refId1,refId2,0,0,0) != INST_SUCCESS)
			{
			  LOG_PRINT(MAJOR,"No PSCH Inst found for cellIndex - [%d]\n",refId2);
			  continue;
			}
			if (0 == lclPidPtr)
			{
			  LOG_PRINT(CRITICAL,"Invalid Instance Found...\n");
			  DalocMsgBuf(rcvPtr);
			  break;
			}
			gNumPsCellNseLockUnlock = gNumPsCellNseLockUnlock + 1;
			rcvr.LocalPId = (xLocalPIdNode)lclPidPtr;
			S = xGetSignal( sig_OAMS_CFG_PSCH_UNLOCK_REQ, rcvr, xEnv);
			((yPDP_sig_OAMS_CFG_PSCH_UNLOCK_REQ)S)->Param1 = rcvPtr;
			((yPDP_sig_OAMS_CFG_PSCH_UNLOCK_REQ)S)->Param2 = gNseProc;
			SDL_Output( S xSigPrioPar(xDefaultPrioSignal), (xIdNode *)0 );
		  }//end for loop index
		  DalocMsgBuf(rcvPtr);
		  if (psCellTableApi != NULL)
		  {
			free(psCellTableApi);
		  }
		  if(gNumPsCellNseLockUnlock <= 0)
		  {
			sendCfgNseLockUnlockResp(gNsei,I_FALSE);
		  }
		  return;
		  //		  break;

		case OAMS_CFG_PSCH_UNLOCK_REQ :
		  LOG_PRINT(INFO,"(ENV:xInEnv)OAMS_CFG_PSCH_UNLOCK_REQ Signal Received ");

		  //changes for mantis id :16430 
		  cellNonPerTableIndices.cellId =((OamsCfgPschUnlockReq *)rcvPtr)->cellId; 
		  cellNonPerTableIndices.lac = ((OamsCfgPschUnlockReq *)rcvPtr)->lac ;
		  LOG_PRINT(INFO,"(ENV:xInEnv) CellId - [%u] , lac = %d",((OamsCfgPschUnlockReq *)rcvPtr)->cellId, ((OamsCfgPschUnlockReq *)rcvPtr)->lac);
		  ret = getCellNonPerTable(&cellNonPerTableIndices, &cellNonPerTableApi ); 
		  if(CLIB_SUCCESS == ret )
		  {
			refId2 = cellNonPerTableApi->cellIndex;
			refId2 = refId2 + 1 ; 
		  }
		  else
		  {
			LOG_PRINT(DEBUG,"xInEnv:  DBCall failed for cellNonPerTableIndices()"); 
			exit(0) ;
		  }
		  //changes for mantis id :16430 ends 
		  //GetRefId(rcvPtr, &refId1, &refId2);
		  refId1 = 0;
		  LOG_PRINT(INFO,"(ENV:xInEnv)OAMS_CFG_PSCH_UNLOCK_REQ Signal Received for CellIndex - [%u]",refId2);
		  if (SearchAlocatedInst(&lclPidPtr,&instId,ENT_OAMS_PSCH,PSCH_CLASS_ID,refId1,refId2,0,0,0) != INST_SUCCESS)
		  {
			//changes for mantis id :16430 
			GetRefId(rcvPtr, &refId1, &refId2);
			refId2 = cellNonPerTableApi->cellIndex;
			refId2 = refId2 + 1 ; 
			LOG_PRINT(MAJOR,"(ENV:xInEnv)No PSCH Inst found for CellIndex - [%u] so allocting one \n",refId2);

			if (ZERO == gPschInstCount)
			{
			  LOG_PRINT(CRITICAL,"(ENV:xInEnv)No PSCH Found...\n");
			  DalocMsgBuf(rcvPtr);
			  return ;
			}
			if (AlocNewInst(&lclPidPtr,&instId,ENT_OAMS_PSCH,PSCH_CLASS_ID,refId1,refId2,0,0,0) != INST_SUCCESS )
			{
			  LOG_PRINT(CRITICAL,"(ENV:xInEnv)Unable to create New Instance...\n") ;
			  DalocMsgBuf(rcvPtr);
			  return ;
			}
			if (0 == lclPidPtr)
			{
			  LOG_PRINT(CRITICAL,"(ENV:xInEnv)Invalid Instance Found...\n");
			  DalocMsgBuf(rcvPtr);
			  return ;
			}
			for (index = 0; index < gPschInstCount; index ++)
			{
			  if (gBvciList[index] == INVALID_BVCI)
				break;
			}
			gNseProc = I_FALSE;
			LOG_PRINT(DEBUG,"xInEnv: Storing bvci - [%u] at index [%d]", refId1, index);
			gBvciList[index] = refId1;
			rcvr.LocalPId = (xLocalPIdNode)lclPidPtr;
			LOG_PRINT(INFO,"(ENV:xInEnv)Value of Local Pid Pointer - [%d]",lclPidPtr)
			  /* Send this Message into TAU model */
			  S = xGetSignal( sig_OAMS_CFG_PSCH_UNLOCK_REQ, rcvr, xEnv);
			((yPDP_sig_OAMS_CFG_PSCH_UNLOCK_REQ)S)->Param1 = rcvPtr;
			((yPDP_sig_OAMS_CFG_PSCH_UNLOCK_REQ)S)->Param2 = gNseProc;
			break;
			//DalocMsgBuf(rcvPtr);
			//return;
		  }//if search does not fails
		  else
		  {
			if (0 == lclPidPtr)
			{
			  LOG_PRINT(CRITICAL,"(ENV:xInEnv)Invalid Instance Found...\n");
			  DalocMsgBuf(rcvPtr);
			  return ;
			}
			rcvr.LocalPId = (xLocalPIdNode)lclPidPtr;
			S = xGetSignal( sig_OAMS_CFG_PSCH_UNLOCK_REQ, rcvr, xEnv);
			((yPDP_sig_OAMS_CFG_PSCH_UNLOCK_REQ)S)->Param1 = rcvPtr;
			((yPDP_sig_OAMS_CFG_PSCH_UNLOCK_REQ)S)->Param2 = gNseProc;
			break;
		  }
		case CSAPP_GRHM_PSCH_ACT_PDCH_IND:
		  GetRefId(rcvPtr, &refId1, &refId2);
		  LOG_PRINT(INFO,"(ENV:xInEnv)CSAPP_GRHM_PSCH_ACT_PDCH_IND Signal Received from GRHM for CellIndex - [%u]",refId2);
		  if (SearchAlocatedInst(&lclPidPtr,&instId,ENT_OAMS_PSCH,PSCH_CLASS_ID,refId1,refId2,0,0,0) != INST_SUCCESS)
		  {
			LOG_PRINT(MAJOR,"(ENV:xInEnv)No PSCH Inst found for CellIndex - [%u]\n",refId2);
			DalocMsgBuf(rcvPtr);
			return;
		  }
		  if (0 == lclPidPtr)
		  {
			LOG_PRINT(CRITICAL,"(ENV:xInEnv)Invalid Instance Found...\n");
			DalocMsgBuf(rcvPtr);
			return ;
		  }
		  rcvr.LocalPId = (xLocalPIdNode)lclPidPtr;

		  S = xGetSignal( sig_CSAPP_GRHM_PSCH_ACT_PDCH_IND, rcvr, xEnv);
		  ((yPDP_sig_CSAPP_GRHM_PSCH_ACT_PDCH_IND)S)->Param1 = rcvPtr;
		  break;

		case  PSSKS_BSSGP_PSCH_PTP_BVC_RESET_ACK:
		  GetRefId(rcvPtr, &refId1, &refId2);
		  LOG_PRINT(INFO,"(ENV:xInEnv)PSSKS_BSSGP_PSCH_PTP_BVC_RESET_ACK Signal Received for Bvci - [%u]",refId1);
		  if (SearchAlocatedInst(&lclPidPtr,&instId,ENT_OAMS_PSCH,PSCH_CLASS_ID,refId1,refId2,0,0,0) != INST_SUCCESS)
		  {
			LOG_PRINT(MAJOR,"(ENV:xInEnv)No PSCH Inst found for Bvci - [%u]\n",refId1);
			DalocMsgBuf(rcvPtr);
			return;
		  }
		  if (0 == lclPidPtr)
		  {
			LOG_PRINT(CRITICAL,"(ENV:xInEnv)Invalid Instance Found...\n");
			DalocMsgBuf(rcvPtr);
			return ;
		  }
		  rcvr.LocalPId = (xLocalPIdNode)lclPidPtr;
		  S = xGetSignal( sig_PSSKS_BSSGP_PSCH_PTP_BVC_RESET_ACK, rcvr, xEnv);
		  ((yPDP_sig_PSSKS_BSSGP_PSCH_PTP_BVC_RESET_ACK)S)->Param1 = rcvPtr;
		  break;

		case PSSKS_BSSGP_PSCH_PTP_BVC_BLOCK_ACK:
		  GetRefId(rcvPtr, &refId1, &refId2);
		  LOG_PRINT(INFO,"(ENV:xInEnv)PSSKS_BSSGP_PSCH_PTP_BVC_BLOCK_ACK Signal Received for Bvci - [%u]",refId1);
		  if (SearchAlocatedInst(&lclPidPtr,&instId,ENT_OAMS_PSCH,PSCH_CLASS_ID,refId1,refId2,0,0,0) != INST_SUCCESS)
		  {
			LOG_PRINT(MAJOR,"(ENV:xInEnv)No PSCH Inst found for Bvci - [%u]\n",refId1);
			DalocMsgBuf(rcvPtr);
			return;
		  }
		  if (0 == lclPidPtr)
		  {
			LOG_PRINT(CRITICAL,"(ENV:xInEnv)Invalid Instance Found...\n");
			DalocMsgBuf(rcvPtr);
			return ;
		  }
		  rcvr.LocalPId = (xLocalPIdNode)lclPidPtr;
		  S = xGetSignal( sig_PSSKS_BSSGP_PSCH_PTP_BVC_BLOCK_ACK, rcvr, xEnv);
		  ((yPDP_sig_PSSKS_BSSGP_PSCH_PTP_BVC_BLOCK_ACK)S)->Param1 = rcvPtr;
		  break;

		case  PSSKS_BSSGP_PSCH_PTP_BVC_UNBLOCK_ACK:
		  GetRefId(rcvPtr, &refId1, &refId2);
		  LOG_PRINT(INFO,"(ENV:xInEnv)PSSKS_BSSGP_PSCH_PTP_BVC_UNBLOCK_ACK Signal Received for Bvci - [%u]",refId1);
		  if (SearchAlocatedInst(&lclPidPtr,&instId,ENT_OAMS_PSCH,PSCH_CLASS_ID,refId1,refId2,0,0,0) != INST_SUCCESS)
		  {
			LOG_PRINT(MAJOR,"(ENV:xInEnv)No PSCH Inst found for Bvci - [%u]\n",refId1);
			DalocMsgBuf(rcvPtr);
			return;
		  }
		  if (0 == lclPidPtr)
		  {
			LOG_PRINT(CRITICAL,"(ENV:xInEnv)Invalid Instance Found...\n");
			DalocMsgBuf(rcvPtr);
			return ;
		  }
		  rcvr.LocalPId = (xLocalPIdNode)lclPidPtr;
		  S = xGetSignal( sig_PSSKS_BSSGP_PSCH_PTP_BVC_UNBLOCK_ACK, rcvr, xEnv);
		  ((yPDP_sig_PSSKS_BSSGP_PSCH_PTP_BVC_UNBLOCK_ACK)S)->Param1 = rcvPtr;
		  break;

		case  PSSKS_BSSGP_PSCH_PTP_BVC_FLOW_CTRL_ACK:
		  GetRefId(rcvPtr, &refId1, &refId2);
		  LOG_PRINT(INFO,"(ENV:xInEnv)PSSKS_BSSGP_PSCH_PTP_BVC_FLOW_CTRL_ACK Signal Received for Bvci - [%u]",refId1);
		  if (SearchAlocatedInst(&lclPidPtr,&instId,ENT_OAMS_PSCH,PSCH_CLASS_ID,refId1,refId2,0,0,0) != INST_SUCCESS)
		  {
			LOG_PRINT(MAJOR,"(ENV:xInEnv)No PSCH Inst found for Bvci - [%u]\n",refId1);
			DalocMsgBuf(rcvPtr);
			return;
		  }
		  if (0 == lclPidPtr)
		  {
			LOG_PRINT(CRITICAL,"(ENV:xInEnv)Invalid Instance Found...\n");
			DalocMsgBuf(rcvPtr);
			return ;
		  }
		  rcvr.LocalPId = (xLocalPIdNode)lclPidPtr;
		  S = xGetSignal( sig_PSSKS_BSSGP_PSCH_PTP_BVC_FLOW_CTRL_ACK, rcvr, xEnv);
		  ((yPDP_sig_PSSKS_BSSGP_PSCH_PTP_BVC_FLOW_CTRL_ACK)S)->Param1 = rcvPtr;
		  break;

		case PSSKS_BSSGP_PSCH_PTP_BVC_RESET :
		  GetRefId(rcvPtr, &refId1, &refId2);
		  LOG_PRINT(INFO,"(ENV:xInEnv)PSSKS_BSSGP_PSCH_PTP_BVC_RESET Signal Received for Bvci - [%u]",refId1);
		  if (SearchAlocatedInst(&lclPidPtr,&instId,ENT_OAMS_PSCH,PSCH_CLASS_ID,refId1,refId2,0,0,0) != INST_SUCCESS)
		  {
			LOG_PRINT(MAJOR,"(ENV:xInEnv)No PSCH Inst found for Bvci - [%u]\n",refId1);
			DalocMsgBuf(rcvPtr);
			return;
		  }
		  if (0 == lclPidPtr)
		  {
			LOG_PRINT(CRITICAL,"(ENV:xInEnv)Invalid Instance Found...\n");
			DalocMsgBuf(rcvPtr);
			return ;
		  }
		  rcvr.LocalPId = (xLocalPIdNode)lclPidPtr;
		  S = xGetSignal( sig_PSSKS_BSSGP_PSCH_PTP_BVC_RESET, rcvr, xEnv);
		  ((yPDP_sig_PSSKS_BSSGP_PSCH_PTP_BVC_RESET)S)->Param1 = rcvPtr;
		  break;

		case OAMS_GBH_PSCH_SIG_BVC_RESET_IND :
		  LOG_PRINT(DEBUG,"(ENV:xInEnv)OAMS_GBH_PSCH_SIG_BVC_RESET_IND received ");
		  instCountResult = GetInstCount(ENT_OAMS_PSCH, PSCH_CLASS_ID , &instCount);
		  if ( instCountResult != INST_SUCCESS )
		  {
			LOG_PRINT(MAJOR,"(ENV:xInEnv)GetInstCount Db call failed.. ");
			return;
		  }
		  for ( index = 0; index < instCount; index ++ )
		  {
			if (gBvciList[index] != INVALID_BVCI)
			{
			  if (SearchAlocatedInst(&lclPidPtr,&instId,ENT_OAMS_PSCH,PSCH_CLASS_ID,gBvciList[index],0,0,0,0) != INST_SUCCESS)
			  {
				LOG_PRINT(MAJOR,"(ENV:xInEnv)No PSCH Inst found for Bvci - [%u]\n",refId1);
				continue;
			  }
			  if (0 == lclPidPtr)
			  {
				LOG_PRINT(CRITICAL,"(ENV:xInEnv)Invalid Instance Found...\n");
				continue ;
			  }
			  rcvr.LocalPId = (xLocalPIdNode)lclPidPtr;

			  LOG_PRINT(DEBUG,"(ENV:xInEnv)findLclPidPtr Success lclPid = %d",(I_U32)lclPidPtr);
			  if (lclPidPtr != INVALID_LCL_PID_PTR )
			  {
				rcvr.LocalPId = (xLocalPIdNode)lclPidPtr;
				LOG_PRINT(INFO,"(ENV:xInEnv)Sending signal OAMS_GBH_PSCH_SIG_BVC_RESET_IND to Model for bvci - [%u]",gBvciList[index]);
				S = xGetSignal( sig_OAMS_GBH_PSCH_SIG_BVC_RESET_IND, rcvr, xEnv);
				((yPDP_sig_OAMS_GBH_PSCH_SIG_BVC_RESET_IND)S)->Param1 = ((OamsGbhPschSigBvcResetInd *)rcvPtr)->cbl;
				((yPDP_sig_OAMS_GBH_PSCH_SIG_BVC_RESET_IND)S)->Param2 = ((OamsGbhPschSigBvcResetInd *)rcvPtr)->isCblChanged;
				SDL_Output( S xSigPrioPar(xDefaultPrioSignal), (xIdNode *)0 );
			  }
			}
		  }
		  DalocMsgBuf(rcvPtr);
		  return;

		case OAMS_GBH_PSCH_GB_DOWN_IND:
		  LOG_PRINT(DEBUG,"(ENV:xInEnv)OAMS_GBH_PSCH_GB_DOWN_IND received ");
		  instCountResult = GetInstCount(ENT_OAMS_PSCH, PSCH_CLASS_ID , &instCount);
		  if ( instCountResult != INST_SUCCESS )
		  {
			LOG_PRINT(MAJOR,"(ENV:xInEnv)GetInstCount Db call failed.. ");
			return;
		  }
		  for ( index = 0; index < instCount; index ++ )
		  {
			if (gBvciList[index] != INVALID_BVCI)
			{
			  if (SearchAlocatedInst(&lclPidPtr,&instId,ENT_OAMS_PSCH,PSCH_CLASS_ID,gBvciList[index],0,0,0,0) != INST_SUCCESS)
			  {
				LOG_PRINT(MAJOR,"(ENV:xInEnv)No PSCH Inst found for Bvci - [%u]\n",refId1);
				continue;
			  }
			  if (0 == lclPidPtr)
			  {
				LOG_PRINT(CRITICAL,"(ENV:xInEnv)Invalid Instance Found...\n");
				continue ;
			  }
			  rcvr.LocalPId = (xLocalPIdNode)lclPidPtr;
			  LOG_PRINT(DEBUG,"(ENV:xInEnv)findLclPidPtr Success lclPid = %d",(I_U32)lclPidPtr);
			  if (lclPidPtr != INVALID_LCL_PID_PTR )
			  {
				rcvr.LocalPId = (xLocalPIdNode)lclPidPtr;
				LOG_PRINT(INFO,"(ENV:xInEnv)Sending signal OAMS_GBH_PSCH_GB_DOWN_IND to Model");
				S = xGetSignal( sig_OAMS_GBH_PSCH_GB_DOWN_IND, rcvr, xEnv);
				SDL_Output( S xSigPrioPar(xDefaultPrioSignal), (xIdNode *)0 );
			  }
			}
		  }
		  DalocMsgBuf(rcvPtr);
		  return;

		case OAMS_TRXH_PSCH_PS_ALLOWED:
		  GetRefId(rcvPtr, &refId1, &refId2);
		  LOG_PRINT(INFO,"(ENV:xInEnv)OAMS_TRXH_PSCH_PS_ALLOWED Signal Received for CellIndex - [%u]",refId2);
		  if (SearchAlocatedInst(&lclPidPtr,&instId,ENT_OAMS_PSCH,PSCH_CLASS_ID,refId1,refId2,0,0,0) != INST_SUCCESS)
		  {
			//changes for mantis id : 15499
			psCellTableIndex.cellId =((OamsTrxhPschPsAllowed *)rcvPtr)->cellId; //refId2; //((OamsTrxhPschPsAllowed *)rcvPtr)->cellIndex  + 1;
			psCellTableIndex.lac = ((OamsTrxhPschPsAllowed *)rcvPtr)->lac ;
			LOG_PRINT(INFO,"(ENV:xInEnv) CellIndex - [%u] , lac = %d",((OamsTrxhPschPsAllowed *)rcvPtr)->cellIndex, ((OamsTrxhPschPsAllowed *)rcvPtr)->lac);
			ret = getPsCellTable(&psCellTableIndex, &psCellTableApi); 
			if(CLIB_SUCCESS == ret ){
			  if(psCellTableApi->bvciId > 0){
				refId1 = psCellTableApi->bvciId;
				LOG_PRINT(MAJOR,"(ENV:xInEnv)No PSCH Inst found for CellIndex - [%u] so allocting one \n",refId2);

				if (ZERO == gPschInstCount)
				{
				  LOG_PRINT(CRITICAL,"(ENV:xInEnv)No PSCH Found...\n");
				  DalocMsgBuf(rcvPtr);
				  return ;
				}
				if (AlocNewInst(&lclPidPtr,&instId,ENT_OAMS_PSCH,PSCH_CLASS_ID,refId1,refId2,0,0,0) != INST_SUCCESS )
				{
				  LOG_PRINT(CRITICAL,"(ENV:xInEnv)Unable to create New Instance...\n") ;
				  DalocMsgBuf(rcvPtr);
				  return ;
				}
				if (0 == lclPidPtr)
				{
				  LOG_PRINT(CRITICAL,"(ENV:xInEnv)Invalid Instance Found...\n");
				  DalocMsgBuf(rcvPtr);
				  return ;
				}
				for (index = 0; index < gPschInstCount; index ++)
				{
				  if (gBvciList[index] == INVALID_BVCI)
					break;
				}
				LOG_PRINT(DEBUG,"xInEnv: Storing bvci - [%u] at index [%d]", refId1, index);
				gBvciList[index] = refId1;
				rcvr.LocalPId = (xLocalPIdNode)lclPidPtr;
				LOG_PRINT(INFO,"(ENV:xInEnv)Value of Local Pid Pointer - [%d]",lclPidPtr)
				  /* Send this Message into TAU model */
				  S = xGetSignal( sig_OAMS_TRXH_PSCH_PS_ALLOWED, rcvr, xEnv);
				((yPDP_sig_OAMS_TRXH_PSCH_PS_ALLOWED)S)->Param1 = rcvPtr;
				break;
			  }//bvciid
			}//ret
			else{
			  LOG_PRINT(DEBUG,"xInEnv:  DBCall failed for getPsCellTable()"); 
			  exit(0) ;
			}
		  }//if search fails
		  else
		  {
			if (0 == lclPidPtr)
			{
			  LOG_PRINT(CRITICAL,"(ENV:xInEnv)Invalid Instance Found...\n");
			  DalocMsgBuf(rcvPtr);
			  return ;
			}
			rcvr.LocalPId = (xLocalPIdNode)lclPidPtr;
			S = xGetSignal( sig_OAMS_TRXH_PSCH_PS_ALLOWED, rcvr, xEnv);
			((yPDP_sig_OAMS_TRXH_PSCH_PS_ALLOWED)S)->Param1 = rcvPtr;
			break;
		  }
		case  OAMS_TRXH_PSCH_PS_NOT_ALLOWED:
		  GetRefId(rcvPtr, &refId1, &refId2);
		  LOG_PRINT(INFO,"(ENV:xInEnv)OAMS_TRXH_PSCH_PS_NOT_ALLOWED Signal Received for CellIndex - [%u]",refId2);
		  if (SearchAlocatedInst(&lclPidPtr,&instId,ENT_OAMS_PSCH,PSCH_CLASS_ID,refId1,refId2,0,0,0) != INST_SUCCESS)
		  {
			LOG_PRINT(MAJOR,"(ENV:xInEnv)No PSCH Inst found for CellIndex - [%u]\n",refId2);
			DalocMsgBuf(rcvPtr);
			return;
		  }
		  if (0 == lclPidPtr)
		  {
			LOG_PRINT(CRITICAL,"(ENV:xInEnv)Invalid Instance Found...\n");
			DalocMsgBuf(rcvPtr);
			return ;
		  }
		  rcvr.LocalPId = (xLocalPIdNode)lclPidPtr;
		  S = xGetSignal( sig_OAMS_TRXH_PSCH_PS_NOT_ALLOWED, rcvr, xEnv);
		  ((yPDP_sig_OAMS_TRXH_PSCH_PS_NOT_ALLOWED)S)->Param1 = rcvPtr;
		  break;

		case  OAMS_PSSCM_PSCH_PROV_PTP_BVC_CNF:
		  GetRefId(rcvPtr, &refId1, &refId2);
		  LOG_PRINT(INFO,"(ENV:xInEnv)OAMS_PSSCM_PSCH_PROV_PTP_BVC_CNF Signal Received for Bvci - [%u]",refId1);
		  if (SearchAlocatedInst(&lclPidPtr,&instId,ENT_OAMS_PSCH,PSCH_CLASS_ID,refId1,refId2,0,0,0) != INST_SUCCESS)
		  {
			LOG_PRINT(MAJOR,"(ENV:xInEnv)No PSCH Inst found for Bvci - [%u]\n",refId1);
			DalocMsgBuf(rcvPtr);
			return;
		  }
		  if (0 == lclPidPtr)
		  {
			LOG_PRINT(CRITICAL,"(ENV:xInEnv)Invalid Instance Found...\n");
			DalocMsgBuf(rcvPtr);
			return ;
		  }
		  rcvr.LocalPId = (xLocalPIdNode)lclPidPtr;
		  S = xGetSignal( sig_OAMS_PSSCM_PSCH_PROV_PTP_BVC_CNF, rcvr, xEnv);
		  ((yPDP_sig_OAMS_PSSCM_PSCH_PROV_PTP_BVC_CNF)S)->Param1 = rcvPtr;
		  break;

		case  OAMS_PSSCM_PSCH_UNPROV_PTP_BVC_CNF:
		  GetRefId(rcvPtr, &refId1, &refId2);
		  LOG_PRINT(INFO,"(ENV:xInEnv)OAMS_PSSCM_PSCH_UNPROV_PTP_BVC_CNF Signal Received for Bvci - [%u]",refId1);
		  if (SearchAlocatedInst(&lclPidPtr,&instId,ENT_OAMS_PSCH,PSCH_CLASS_ID,refId1,refId2,0,0,0) != INST_SUCCESS)
		  {
			LOG_PRINT(MAJOR,"(ENV:xInEnv)No PSCH Inst found for Bvci - [%u]\n",refId1);
			DalocMsgBuf(rcvPtr);
			return;
		  }
		  if (0 == lclPidPtr)
		  {
			LOG_PRINT(CRITICAL,"(ENV:xInEnv)Invalid Instance Found...\n");
			DalocMsgBuf(rcvPtr);
			return ;
		  }
		  rcvr.LocalPId = (xLocalPIdNode)lclPidPtr;

		  S = xGetSignal( sig_OAMS_PSSCM_PSCH_UNPROV_PTP_BVC_CNF, rcvr, xEnv);
		  ((yPDP_sig_OAMS_PSSCM_PSCH_UNPROV_PTP_BVC_CNF)S)->Param1 = rcvPtr;
		  break;

		case OAMS_CFG_PSCH_LOCK_REQ:
		  LOG_PRINT(INFO,"(ENV:xInEnv)OAMS_CFG_PSCH_LOCK_REQ: Signal Received ");

		  //changes for mantis id :16430 
		  cellNonPerTableIndices.cellId =((OamsCfgPschLockReq *)rcvPtr)->cellId; 
		  cellNonPerTableIndices.lac = ((OamsCfgPschLockReq *)rcvPtr)->lac ;
		  LOG_PRINT(INFO,"(ENV:xInEnv) CellIndex - [%u] , lac = %d",((OamsCfgPschLockReq *)rcvPtr)->cellIndex, ((OamsCfgPschLockReq *)rcvPtr)->lac);
		  ret = getCellNonPerTable(&cellNonPerTableIndices, &cellNonPerTableApi ); 
		  if(CLIB_SUCCESS == ret )
		  {
			refId2 = cellNonPerTableApi->cellIndex;
			refId2 = refId2 + 1 ; 
		  }
		  else
		  {
			LOG_PRINT(DEBUG,"xInEnv:  DBCall failed for cellNonPerTableIndices()"); 
			exit(0) ;
		  }
		  refId1 = 0;
		  //changes for mantis id :16430 ends 
		  //GetRefId(rcvPtr, &refId1, &refId2);
		  LOG_PRINT(INFO,"(ENV:xInEnv)OAMS_CFG_PSCH_LOCK_REQ Signal Received for CellIndex - [%u]",refId2);
		  if (SearchAlocatedInst(&lclPidPtr,&instId,ENT_OAMS_PSCH,PSCH_CLASS_ID,refId1,refId2,0,0,0) != INST_SUCCESS)
		  {
			LOG_PRINT(MAJOR,"(ENV:xInEnv)No PSCH Inst found for CellIndex - [%u]\n",refId2);
			DalocMsgBuf(rcvPtr);
			return;
		  }
		  if (0 == lclPidPtr)
		  {
			LOG_PRINT(CRITICAL,"(ENV:xInEnv)Invalid Instance Found...\n");
			DalocMsgBuf(rcvPtr);
			return ;
		  }
		  gNseProc = I_FALSE;;
		  rcvr.LocalPId = (xLocalPIdNode)lclPidPtr;
		  S = xGetSignal( sig_OAMS_CFG_PSCH_LOCK_REQ, rcvr, xEnv);
		  ((yPDP_sig_OAMS_CFG_PSCH_LOCK_REQ)S)->Param1 = rcvPtr;
		  ((yPDP_sig_OAMS_CFG_PSCH_LOCK_REQ)S)->Param2 = gNseProc;
		  break;

		case  OAMS_CFG_PSCH_SHUTDOWN_IND:
		  LOG_PRINT(INFO,"(ENV:xInEnv)OAMS_CFG_PSCH_SHUTDOWN_IND: Signal Received ");
		  //changes for mantis id :16430 
		  cellNonPerTableIndices.cellId =((OamsCfgPschShutdownInd *)rcvPtr)->cellId; 
		  cellNonPerTableIndices.lac = ((OamsCfgPschShutdownInd *)rcvPtr)->lac ;
		  LOG_PRINT(INFO,"(ENV:xInEnv) CellIndex - [%u] , lac = %d",((OamsCfgPschShutdownInd *)rcvPtr)->cellIndex, ((OamsCfgPschShutdownInd *)rcvPtr)->lac);
		  ret = getCellNonPerTable(&cellNonPerTableIndices, &cellNonPerTableApi ); 
		  if(CLIB_SUCCESS == ret )
		  {
			refId2 = cellNonPerTableApi->cellIndex;
			refId2 = refId2 + 1 ; 
		  }
		  else
		  {
			LOG_PRINT(DEBUG,"xInEnv:  DBCall failed for cellNonPerTableIndices()"); 
			exit(0) ;
		  }
		  refId1 = 0;
		  //changes for mantis id :16430 ends 
		  //GetRefId(rcvPtr, &refId1, &refId2);
		  LOG_PRINT(INFO,"(ENV:xInEnv)OAMS_CFG_PSCH_SHUTDOWN_IND Signal Received for CellIndex - [%u]",refId2);
		  if (SearchAlocatedInst(&lclPidPtr,&instId,ENT_OAMS_PSCH,PSCH_CLASS_ID,refId1,refId2,0,0,0) != INST_SUCCESS)
		  {
			LOG_PRINT(MAJOR,"(ENV:xInEnv)No PSCH Inst found for CellIndex - [%u]\n",refId2);
			DalocMsgBuf(rcvPtr);
			return;
		  }
		  if (0 == lclPidPtr)
		  {
			LOG_PRINT(CRITICAL,"(ENV:xInEnv)Invalid Instance Found...\n");
			DalocMsgBuf(rcvPtr);
			return ;
		  }
		  rcvr.LocalPId = (xLocalPIdNode)lclPidPtr;
		  S = xGetSignal( sig_OAMS_CFG_PSCH_SHUTDOWN_IND, rcvr, xEnv);
		  ((yPDP_sig_OAMS_CFG_PSCH_SHUTDOWN_IND)S)->Param1 = rcvPtr;
		  break;

		case  OAMS_CFG_PSCH_CELL_BAR_ACCESS:
		  LOG_PRINT(INFO,"(ENV:xInEnv)OAMS_CFG_PSCH_CELL_BAR_ACCESS: Signal Received ");
		  //changes for mantis id :16430 
		  cellNonPerTableIndices.cellId =((OamsCfgPschCellBarAccess *)rcvPtr)->cellId; 
		  cellNonPerTableIndices.lac = ((OamsCfgPschCellBarAccess *)rcvPtr)->lac ;
		  LOG_PRINT(INFO,"(ENV:xInEnv) CellIndex - [%u] , lac = %d",((OamsCfgPschCellBarAccess *)rcvPtr)->cellIndex, ((OamsCfgPschCellBarAccess *)rcvPtr)->lac);
		  ret = getCellNonPerTable(&cellNonPerTableIndices, &cellNonPerTableApi ); 
		  if(CLIB_SUCCESS == ret )
		  {
			refId2 = cellNonPerTableApi->cellIndex;
			refId2 = refId2 + 1 ; 
		  }
		  else
		  {
			LOG_PRINT(DEBUG,"xInEnv:  DBCall failed for cellNonPerTableIndices()"); 
			exit(0) ;
		  }
		  refId1 = 0;
		  //changes for mantis id :16430 ends 
		  //GetRefId(rcvPtr, &refId1, &refId2);
		  LOG_PRINT(INFO,"(ENV:xInEnv)OAMS_CFG_PSCH_CELL_BAR_ACCESS Signal Received for CellIndex - [%u]",refId2);
		  if (SearchAlocatedInst(&lclPidPtr,&instId,ENT_OAMS_PSCH,PSCH_CLASS_ID,refId1,refId2,0,0,0) != INST_SUCCESS)
		  {
			LOG_PRINT(MAJOR,"(ENV:xInEnv)No PSCH Inst found for CellIndex - [%u]\n",refId2);
			DalocMsgBuf(rcvPtr);
			return;
		  }
		  if (0 == lclPidPtr)
		  {
			LOG_PRINT(CRITICAL,"(ENV:xInEnv)nvalid Instance Found...\n");
			DalocMsgBuf(rcvPtr);
			return ;
		  }
		  rcvr.LocalPId = (xLocalPIdNode)lclPidPtr;
		  S = xGetSignal( sig_OAMS_CFG_PSCH_CELL_BAR_ACCESS, rcvr, xEnv);
		  ((yPDP_sig_OAMS_CFG_PSCH_CELL_BAR_ACCESS)S)->Param1 = rcvPtr;
		  break;

		case  OAMS_CFG_PSCH_BVC_OP_FAILED:
		  LOG_PRINT(INFO,"(ENV:xInEnv)OAMS_CFG_PSCH_BVC_OP_FAILED Signal Received ");
		  GetRefId(rcvPtr, &refId1, &refId2);
		  LOG_PRINT(INFO,"(ENV:xInEnv)OAMS_CFG_PSCH_BVC_OP_FAILED Signal Received for Bvci - [%u], CellIndex - [%u]",refId1,refId2);
		  if (SearchAlocatedInst(&lclPidPtr,&instId,ENT_OAMS_PSCH,PSCH_CLASS_ID,refId1,refId2,0,0,0) != INST_SUCCESS)
		  {
			LOG_PRINT(MAJOR,"(ENV:xInEnv)No PSCH Inst found for Bvci - [%u], CellIndex - [%u]\n",refId1,refId2);
			DalocMsgBuf(rcvPtr);
			return;
		  }
		  if (0 == lclPidPtr)
		  {
			LOG_PRINT(CRITICAL,"(ENV:xInEnv)Invalid Instance Found...\n");
			DalocMsgBuf(rcvPtr);
			return ;
		  }
		  rcvr.LocalPId = (xLocalPIdNode)lclPidPtr;
		  S = xGetSignal( sig_OAMS_CFG_PSCH_BVC_OP_FAILED, rcvr, xEnv);
		  ((yPDP_sig_OAMS_CFG_PSCH_BVC_OP_FAILED)S)->Param1 = rcvPtr;
		  break;

#if BPM_PRESENT != 1
		case BPM_SELFCARD_STATE_CHANGE :
		  LOG_PRINT(DEBUG,"(ENV:xInEnv)Locking Semaphore...");
		  if( SEM_WAIT(&gSemHandler) !=0)
			LOG_PRINT(DEBUG,"SEM_WAIT failed ");

		  LOG_PRINT(DEBUG,"(ENV:xInEnv)BPM_SELFCARD_STATE_CHANGE received ");
		  param = (struct sAisParam *)(rcvPtr+sizeof(SysHdr));
		  cardStateChangeHandler(param);
		  LOG_PRINT(DEBUG,"(ENV:xInEnv)Waiting For Semaphore....");
		  if( SEM_TIMED_WAIT(&gSemHandler) != SEMAPHORE_WAIT_COMPLETE)
		  {
			LOG_PRINT(INFO,"(ENV:xInEnv)Got Sempahore.. ");
			LOG_PRINT(INFO,"(ENV:xInEnv)calling bpmRespondToAis.. ");
			bpmRespondToAis (param->invocation, OK);
			LOG_PRINT(INFO,"(ENV:xInEnv)Response sent to BPM.. ");
			LOG_PRINT(INFO,"(ENV:xInEnv)Releasing Sempahore.. ");
			SEM_POST(&gSemHandler);
		  }
		  else
		  {
			LOG_PRINT(INFO,"(ENV:xInEnv)Semaphore Wait Timed Out.. ");
			LOG_PRINT(INFO,"(ENV:xInEnv)Releasing semaphore.. ");
			SEM_POST(&gSemHandler);
		  }
		  DalocMsgBuf(rcvPtr) ;
		  return;
#endif

		default:
		  LOG_PRINT(MAJOR,"(ENV:xInEnv)Invalid Msg. Rcvd. From Outside(msgTyp = 0x%d) ",((SysHdr *)rcvPtr)->msgType);
		  DalocMsgBuf(rcvPtr);
		  return;
	  }/*End of Switch condition*/

	  SDL_Output( S xSigPrioPar(xDefaultPrioSignal), (xIdNode *)0 );

	}
	else
	{
	  if (msgType == BPM_SELFCARD_STATE_CHANGE)
	  {
#if BPM_PRESENT != 1
		LOG_PRINT(DEBUG,"(ENV:xInEnv)Locking Semaphore...");
		if( SEM_WAIT(&gSemHandler) !=0)
		  LOG_PRINT(DEBUG,"(ENV:xInEnv)SEM_WAIT failed ");

		LOG_PRINT(DEBUG,"(ENV:xInEnv)BPM_SELFCARD_STATE_CHANGE received ");
		param = (struct sAisParam *)(rcvPtr+sizeof(SysHdr));
		cardStateChangeHandler(param);
		LOG_PRINT(DEBUG,"(ENV:xInEnv)Waiting For Semaphore....");
		if( SEM_TIMED_WAIT(&gSemHandler) != SEMAPHORE_WAIT_COMPLETE)
		{
		  LOG_PRINT(INFO,"(ENV:xInEnv)Got Sempahore.. ");
		  LOG_PRINT(INFO,"(ENV:xInEnv)calling bpmRespondToAis.. ");
		  bpmRespondToAis (param->invocation, OK);
		  LOG_PRINT(INFO,"(ENV:xInEnv)Response sent to BPM.. ");
		  LOG_PRINT(INFO,"(ENV:xInEnv)Releasing Sempahore.. ");
		  SEM_POST(&gSemHandler);
		}
		else
		{
		  LOG_PRINT(INFO,"(ENV:xInEnv)Semaphore Wait Timed Out... ");
		  LOG_PRINT(INFO,"(ENV:xInEnv)Releasing semaphore.. ");
		  SEM_POST(&gSemHandler);
		}

#endif
	  }
	  else
	  {
		LOG_PRINT(DEBUG,"(ENV:xInEnv)Card isn't in Active State , So discarding the received message..... ");
		DalocMsgBuf(rcvPtr) ;
	  }
	}

  }/*End of If Condition*/

#ifdef XTENV
  return SDL_Time_Lit((xint32) ZERO,(xint32) ZERO);
#endif
}


