
/* SKELETON for env functions */
/* Program generated by Cadvanced 3.0.0.0.2032 */
#define XSCT_CADVANCED

#define C_TRANSLATOR_2_6
#include "scttypes.h"
#ifdef XUSE_SIGNAL_NUMBERS
#include "System_TRXHM.hs"
#endif
#ifdef XENV_INC
#include XENV_INC
#endif
#include "System_TRXHM.ifc"
#define SELF_ENTITY_NAME "TRXHM"

#ifndef XNOGLOBALNODENUMBER
/*---+---------------------------------------------------------------
     xGlobalNodeNumber  extern
-------------------------------------------------------------------*/
#ifndef XENV_NODENUMBER
#define XENV_NODENUMBER return 1;
#endif
I_S32  selfEntIdG ;
/*Changes merged from R2.9 Issue #31185 Gaurav Sinha*/
I_Void prepareAlarmFromFailureEventReportForR3(CsappAbihmTrxhFailureEventReport *pRcvdMsg,I_U32 *pAlarmId,I_U32 *pAlarmLevel,I_U8 alarmString[100]);
extern int xGlobalNodeNumber(void)
{
  /* Assign a unique global system Id to each SDL system in a cluster of systems. */
   return ENT_OAMS_TRXH ;
   XENV_NODENUMBER
}
#endif


//BSC-4.0 HA-Redundancy changes

//#define OAMS_RM_TRXH_DBRW_INIT 345 //FIXME
#include<pthread.h>


#include "bpmxxx_commonDef.h"
#include "bpmxxx_platformLib.h"
#include "bpmxxx_OAM_commonDef.h"
#include "oamsxxx_semaphore.h" //FIXME
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
/* IP class changes Start */
I_U8 getActiveClassIdFromPtrxIdTei(I_U32 ptrxId,I_S32 tei)
{
    I_S32   errCode = 0;
    I_U8    actClsId = 0;
  
    if(ptrxId != 0)
    {
        errCode = getTrxTeiTrxTsTeiTable(ptrxId,&tei);
        if(CLIB_SUCCESS != errCode)
        {
            LOG_PRINT(CRITICAL,"Error in getTrxTeiTrxTsTeiTable: err = %s",clib_strerror(errCode));
            return;
        }
    }
    if(tei <= TEI_RANGE_R2_TDM)
    {
        actClsId = TRXH_HANDLER_TDM;
    }
    else if(tei > TEI_RANGE_R2_TDM && tei <= TEI_MAX_VALUE)
    {
        actClsId = TRXH_HANDLER_IP;
    }
    return actClsId;
}
/* Changes of IP class Ends */

I_U32 getIpAddrIntFromIpStr(const char* ipAddrStr) 
{
  I_U32 ipAddr=ZERO;
  struct sockaddr_in sockAddr;
  I_S32 status;

  LOG_PRINT(DEBUG,"Ip Address String %s",ipAddrStr);
  status=inet_aton(ipAddrStr, &sockAddr.sin_addr); // store IP in sockAddr 
  if(status == ZERO)
  {
    LOG_PRINT(CRITICAL,"Ip Address is invalid");
    return ipAddr;
  }
  ipAddr=(I_U32)sockAddr.sin_addr.s_addr;
  LOG_PRINT(INFO,"IpAddress is 0x%x",ipAddr);

  return ipAddr;
}

I_Void reg_sig_hndlr(I_Void); 
I_S32 gCurrentCardState = CARDSTATE_INIT;
I_S32 gNewCardState = BSC_APP_CARDSTATE_INVALID;
I_S32 gInvocation;
I_U32 gInstancesCreated = I_FALSE;
I_U32 gMsgsSent = ZERO;
I_U16	gInstCount = ZERO;
sem_t gSemHandler;

/* 
  Added for R2.5-HA No LAPD Down Feature. 
  Dated: 02-Aug-2010.
*/
I_U32 gHaNoLapdDownStateChangeMsgSent = ZERO;
I_U32 gIsTransitionViaStandBy         = I_FALSE;

/*
  Added for DB Unlocked Ind From RM.
  Dated: 21-Sep-2010
*/
I_U32 gIsDbUnlockedByRm               = I_FALSE;
I_U32 gIsBpmCallBackRcvd              = I_FALSE;

#if BPM_PRESENT != 1

#define bpmRespondToAis(a,b) do{\
                               ;}while(0);
#endif

/*************
*
*
*
*/
void buildNSendRmAipResp(I_U32 msgOpCode);

void handleStandByToAip(void)
{
    xSignalNode         S;
    I_U32 myOutCount                           =  ZERO;
    I_U16 myOutSize                            =  ZERO;
    I_U32 outCount                             =  ZERO;
    I_U16 outSize                              =  ZERO;
	  I_S32 myResult                             =  ZERO;
	  I_S32 result                               =  ZERO;
    TrxTableApi *trxTableApiPtr                =  NULL;
    TrxTableApi *tmpTrxTableApiPtr             =  NULL;
    TrxContextTableApi  *trxContextTablePtr    =  NULL;
    TrxContextTableApi  *tmpTrxContextTablePtr =  NULL;
    I_U32               idx                    = ZERO;
    I_U32               HaNoLapdDownIndex      = ZERO;
    I_S32               tei                    = ZERO;
    I_U32               refId                  = ZERO;
	  I_U32               lclPidPtr              = ZERO ;
	  I_S32               retVal;
	  I_S32               instId                 = ZERO ;
	  InstMapTbl          *instMapTblPtr_i;
	  SDL_Pid             rcvr;
	  I_U16	              instCount              = ZERO;
	  I_U32               ptrxMaxList[60];
    I_U8                actClsId = 0;

    rcvr.GlobalNodeNr = (I_S32)selfEntIdG;
    rcvr.LocalPId = (xLocalPIdNode)ZERO;


      /* refId points to the pTrxId */
      memset(&ptrxMaxList[ZERO],ZERO,(sizeof(I_U32) * 60));

      result    = getallTrxContextTable(&trxContextTablePtr,&outCount,&outSize);
      myResult  = getallTrxTable(&trxTableApiPtr, &myOutCount, &myOutSize);
      
      if((CLIB_SUCCESS != result) && (CLIB_SUCCESS != myResult))
      {
           LOG_PRINT(DEBUG,"No entries found in PtrxContxtTable or TrxTable");
           gCurrentCardState = CARDSTATE_ACTIVE_IN_PROGRESS;
           gNewCardState     = BSC_APP_CARDSTATE_INVALID;
           buildNSendRmAipResp(OAMS_TRXHM_RM_AIP_RESP);
           LOG_PRINT(INFO,"Releasing sem.. ");
	    	   SEM_POST(&gSemHandler);
      }
      else if(outCount == myOutCount)
      {
         LOG_PRINT(DEBUG,"PtrxStateContxtTable and TrxTable have same no. of TRX entries");
         for(HaNoLapdDownIndex  = ZERO, tmpTrxTableApiPtr = (I_PVoid)trxTableApiPtr; \
            HaNoLapdDownIndex < outCount; HaNoLapdDownIndex++)
         {
   			    tmpTrxContextTablePtr = (TrxContextTableApi*)((I_U8 *)(trxContextTablePtr) + \
                              (HaNoLapdDownIndex * outSize) );
            ptrxMaxList[tmpTrxContextTablePtr->ptrxId] = tmpTrxContextTablePtr->ptrxId;

            LOG_PRINT(DEBUG,"(R2.5 HA No LAPD Down) ptrxId fetched from ptrxContxtTable & store in ptrxMaxList[%d] =\
            [%d]",tmpTrxContextTablePtr->ptrxId,ptrxMaxList[tmpTrxContextTablePtr->ptrxId]);
         }
      }
      else if((myOutCount > outCount) || (myOutCount < outCount))
      {
          LOG_PRINT(DEBUG,"(R2.5 HA No LAPD Down) No. of TRX in PtrxContxtTable < TRXtable, Possibly Switchover\
          happened during TRX Add procedure");
          for(HaNoLapdDownIndex  = ZERO; HaNoLapdDownIndex < outCount; HaNoLapdDownIndex++)
          {
            tmpTrxContextTablePtr = (TrxContextTableApi*)((I_U8 *)(trxContextTablePtr) + \
                              (HaNoLapdDownIndex * outSize) );
            ptrxMaxList[tmpTrxContextTablePtr->ptrxId] = tmpTrxContextTablePtr->ptrxId;
            LOG_PRINT(DEBUG,"(R2.5 HA No LAPD Down) ptrxId fetched from ptrxContxtTable & store in ptrxMaxList[%d] = \
            [%d]",tmpTrxContextTablePtr->ptrxId,ptrxMaxList[tmpTrxContextTablePtr->ptrxId]);
          }
          for(HaNoLapdDownIndex  = ZERO, tmpTrxTableApiPtr = (I_PVoid)trxTableApiPtr; \
                    HaNoLapdDownIndex < myOutCount; HaNoLapdDownIndex++)
          {
              trxTableApiPtr = (TrxTableApi *)(((I_U8 *)(tmpTrxTableApiPtr)) + (HaNoLapdDownIndex * myOutSize));
              trxTableApiPtr->ptrxId;

              if(ZERO == ptrxMaxList[trxTableApiPtr->ptrxId])
              {
                 ptrxMaxList[trxTableApiPtr->ptrxId] = trxTableApiPtr->ptrxId;
                 LOG_PRINT(DEBUG,"(R2.5 HA No LAPD Down) ptrxId fetched from TrxTable & store in ptrxMaxList[%d] = \
                 [%d]",trxTableApiPtr->ptrxId,ptrxMaxList[trxTableApiPtr->ptrxId]);
              }
              else
              {
                LOG_PRINT(DEBUG,"(R2.5 HA No LAPD Down) ptrxId is already stored in ptrxMaxList[%d] = \
                 [%d]",trxTableApiPtr->ptrxId,ptrxMaxList[trxTableApiPtr->ptrxId]);
              }
          }

      }
      else
      {
         LOG_PRINT(DEBUG,"(R2.5 HA No LAPD Down) UNEXPECTED: condition" );
      }

      if (NULL != tmpTrxTableApiPtr)
      {
         LOG_PRINT(DEBUG,"(R2.5.5-ABIS HA) tmpTrxTableApiPtr is being freed");
         free(tmpTrxTableApiPtr);
      }
      if (NULL != trxContextTablePtr)
      {
         LOG_PRINT(DEBUG,"(R2.5.5-ABIS HA) trxContextTablePtr is being freed");
         free(trxContextTablePtr);
      }
      /* 
        If atleast one entry is found then send it to Model otherwise update the 
        global variables and release the semaphore.
      */
      if(CARDSTATE_ACTIVE_IN_PROGRESS != gCurrentCardState)
      {
        for(HaNoLapdDownIndex=ZERO; HaNoLapdDownIndex < 60 /*To be replaced by Macro*/; HaNoLapdDownIndex++)
        {
            refId = ptrxMaxList[HaNoLapdDownIndex];
            if (ZERO == refId)
            {
               LOG_PRINT(DEBUG,"(R2.5 HA No LAPD Down) ptrxMaxList[%d]=%d",HaNoLapdDownIndex, \
               ptrxMaxList[HaNoLapdDownIndex]);
               continue;
            }
            /*     Allocating new instance for all replicated TRX.     */
            /* R2.9 changes starts */
            result = getTrxTeiTrxTsTeiTable(refId,&tei);
            if(CLIB_SUCCESS != result)
            {
               LOG_PRINT(CRITICAL,"Error in getTrxTeiTrxTsTeiTable: err = %s",clib_strerror(result));
               return;
            }

            actClsId = getActiveClassIdFromPtrxIdTei(0,tei);
            if(actClsId == 0)
            {
              return;
            }

            if (SearchAlocatedInst(&lclPidPtr,&instId,ENT_OAMS_TRXH,actClsId,refId,ZERO,ZERO,ZERO,ZERO) \
                             != INST_SUCCESS)
					  {
      				 LOG_PRINT(CRITICAL,"No TRXHM Ins found for PTRXID = [%d]",refId);
               if (AlocNewInst(&lclPidPtr, &instId, ENT_OAMS_TRXH,
	                                    actClsId,refId,
	                            tei, ZERO, ZERO, ZERO)  != INST_SUCCESS)
	             {
	               LOG_PRINT(CRITICAL, "xInEnv : AlocNewInst() Failed for TRXH");
	               return;
	             }
               else
               {
                  LOG_PRINT(DEBUG, "xInEnv : NEW INSTANCE ALLOCATED FOR TRXH  \
                                     LCLPID: 0x%0x, INSTANCE-ID: %d, TRX-ID: %u",
                                     lclPidPtr, instId, refId);
               }
            }
			      else
            {
                LOG_PRINT(DEBUG, "xInEnv : INSTANCE ALLOCATED SEARCHED FOR TRXH  \
                                     LCLPID: 0x%0x, INSTANCE-ID: %d, TRX-ID: %u",
                                     lclPidPtr, instId, refId);
            }
          /* R2.9 changes ends */  
            
            LOG_PRINT(DEBUG,"(R2.5 HA No LAPD Down) Tau Inst [%d] mapped to PtrxId [%d] while transition \
            SBY->AIP",instId,refId);
        
   		      if (lclPidPtr == 0)
   		      {
       	        LOG_PRINT(CRITICAL,"Invalid Inst Found...");
      		      continue;
   		      }
			      else
			      {
     			  	  LOG_PRINT(INFO,"Sending TRXH_INT_SELFCARD_STATE_CHANGE to Model for ptrx: %d, lclPid: %x ", refId, lclPidPtr);
					      rcvr.LocalPId = (xLocalPIdNode)lclPidPtr;
					      S = xGetSignal( sig_TRXH_INT_SELFCARD_STATE_CHANGE, rcvr, xEnv);
      		      (((yPDP_sig_TRXH_INT_SELFCARD_STATE_CHANGE)S)->Param1) = BSC_APP_CARDSTATE_STANDBY;
          		  (((yPDP_sig_TRXH_INT_SELFCARD_STATE_CHANGE)S)->Param2) = BSC_APP_CARDSTATE_ACTIVE_IN_PROGRESS;
          		  (((yPDP_sig_TRXH_INT_SELFCARD_STATE_CHANGE)S)->Param3) = refId;
      	        SDL_Output( S xSigPrioPar(xDefaultPrioSignal), (xIdNode *)ZERO);
          
                gHaNoLapdDownStateChangeMsgSent++;
                gNewCardState = CARDSTATE_ACTIVE_IN_PROGRESS;
		        } /* End of else */
        } /* End of For Loop */
      }
}

/**************************************************************************************************************************
*Description: This module prepares and send OAMS_TRXHM_RM_AIP_REQ to RM once
*             semaphore is released and response sent to BPM for callback SBY->AIP.
*Dated:       22-Sep-2010
*Release:     R.5.5-ABIS HA
*/

void buildNSendRmAipResp(I_U32 msgOpCode)
{
  OamsTrxhmRmAipResp *rmAipRespMsgPtr;
  I_U16   rmAipRespMsgSize;
  
  rmAipRespMsgSize  = sizeof(OamsTrxhmRmAipResp);
  rmAipRespMsgPtr   = (OamsTrxhmRmAipResp *) AlocMsgBuf(rmAipRespMsgSize);
  
  if (NULL == rmAipRespMsgPtr)
  {
      LOG_PRINT(CRITICAL,"(R.2.5.-ABIS HA) AlocMsgBuf() failed to Allocate the Buffer for OamsTrxhmRmAipResp");
      return; 
  }

  FILL_SYS_HDR(rmAipRespMsgPtr,msgOpCode,MSG_SUB_TYPE,PRCR_CP,ENT_OAMS_TRXH,ZERO,PRCR_CP, ENT_OAMS_RM,ZERO); 
  
  if (SendMsg(rmAipRespMsgPtr, MSG_ORD_PRIO, rmAipRespMsgSize) < ZERO)
  {
      LOG_PRINT(CRITICAL,"(R2.5.5-ABIS HA) SendMsg Failed for OamsTrxhmRmAipResp");
      return;
  }
  else
  {
     LOG_PRINT(DEBUG,"(R2.5.5-ABIS HA) OAMS_TRXHM_RM_AIP_RESP sent to RM Successfully.");
  }

}

void handleAipToActive(void)
{
    xSignalNode         S;
    I_U32 outCount                             =  ZERO;
    I_U16 outSize                              =  ZERO;
	  I_S32 result                               =  ZERO;
    TrxContextTableApi  *trxContextTablePtr    =  NULL;
    TrxContextTableApi  *tmpTrxContextTablePtr =  NULL;
    I_U32               idx                    = ZERO;
    I_U32               refId                  = ZERO;
	  I_U32               lclPidPtr              = ZERO ;
	  I_S32               instId                 = ZERO ;
	  InstMapTbl          *instMapTblPtr_i;
	  SDL_Pid             rcvr;
	  I_U16	              instCount              = ZERO;
    I_U8                actClsId = 0;

    rcvr.GlobalNodeNr = (I_S32)selfEntIdG;
    rcvr.LocalPId = (xLocalPIdNode)ZERO;

    
     if(I_TRUE == gIsTransitionViaStandBy)
     {
        /*
          Added for (R2.5 HA No LAPD Down)
          Dated: 06-Aug-2010
          
        */
        /* Resetting the global variable.*/
        LOG_PRINT(INFO,"(R2.5.5-ABIS HA) state transition is <STANDBY->ACTIVE_IN_PROGRESS->ACTIVE>");
        
        gIsTransitionViaStandBy = I_FALSE;
        
        result = getallTrxContextTable(&trxContextTablePtr,&outCount,&outSize);
        
        if(CLIB_SUCCESS != result)
        {
          LOG_PRINT(DEBUG,"(R2.5.5-ABIS HA) (handleAipToActive) There are no entries found in the TrxContextTable");
          //gCurrentCardState = CARDSTATE_ACTIVE;
          //gNewCardState = BSC_APP_CARDSTATE_INVALID;
          //LOG_PRINT(DEBUG,"(R2.5 HA No LAPD Down) Releasing semaphore... and moving into CARDSTATE_CARDSTATE_ACTIVE");
          //SEM_POST(&gSemHandler);
        }
        else
        {   
            for(idx = ZERO; idx < outCount; idx++)
            {
                tmpTrxContextTablePtr = (TrxContextTableApi*)((I_U8 *)(trxContextTablePtr) + (idx * outSize));
                refId  = tmpTrxContextTablePtr->ptrxId;

                actClsId = getActiveClassIdFromPtrxIdTei(refId,0);

                if (SearchAlocatedInst(&lclPidPtr,&instId,ENT_OAMS_TRXH,actClsId,refId,ZERO,ZERO,ZERO,ZERO) \
                             != INST_SUCCESS)
					      {
      				      LOG_PRINT(CRITICAL,"No TRXHM Ins found for PTRXID = [%d]",refId);
   				      }
                
   				      if ( ZERO == lclPidPtr )
   				      {
      				      LOG_PRINT(CRITICAL,"Invalid Instance Found...(lclPidPtr is NULL)");
   				      }
                else
                {
                    rcvr.LocalPId = (xLocalPIdNode)lclPidPtr;
                    S = xGetSignal( sig_OAMS_TRXHENV_TRXH_CARD_STATE_ACTIVE_VIA_STANDBY_IND, rcvr, xEnv);
                    SDL_Output( S xSigPrioPar(xDefaultPrioSignal), (xIdNode *)ZERO );
                }
            } /* End of For Loop*/
            if(NULL != trxContextTablePtr)
            {
               free(trxContextTablePtr);
            }
            
        } /* End of Else*/
     } /* End of IF*/
     else
     {
        LOG_PRINT(INFO,"(R2.5.5-ABIS HA) Value of gIsTransitionViaStandBy = %d",gIsTransitionViaStandBy);
     }
}



/**************************************************************************************************************************
*
* Dated: 09-Aug-2010
* Description:  This function release the mapping between Trxh and Tau Instance Id.
*
*
*
*
*
*
****************************************************************************************************************************
*/

void freeTauInstId(void)
{
    I_S32   result;
    I_U32 outCount  = ZERO;
  	I_U16 outSize   = ZERO;
	  I_U16 counter   = ZERO; 
    PtrxTableApi *pTrxTablePtr;
  	PtrxTableApi *toBeDeleted;
    I_U16  NoRowsFound;
	  I_U32  refId    = ZERO ;
  	I_U32 lclPidPtr = ZERO ;
	  I_S32 retVal    = ZERO;
  	I_S32 instId    = ZERO;
    PtrxTableIndices inData;
    I_U8  actClsId  = ZERO;
    I_S32 tei       = ZERO;
    


    result = getallPtrxTable(&pTrxTablePtr,&outCount,&outSize);
        
	  if( CLIB_SUCCESS != result )
	  {
    	  LOG_PRINT(DEBUG,"(R2.5 HA No LAPD Down) getallPtrxTable failed while moving from ACTIVE -> INSERVICE");
        NoRowsFound = checkDBErrorCode(result);
  	    if( ONE == NoRowsFound )
  		  {
     		    LOG_PRINT(INFO,"getAllPtrx : No entries found");
  		  }
 			  else
  		  {
     		    LOG_PRINT(MAJOR,"getallPtrxTable Failed err = %d",result);
  		  }
    }
    else
    {
          for(counter = ZERO; counter < outCount; counter++)
  		    {
   			      toBeDeleted = (PtrxTableApi*)((I_U8 *)(pTrxTablePtr) + (counter * outSize));
        			refId = toBeDeleted->ptrxId; 
			     		inData.ptrxId = refId; 

              actClsId = getActiveClassIdFromPtrxIdTei(inData.ptrxId,0);

				      if (SearchAlocatedInst(&lclPidPtr,&instId,ENT_OAMS_TRXH,actClsId,refId,ZERO,ZERO,ZERO,ZERO) \
                             != INST_SUCCESS)
				      {
      			      LOG_PRINT(CRITICAL,"No TRXHM Ins found for PTRXID = [%d]",refId);
   			      }
   			      if ( ZERO == lclPidPtr )
   			      {
      			      LOG_PRINT(CRITICAL,"Invalid Instance Found...(lclPidPtr is NULL)");
   			      }
				      else
				      {
					        if ((retVal = FreInstId(lclPidPtr, ENT_OAMS_TRXH,actClsId)) != INST_SUCCESS)
         			    {
             			    LOG_PRINT(CRITICAL, "xOutEnv : FreeInstId() Failed lclPidPtr= 0x%x [ActClsId= %d], [errCode =%d]",\
                      lclPidPtr, actClsId,retVal);
         			    }
         			    else
         			    {
             			    LOG_PRINT(DEBUG, "xOutEnv:FreeInstId() Success lclPidPtr= 0x%x [ActClsId= %d].Allocated Instance [%d]\
                      for PtrxId [%d] has been freed",lclPidPtr,actClsId,instId,refId);
         			    }
				      }
          } /* End of For Loop.*/
    } /* End of Else.*/
}





void cardStateChangeHandler(struct sAisParam *param)
{
   xSignalNode         S;
   I_S32 result        = ZERO;
	PtrxTableIndices inData;
	I_U32 outCount=0;
	I_U16 outSize;
	I_U16 counter;
	PtrxTableApi *pTrxTablePtr;
	PtrxTableApi *toBeDeleted;
	I_U16  NoRowsFound;
	I_U32  refId = 0 ;
	I_U32 lclPidPtr = 0 ;
	I_S32 retVal;
	I_S32 instId = 0 ;
	InstMapTbl *instMapTblPtr_i;
	SDL_Pid             rcvr;
	I_U16	instCount = 0;
  I_U8  actClassId = 0;
  
  /*
    Added for R2.5 (HA No LAPD Down)
    Dated: 05-Aug-2010

  */
  
  I_U32 myOutCount                           =  ZERO;
  I_U16 myOutSize                            =  ZERO;
	I_S32 myResult                            =  ZERO;
  TrxTableApi *trxTableApiPtr                =  NULL;
  TrxTableApi *tmpTrxTableApiPtr             =  NULL;
  TrxContextTableApi  *trxContextTablePtr    =  NULL;
  TrxContextTableApi  *tmpTrxContextTablePtr =  NULL;
  I_U32               idx   = ZERO;
  I_U32               HaNoLapdDownIndex = ZERO;
  I_S32               tei               = ZERO;

	rcvr.GlobalNodeNr = (I_S32)selfEntIdG;
	rcvr.LocalPId = (xLocalPIdNode)ZERO;
  
  /*
    Added for R2.5 (HA No LAPD Down)
    Dated:  05-Aug-2010

  */
	//I_U32 ptrxMaxList[60];

   if ( (param->cardState == CARDSTATE_IN_SERVICE) && (gCurrentCardState == CARDSTATE_INIT) )
   {
      LOG_PRINT(INFO,"STATE TRANSITION INIT -> INSERVICE");
      gNewCardState = CARDSTATE_IN_SERVICE;
      LOG_PRINT(DEBUG,"Registering with DB Server...");

      result = dbConnect();
      if ( result != DBLIB_SUCCESS )
      {
					  LOG_PRINT(CRITICAL,"TRXH: Unable to Register itself with DBServer:Exiting");
         exit(0);
      }
      LOG_PRINT(DEBUG,"Successfully Registered with DB Server.");

     if(gInstancesCreated == I_FALSE)
		 {	
	      LOG_PRINT(DEBUG,"(R2.5-HA No LAPD Down) TauInstances not yet instantiated. Instantiated by sending CRE_INSTS_REQ and Initializing the InstMapTable");
   	 	  InitInstMap(ENT_OAMS_TRXH,TRXH_HANDLER_TDM);
        result = GetInstCount(ENT_OAMS_TRXH,TRXH_HANDLER_TDM, &instCount);
      	if ( result != INST_SUCCESS )
      	{
         	LOG_PRINT(MAJOR,"[ENV] TDM GetInstCount Db call failed.. ");
         	return;
      	}
		 	  gInstCount = (instCount)*2;
        LOG_PRINT(DEBUG,"The value of TDM InstCount=[%d] and global is %d",instCount,gInstCount);

   	 	  InitInstMap(ENT_OAMS_TRXH,TRXH_HANDLER_IP);
        /*result = GetInstCount(ENT_OAMS_TRXH,TRXH_HANDLER_IP, &instCount);
      	if ( result != INST_SUCCESS )
      	{
         	LOG_PRINT(MAJOR,"[ENV] IP GetInstCount Db call failed.. ");
         	return;
      	}
		 	  gInstCount = instCount;*/
        LOG_PRINT(DEBUG,"The value of IP InstCount=[%d]",instCount);

		    S = xGetSignal( sig_CRE_INSTS_REQ, xNotDefPId, xEnv);
        SDL_Output( S xSigPrioPar(xDefaultPrioSignal), (xIdNode *)0 );
        gCurrentCardState = CARDSTATE_IN_SERVICE;
	   }
     else
     {
        LOG_PRINT(DEBUG,"(R2.5-HA No LAPD Down) TAU Instances [%d] already created & gInstancesCreated = [%d]",gInstCount, gInstancesCreated);
        gCurrentCardState = CARDSTATE_IN_SERVICE;
        gNewCardState = BSC_APP_CARDSTATE_INVALID;
        LOG_PRINT(INFO,"(R2.5 HA No LAPD Down) Releasing semaphore while moving to CARDSTATE=CARDSTATE_STANDBY");
        SEM_POST(&gSemHandler);
     }
     
   }
#if 0   
      gCurrentCardState = CARDSTATE_IN_SERVICE;
      gNewCardState = BSC_APP_CARDSTATE_INVALID;
      LOG_PRINT(INFO,"Releasing semaphore.. ");
      SEM_POST(&gSemHandler); 
#endif
   
   else if ( (param->cardState == CARDSTATE_STANDBY) && (gCurrentCardState == CARDSTATE_IN_SERVICE) )
   {
     LOG_PRINT(INFO,"STATE TRANSITION INSERVICE -> STANDBY");
     /*
       Added for R2.5 HA_NoLapdDown Feature.
       Dated: 2-Aug-2010
     */
#if 0
     if(gInstancesCreated == I_FALSE)
		 {	
	      LOG_PRINT(DEBUG,"(R2.5-HA No LAPD Down) TauInstances not yet instantiated. Instantiated by sending CRE_INSTS_REQ and Initializing the InstMapTable");
   	 	  InitInstMap(ENT_OAMS_TRXH,TRXHM_HANDLER);
        result = GetInstCount(ENT_OAMS_TRXH, TRXHM_HANDLER , &instCount);
      	if ( result != INST_SUCCESS )
      	{
         	LOG_PRINT(MAJOR,"[ENV] GetInstCount Db call failed.. ");
         	return;
      	}
		 	  gInstCount = instCount;
        LOG_PRINT(DEBUG,"(R2.5-HA No LAPD Down) The value of InstCount=[%d]",instCount);
		    S = xGetSignal( sig_CRE_INSTS_REQ, xNotDefPId, xEnv);
        SDL_Output( S xSigPrioPar(xDefaultPrioSignal), (xIdNode *)0 );
        gCurrentCardState = CARDSTATE_STANDBY;
	   }
     else
     {
        LOG_PRINT(DEBUG,"(R2.5-HA No LAPD Down) TAU Instances [%d] already created & gInstancesCreated = [%d]",gInstCount, gInstancesCreated);
        gCurrentCardState = CARDSTATE_STANDBY;
        gNewCardState = BSC_APP_CARDSTATE_INVALID;
        LOG_PRINT(INFO,"(R2.5 HA No LAPD Down) Releasing semaphore while moving to CARDSTATE=CARDSTATE_STANDBY");
        SEM_POST(&gSemHandler);
     }
#endif  
   
  
//    gNewCardState = CARDSTATE_IN_SERVICE;
    
      gCurrentCardState = CARDSTATE_STANDBY;
      gNewCardState = BSC_APP_CARDSTATE_INVALID;
      LOG_PRINT(INFO,"Releasing semaphore.. ");
      SEM_POST(&gSemHandler); 
   }  
   
   else if ( (param->cardState == CARDSTATE_ACTIVE_IN_PROGRESS) && (gCurrentCardState == CARDSTATE_IN_SERVICE) )
   {
      LOG_PRINT(INFO,"STATE TRANSITION INSERVICE -> ACTIVE_IN_PROGRESS");

      gCurrentCardState = CARDSTATE_ACTIVE_IN_PROGRESS;
      gNewCardState = BSC_APP_CARDSTATE_INVALID;
     	LOG_PRINT(INFO,"Releasing semaphore.. ");
      SEM_POST(&gSemHandler);
   }
   else if ( (param->cardState == CARDSTATE_ACTIVE) && (gCurrentCardState == CARDSTATE_ACTIVE_IN_PROGRESS) )
	 {
     LOG_PRINT(INFO,"STATE TRANSITION AIP -> ACTIVE");

#if 0
     if(gInstancesCreated == I_FALSE)
		 {
	     LOG_PRINT(INFO," No inst found :: send CRE_INSTS_REQ to Model & init InstMap");
   		 InitInstMap(ENT_OAMS_TRXH,TRXHM_HANDLER);
       result = GetInstCount(ENT_OAMS_TRXH, TRXHM_HANDLER , &instCount);
       if ( result != INST_SUCCESS )
       {
         	LOG_PRINT(MAJOR,"[ENV] GetInstCount Db call failed.. ");
         	return;
       }
			 gInstCount = instCount;
		   S = xGetSignal( sig_CRE_INSTS_REQ, xNotDefPId, xEnv);
       SDL_Output( S xSigPrioPar(xDefaultPrioSignal), (xIdNode *)ZERO );
       gCurrentCardState = CARDSTATE_ACTIVE;
		 }
     else
     {
       gCurrentCardState = CARDSTATE_ACTIVE;
       gNewCardState = BSC_APP_CARDSTATE_INVALID;
       LOG_PRINT(DEBUG,"(R2.5.5-ABIS HA) Releasing semaphore... and moving into CARDSTATE_CARDSTATE_ACTIVE");
       SEM_POST(&gSemHandler);
     }
#endif
     
      gCurrentCardState = CARDSTATE_ACTIVE;
      gNewCardState = BSC_APP_CARDSTATE_INVALID;
     	LOG_PRINT(INFO,"Releasing semaphore.. ");
      SEM_POST(&gSemHandler);
 }


#if 0
     else if(I_TRUE == gIsTransitionViaStandBy)
     {
        /*
          Added for (R2.5 HA No LAPD Down)
          Dated: 06-Aug-2010
          
        */
        /* Resetting the global variable.*/
        LOG_PRINT(INFO,"(R2.5.5 HA No LAPD Down) state transition is <STANDBY->ACTIVE_IN_PROGRESS->ACTIVE>");
        
        gIsTransitionViaStandBy = I_FALSE;
        
        result = getallTrxContextTable(&trxContextTablePtr,&outCount,&outSize);
        
        if(CLIB_SUCCESS != result)
        {
          LOG_PRINT(INFO,"(R2.5 HA No LAPD Down) There are no entries found in the TrxContextTable");
          gCurrentCardState = CARDSTATE_ACTIVE;
          gNewCardState = BSC_APP_CARDSTATE_INVALID;
          LOG_PRINT(DEBUG,"(R2.5 HA No LAPD Down) Releasing semaphore... and moving into CARDSTATE_CARDSTATE_ACTIVE");
          SEM_POST(&gSemHandler);
        }
        else
        {   
            for(idx = ZERO; idx < outCount; idx++)
            {
                tmpTrxContextTablePtr = (TrxContextTableApi*)((I_U8 *)(trxContextTablePtr) + (idx * outSize));
                refId  = tmpTrxContextTablePtr->ptrxId;

                if (SearchAlocatedInst(&lclPidPtr,&instId,ENT_OAMS_TRXH,TRXHM_HANDLER,refId,ZERO,ZERO,ZERO,ZERO) \
                             != INST_SUCCESS)
					      {
      				      LOG_PRINT(CRITICAL,"No TRXHM Ins found for PTRXID = [%d]",refId);
   				      }
                
   				      if ( ZERO == lclPidPtr )
   				      {
      				      LOG_PRINT(CRITICAL,"Invalid Instance Found...(lclPidPtr is NULL)");
   				      }
                else
                {
                    rcvr.LocalPId = (xLocalPIdNode)lclPidPtr;
                    S = xGetSignal( sig_OAMS_TRXHENV_TRXH_CARD_STATE_ACTIVE_VIA_STANDBY_IND, rcvr, xEnv);
                    SDL_Output( S xSigPrioPar(xDefaultPrioSignal), (xIdNode *)ZERO );
                }
            } /* End of For Loop*/
            if(NULL != trxContextTablePtr)
            {
               free(trxContextTablePtr);
            }
            gCurrentCardState = CARDSTATE_ACTIVE;
            gNewCardState = BSC_APP_CARDSTATE_INVALID;
            LOG_PRINT(DEBUG,"(R2.5 HA No LAPD Down) Release sem :: Moving into CARDSTATE_ACTIVE From AIP");
            SEM_POST(&gSemHandler);
        } /* End of Else*/
     } /* End of IF*/
     else
     {
        /* Comming from Active-In-Progress into Active from Inservice.*/
        LOG_PRINT(DEBUG,"(R2.5-HA No LAPD Down) [%d] inst are already created :: gInstancesCreated = [%d]",\
        gInstCount,gInstancesCreated);
        gCurrentCardState = CARDSTATE_ACTIVE;
        gNewCardState = BSC_APP_CARDSTATE_INVALID;
        LOG_PRINT(DEBUG,"(R2.5 HA No LAPD Down) Releasing sem while CARDSTATE_ACTIVE");
        SEM_POST(&gSemHandler);
     }
     #endif
   else if ( (param->cardState == CARDSTATE_IN_SERVICE) && (gCurrentCardState == CARDSTATE_ACTIVE) )
   {
        LOG_PRINT(INFO,"STATE TRANSITION ACTIVE -> INSERVICE");
       
        /*
            Added for (R2.5 ABIS-HA)
            Dated: 06-Aug-2010
            Description: Free the mapped TAU instances.
        */
       result = getallPtrxTable(&pTrxTablePtr,&outCount,&outSize);
		   if(result != CLIB_SUCCESS)
		   {
  			NoRowsFound = checkDBErrorCode(result);
  			if(NoRowsFound == 1)
  			{
     			LOG_PRINT(INFO,"getAllPtrx : No entries found");
          SEM_POST(&gSemHandler);
  			}
 			  else
  			{
     			LOG_PRINT(MAJOR,"getallPtrxTable Failed err = %d",result);
     			//return;
  			}
		  }
		  else
		  {
  		   for(gMsgsSent= (outCount - ONE), counter = ZERO; counter < outCount; counter++)
  		   {
   			   toBeDeleted = (PtrxTableApi*)((I_U8 *)(pTrxTablePtr) + counter*outSize);
   			   refId = toBeDeleted->ptrxId; //refId points to the pTrxId here
				   inData.ptrxId = refId; //inData ptrxTable
     			 LOG_PRINT(INFO,"PtrxId got from pTrxTable is :: %d ", refId);

           actClassId = getActiveClassIdFromPtrxIdTei(inData.ptrxId,0);

				   if (SearchAlocatedInst(&lclPidPtr,&instId,ENT_OAMS_TRXH,actClassId,refId,0,0,0,0) != INST_SUCCESS)
				   {
      		  	LOG_PRINT(CRITICAL,"No TRXHM Ins found for TRX = [%d]",refId);
      			  continue;
   			   }
   			   if (lclPidPtr == 0)
   			   {
      		  	LOG_PRINT(CRITICAL,"Invalid Inst Found...");
      			  continue;
   			   }
				   else
				   {
     			  	 LOG_PRINT(INFO,"Sending TRXH_INT_SELFCARD_STATE_CHANGE to Model for ptrx: %d, lclPid: %x ", refId, lclPidPtr);
					     rcvr.LocalPId = (xLocalPIdNode)lclPidPtr;
					     S = xGetSignal( sig_TRXH_INT_SELFCARD_STATE_CHANGE, rcvr, xEnv);
      			   (((yPDP_sig_TRXH_INT_SELFCARD_STATE_CHANGE)S)->Param1) = BSC_APP_CARDSTATE_ACTIVE;
      			   (((yPDP_sig_TRXH_INT_SELFCARD_STATE_CHANGE)S)->Param2) = CARDSTATE_IN_SERVICE;
      			   (((yPDP_sig_TRXH_INT_SELFCARD_STATE_CHANGE)S)->Param3) = refId;
      			   SDL_Output( S xSigPrioPar(xDefaultPrioSignal), (xIdNode *)ZERO );
					     gNewCardState = CARDSTATE_IN_SERVICE;
           }
			 } /*End of For Loop...*/
        free(pTrxTablePtr);
    }
    /*
    freeTauInstId();
    gCurrentCardState = CARDSTATE_IN_SERVICE;
    gNewCardState = BSC_APP_CARDSTATE_INVALID;
    LOG_PRINT(INFO,"Releasing semaphore.. ");
		SEM_POST(&gSemHandler);
    */
   }
   else if ( (param->cardState == CARDSTATE_ACTIVE_IN_PROGRESS) && (gCurrentCardState == CARDSTATE_STANDBY) )
   {
      LOG_PRINT(DEBUG,"STATE TRANSITION STANDBY -> ACTIVE_IN_PROGRESS"); 
      /*
        R2.5 HA No LAPD Down Feature
        Dated: 02-Aug-2010
      */
     
      /* 
        This flag is used to distinguish to Wait for ADD_TRX_REQ message from CFG or to trigger
        on its own.
      */
      gIsTransitionViaStandBy = I_TRUE;
      /*
      Read Operation(s) is(are) made only after DB is unlocked by RM successfully.
      Dated:21-Sep-2010
      */
      if(I_TRUE == gIsDbUnlockedByRm)
      {
         
         LOG_PRINT(DEBUG,"(R2.5.5-ABIS HA) DB Unlcoked Ind has been recvd from RM prior to BPM CallBack(SBY->AIP)");
         /*
         Semaphore has already been acquired and sending Signal to Model so that
         individual TRX instances are initialised from its context Table.
         */
         handleStandByToAip();
         /*Resetting the global variable*/
         gIsDbUnlockedByRm = I_FALSE;
         gIsBpmCallBackRcvd = I_FALSE;
      }
      else
      {
         LOG_PRINT(DEBUG,"(R2.5.5-ABIS HA)DB Unlocked Indication has not yet been recvd And BPM Callback(ABY->AIP) recvd");
         gIsBpmCallBackRcvd = I_TRUE;
      }
      
      /* refId points to the pTrxId */
      #if 0
      memset(&ptrxMaxList[ZERO],ZERO,(sizeof(I_U32) * 60));

      result    = getallTrxContextTable(&trxContextTablePtr,&outCount,&outSize);
      myResult  = getallTrxTable(&trxTableApiPtr, &myOutCount, &myOutSize);
      
      if((CLIB_SUCCESS != result) && (CLIB_SUCCESS != myResult))
      {
           LOG_PRINT(DEBUG,"No entries found in PtrxContxtTable or TrxTable");
           gCurrentCardState = CARDSTATE_ACTIVE_IN_PROGRESS;
           gNewCardState     = BSC_APP_CARDSTATE_INVALID;
           LOG_PRINT(INFO,"Releasing sem.. ");
	    	   SEM_POST(&gSemHandler);
      }
      else if(outCount == myOutCount)
      {
         LOG_PRINT(DEBUG,"PtrxStateContxtTable and TrxTable have same no. of TRX entries");
         for(HaNoLapdDownIndex  = ZERO, tmpTrxTableApiPtr = (I_PVoid)trxTableApiPtr; \
            HaNoLapdDownIndex < outCount; HaNoLapdDownIndex++)
         {
   			    tmpTrxContextTablePtr = (TrxContextTableApi*)((I_U8 *)(trxContextTablePtr) + \
                              (HaNoLapdDownIndex * outSize) );
            ptrxMaxList[tmpTrxContextTablePtr->ptrxId] = tmpTrxContextTablePtr->ptrxId;

            LOG_PRINT(DEBUG,"(R2.5 HA No LAPD Down) ptrxId fetched from ptrxContxtTable & store in ptrxMaxList[%d] =\
            [%d]",tmpTrxContextTablePtr->ptrxId,ptrxMaxList[tmpTrxContextTablePtr->ptrxId]);
         }
      }
      else if((myOutCount > outCount) || (myOutCount < outCount))
      {
          LOG_PRINT(DEBUG,"(R2.5 HA No LAPD Down) No. of TRX in PtrxContxtTable < TRXtable, Possibly Switchover\
          happened during TRX Add procedure");
          for(HaNoLapdDownIndex  = ZERO; HaNoLapdDownIndex < outCount; HaNoLapdDownIndex++)
          {
            tmpTrxContextTablePtr = (TrxContextTableApi*)((I_U8 *)(trxContextTablePtr) + \
                              (HaNoLapdDownIndex * outSize) );
            ptrxMaxList[tmpTrxContextTablePtr->ptrxId] = tmpTrxContextTablePtr->ptrxId;
            LOG_PRINT(DEBUG,"(R2.5 HA No LAPD Down) ptrxId fetched from ptrxContxtTable & store in ptrxMaxList[%d] = \
            [%d]",tmpTrxContextTablePtr->ptrxId,ptrxMaxList[tmpTrxContextTablePtr->ptrxId]);
          }
          for(HaNoLapdDownIndex  = ZERO, tmpTrxTableApiPtr = (I_PVoid)trxTableApiPtr; \
                    HaNoLapdDownIndex < myOutCount; HaNoLapdDownIndex++)
          {
              trxTableApiPtr = (TrxTableApi *)(((I_U8 *)(tmpTrxTableApiPtr)) + (HaNoLapdDownIndex * myOutSize));
              trxTableApiPtr->ptrxId;

              if(ZERO == ptrxMaxList[trxTableApiPtr->ptrxId])
              {
                 ptrxMaxList[trxTableApiPtr->ptrxId] = trxTableApiPtr->ptrxId;
                 LOG_PRINT(DEBUG,"(R2.5 HA No LAPD Down) ptrxId fetched from TrxTable & store in ptrxMaxList[%d] = \
                 [%d]",trxTableApiPtr->ptrxId,ptrxMaxList[trxTableApiPtr->ptrxId]);
              }
              else
              {
                 LOG_PRINT(DEBUG,"(R2.5 HA No LAPD Down) ptrxId is already stored in ptrxMaxList[%d] = \
                 [%d]",trxTableApiPtr->ptrxId,ptrxMaxList[trxTableApiPtr->ptrxId]);
              }
          }

      }
      else
      {
         LOG_PRINT(DEBUG,"(R2.5 HA No LAPD Down) UNEXPECTED: condition" );
      }

      if (NULL != tmpTrxTableApiPtr)
      {
         LOG_PRINT(DEBUG,"(R2.5.5-ABIS HA) tmpTrxTableApiPtr is being freed");
         free(tmpTrxTableApiPtr);
      }
      if (NULL != trxContextTablePtr)
      {
         LOG_PRINT(DEBUG,"(R2.5.5-ABIS HA) trxContextTablePtr is being freed");
         free(trxContextTablePtr);
      }
      /* 
        If atleast one entry is found then send it to Model otherwise update the 
        global variables and release the semaphore.
      */
      if(CARDSTATE_ACTIVE_IN_PROGRESS != gCurrentCardState)
      {
        for(HaNoLapdDownIndex=ZERO; HaNoLapdDownIndex < 60 /*To be replaced by Macro*/; HaNoLapdDownIndex++)
        {
            refId = ptrxMaxList[HaNoLapdDownIndex];
            if (ZERO == refId)
            {
               LOG_PRINT(DEBUG,"(R2.5 HA No LAPD Down) ptrxMaxList[%d]=%d",HaNoLapdDownIndex, \
               ptrxMaxList[HaNoLapdDownIndex]);
               continue;
            }
            
            /*   Allocating new instance for all replicated TRX.      */
            actClsId = getActiveClassIdFromPtrxIdTei(inData.ptrxId,0);
            if(0 == actClsId)
	          {
      	      return;
		        }

	          if (AlocNewInst(&lclPidPtr, &instId, ENT_OAMS_TRXH,
	                                    actClsId,refId,
	                            tei, ZERO, ZERO, ZERO)  != INST_SUCCESS)
	          {
	              LOG_PRINT(CRITICAL, "xInEnv : AlocNewInst() Failed for TRXH");
	              return;
	          }

			      LOG_PRINT(DEBUG,"(R2.5 HA No LAPD Down) Tau Inst [%d] mapped to PtrxId [%d] while transition \
            SBY->AIP",instId,refId);
        
   		      if (lclPidPtr == 0)
   		      {
       	        LOG_PRINT(CRITICAL,"Invalid Inst Found...");
      		      continue;
   		      }
			      else
			      {
     			  	  LOG_PRINT(INFO,"Sending TRXH_INT_SELFCARD_STATE_CHANGE to Model for ptrx: %d, lclPid: %x ", refId, lclPidPtr);
					      rcvr.LocalPId = (xLocalPIdNode)lclPidPtr;
					      S = xGetSignal( sig_TRXH_INT_SELFCARD_STATE_CHANGE, rcvr, xEnv);
      		      (((yPDP_sig_TRXH_INT_SELFCARD_STATE_CHANGE)S)->Param1) = BSC_APP_CARDSTATE_STANDBY;
          		  (((yPDP_sig_TRXH_INT_SELFCARD_STATE_CHANGE)S)->Param2) = BSC_APP_CARDSTATE_ACTIVE_IN_PROGRESS;
          		  (((yPDP_sig_TRXH_INT_SELFCARD_STATE_CHANGE)S)->Param3) = refId;
      	        SDL_Output( S xSigPrioPar(xDefaultPrioSignal), (xIdNode *)ZERO);
          
                gHaNoLapdDownStateChangeMsgSent++;
                gNewCardState = CARDSTATE_ACTIVE_IN_PROGRESS;
		        } /* End of else */
        } /* End of For Loop */
      }
      #endif
   }
   else if ( (param->cardState == CARDSTATE_RECOVERY) && (gCurrentCardState == CARDSTATE_STANDBY) )
   {
      LOG_PRINT(INFO,"STATE TRANSITION STANDBY -> RECOVERY");
      freeTauInstId(); 
      gCurrentCardState = CARDSTATE_RECOVERY;
      gNewCardState = BSC_APP_CARDSTATE_INVALID;
      LOG_PRINT(INFO,"Releasing semaphore.. ");
		  SEM_POST(&gSemHandler);
   }
   else if ( (param->cardState == CARDSTATE_RECOVERY) && (gCurrentCardState == CARDSTATE_ACTIVE) )
   {
		   LOG_PRINT(INFO,"STATE TRANSITION ACTIVE -> RECOVERY");
        /*
            Added for (R2.5.5 ABIS-HA)
            Dated: 13-Sep-2010
            Description: Bring all TRXH instances into IDLE Sate and then Free the TAU instances.
        */
       result = getallPtrxTable(&pTrxTablePtr,&outCount,&outSize);
		   if(result != CLIB_SUCCESS)
		   {
  			  NoRowsFound = checkDBErrorCode(result);
  			  if(NoRowsFound == 1)
  			  {
     			  LOG_PRINT(INFO,"getAllPtrx : No entries found");
            SEM_POST(&gSemHandler);
  			  }
 			    else
  			  {
     			  LOG_PRINT(MAJOR,"getallPtrxTable Failed err = %d",result);
     			  //return;
  			  }
		  }
		  else
		  {
  		   for(gMsgsSent= (outCount - ONE), counter = ZERO; counter < outCount; counter++)
  		   {
   			   toBeDeleted = (PtrxTableApi*)((I_U8 *)(pTrxTablePtr) + counter*outSize);
   			   refId = toBeDeleted->ptrxId; //refId points to the pTrxId here
				   inData.ptrxId = refId; //inData ptrxTable
     			 LOG_PRINT(INFO,"PtrxId got from pTrxTable is :: %d ", refId);
           
           actClassId = getActiveClassIdFromPtrxIdTei(inData.ptrxId,0);

				   if (SearchAlocatedInst(&lclPidPtr,&instId,ENT_OAMS_TRXH,actClassId,refId,0,0,0,0) != INST_SUCCESS)
				   {
      		  	LOG_PRINT(CRITICAL,"No TRXHM Ins found for TRX = [%d]",refId);
      			  continue;
   			   }
   			   if (lclPidPtr == 0)
   			   {
      		  	LOG_PRINT(CRITICAL,"Invalid Inst Found.");
      			  continue;
   			   }
				   else
				   {
     			  	 LOG_PRINT(INFO,"Sending TRXH_INT_SELFCARD_STATE_CHANGE to Model for ptrx: %d, lclPid: %x ", refId, lclPidPtr);
					     rcvr.LocalPId = (xLocalPIdNode)lclPidPtr;
					     S = xGetSignal( sig_TRXH_INT_SELFCARD_STATE_CHANGE, rcvr, xEnv);
      			   (((yPDP_sig_TRXH_INT_SELFCARD_STATE_CHANGE)S)->Param1) = BSC_APP_CARDSTATE_ACTIVE;
      			   (((yPDP_sig_TRXH_INT_SELFCARD_STATE_CHANGE)S)->Param2) = CARDSTATE_RECOVERY;
      			   (((yPDP_sig_TRXH_INT_SELFCARD_STATE_CHANGE)S)->Param3) = refId;
      			   SDL_Output( S xSigPrioPar(xDefaultPrioSignal), (xIdNode *)ZERO );
               gNewCardState = CARDSTATE_RECOVERY;
           }
			 } /*End of For Loop...*/
		   free(pTrxTablePtr);
     }
      /*
      freeTauInstId(); 
      gCurrentCardState = CARDSTATE_RECOVERY;
      gNewCardState = BSC_APP_CARDSTATE_INVALID;
      LOG_PRINT(INFO,"Releasing semaphore.. ");
		  SEM_POST(&gSemHandler);
      */
   }
   else if ( (param->cardState == CARDSTATE_IN_SERVICE) && (gCurrentCardState == CARDSTATE_RECOVERY) )
   {
      LOG_PRINT(INFO,"STATE TRANSITION RECOVERY -> INSERVICE");
      gCurrentCardState = CARDSTATE_IN_SERVICE;
      gNewCardState = BSC_APP_CARDSTATE_INVALID;
      LOG_PRINT(INFO,"Releasing semaphore.. ");
		SEM_POST(&gSemHandler);
  }
	else if ( (param->cardState == CARDSTATE_OUT_OF_SERVICE) && (gCurrentCardState == CARDSTATE_ACTIVE) )
   {
      LOG_PRINT(INFO,"STATE TRANSITION ACTIVE -> OUT_OF_SERVICE");
		  result = getallPtrxTable(&pTrxTablePtr,&outCount,&outSize);
		  if(result != CLIB_SUCCESS)
		  {
  			//free(pTrxTablePtr);  
  			NoRowsFound = checkDBErrorCode(result);
  			if(NoRowsFound == 1)
  			{
     			LOG_PRINT(INFO,"getAllPtrx : No entries found");
          SEM_POST(&gSemHandler);
  			}
 			  else
  			{
     			LOG_PRINT(MAJOR,"getallPtrxTable Failed err = %d",result);
     			//return;
  			}
		  }
		  else
		  {
        /* Mantis#:0010005, gMsgsSent has been moved into for loop */
  		   for(gMsgsSent= (outCount - ONE), counter = ZERO; counter < outCount; counter++)
  		   {
   			   //toBeDeleted = cast<CPtr<PtrxTableApi> >(cast<CPtr<I_U8> >(pTrxTablePtr) + (counter * outSize));
   			   toBeDeleted = (PtrxTableApi*)((I_U8 *)(pTrxTablePtr) + counter*outSize);
   			   refId = toBeDeleted->ptrxId; //refId points to the pTrxId here
				   inData.ptrxId = refId; //inData ptrxTable
     			 LOG_PRINT(INFO,"PtrxId got from pTrxTable is :: %d ", refId);

           actClassId = getActiveClassIdFromPtrxIdTei(inData.ptrxId,0);
           if(0 == actClassId)
	         {
      	     return;
		       }
				   if (SearchAlocatedInst(&lclPidPtr,&instId,ENT_OAMS_TRXH,actClassId,refId,0,0,0,0) != INST_SUCCESS)
				   {
      		  	LOG_PRINT(CRITICAL,"No TRXHM Ins found for TRX = [%d]",refId);
      			  continue;
   			   }
   			   if (lclPidPtr == 0)
   			   {
      		  	LOG_PRINT(CRITICAL,"Invalid Inst Found...");
      			  continue;
   			   }
				   else
				   {
     			  	 LOG_PRINT(INFO,"Sending TRXH_INT_SELFCARD_STATE_CHANGE to Model for ptrx: %d, lclPid: %x ", refId, lclPidPtr);
					     rcvr.LocalPId = (xLocalPIdNode)lclPidPtr;
					     S = xGetSignal( sig_TRXH_INT_SELFCARD_STATE_CHANGE, rcvr, xEnv);
      			   (((yPDP_sig_TRXH_INT_SELFCARD_STATE_CHANGE)S)->Param1) = BSC_APP_CARDSTATE_ACTIVE;
      			   (((yPDP_sig_TRXH_INT_SELFCARD_STATE_CHANGE)S)->Param2) = BSC_APP_CARDSTATE_OUT_OF_SERVICE;
      			   (((yPDP_sig_TRXH_INT_SELFCARD_STATE_CHANGE)S)->Param3) = refId;
      			   SDL_Output( S xSigPrioPar(xDefaultPrioSignal), (xIdNode *)0 );
            /* Commented for Mantis #: 0010005 (BSS Software Activation Failed...)
			  		gMsgsSent++;
            */
					     gNewCardState = CARDSTATE_OUT_OF_SERVICE;
				   }
			 } /*End of For Loop...*/
		   free(pTrxTablePtr);
    }
    
  }
	else if ( (param->cardState == CARDSTATE_OUT_OF_SERVICE) && (gCurrentCardState == CARDSTATE_STANDBY) )
   {
      LOG_PRINT(INFO,"STATE TRANSITION STANDBY -> OUT_OF_SERVICE");
      freeTauInstId(); 
      gCurrentCardState = CARDSTATE_OUT_OF_SERVICE;
      gNewCardState = BSC_APP_CARDSTATE_INVALID;
      LOG_PRINT(INFO,"Releasing semaphore.. ");
		SEM_POST(&gSemHandler);
   }
	else if ( (param->cardState == CARDSTATE_IN_SERVICE) && (gCurrentCardState == CARDSTATE_OUT_OF_SERVICE) )
   {
      LOG_PRINT(INFO,"STATE TRANSITION OUT_OF_SERVICE -> INSERVICE");
      
      gCurrentCardState = CARDSTATE_IN_SERVICE;
      gNewCardState = BSC_APP_CARDSTATE_INVALID;
      LOG_PRINT(INFO,"Releasing semaphore.. ");
		SEM_POST(&gSemHandler);
   }
   else if (param->cardState == CARDSTATE_PLATFORM_INS)
   {
       LOG_PRINT(INFO,"STATE TRANSITION to PLATFOMR_INS");

      gCurrentCardState = CARDSTATE_PLATFORM_INS;
      gNewCardState = BSC_APP_CARDSTATE_INVALID;
      LOG_PRINT(INFO,"Releasing semaphore.. ");
      SEM_POST(&gSemHandler);

   }
   else
   {
       LOG_PRINT(INFO,"Can't handle this STATE_CHANGE combination");
       /* Start Mantis #:0010005 (BSS Software Activation Failed...)*/
       LOG_PRINT(INFO,"Default Case Handling:");
		   LOG_PRINT(INFO,"calling bpmRespondToAis.. ");
		   bpmRespondToAis (param->invocation, OK);
		   LOG_PRINT(INFO,"Response sent to BPM.. ");
       SEM_POST(&gSemHandler);
       /* End Mantis #:0010005 (BSS Software Activation Failed...)*/
   }
}

  /**
  * Interface with Base Platform Module (BPM)
  * Note1: BPM is an optional feature in the system.
  * All code pertaining to BPM interface should be under a compile time
  * flag.
  */


void TrxhBpmCallbackFunc (struct sAisParam *param)
{
   
	switch (param->messageId)
   {
      case BPM_HEALTHCHECK_MESSAGE:
           bpmRespondToAis (param->invocation, OK);
           break;

      case BPM_SELFCARD_STATE_CHANGE:
				//HA-CS4.0 changes start
           //LOG_PRINT(INFO, "BPM_SELFCARD_STATE_CHANGE recd, No Action Taken");
				if( SEM_WAIT(&gSemHandler) !=0)
	            LOG_PRINT(DEBUG,"SEM_WAIT failed ");
	         LOG_PRINT(DEBUG,"xInEnv : BPM_SELFCARD_STATE_CHANGE received ");
	         cardStateChangeHandler(param);
	         LOG_PRINT(DEBUG,"WAITING FOR SEMAPHORE...");
	         if( SEM_TIMED_WAIT(&gSemHandler) != SEMAPHORE_WAIT_COMPLETE)
	         {
	            LOG_PRINT(INFO,"Got Sempahore.. ");
	            LOG_PRINT(INFO,"calling bpmRespondToAis.. ");
	            bpmRespondToAis (param->invocation, OK);
	            LOG_PRINT(INFO,"Response sent to BPM.. ");
	            LOG_PRINT(INFO,"Releasing Sempahore.. ");
	            SEM_POST(&gSemHandler);
	         }
	         else
	         {
	            LOG_PRINT(INFO,"SEMAPHORE Wait Timed Out(4 secs).. ");
	            LOG_PRINT(INFO,"Releasing semaphore.. ");
	            SEM_POST(&gSemHandler);
	         }


				//HA-CS4.0 changes end


           //bpmRespondToAis (param->invocation, OK);
           break;

      case BPM_PEERCARD_STATE_CHANGE:
           LOG_PRINT(INFO, "BPM_PEERCARD_STATE_CHANGE recd, No Action Taken");
           bpmRespondToAis (param->invocation, OK);
           break;

      case BPM_MSG_ACK_PEER_HEALTH_BAD:
           LOG_PRINT(INFO, "BPM_MSG_ACK_PEER_HEALTH_BAD recd, Not Expected");
           break;

      case BPM_MSG_ACK_CONFIGURE:
           LOG_PRINT(INFO, "BPM_MSG_ACK_CONFIGURE recd");
           break;

      case BPM_MSG_ACK_CONFIGURE_RESET:
           LOG_PRINT(INFO, "BPM_MSG_ACK_CONFIGURE_RESET recd, No Action Taken");
           break;

      case BPM_SHUTDOWN:
           LOG_PRINT(INFO, "BPM_SHUTDOWN recd, Exiting");
           exit (1);
           break;

      default:
           LOG_PRINT(MAJOR, "Unexpected msg from BPM: %d", param->messageId);
           break;
   }
}

#if BPM_PRESENT != 1

#define RegisterTrxhWithBpm() bpmGetComponentReg(ENT_OAMS_TRXH_STUB, &TrxhBpmCallbackFunc);
#warning "BPM support not compiled"
#define bpmRespondToAis(a,b) do{\
                               ;}while(0);


#else




void RegisterTrxhWithBpm(void) 
{
   bpmGetComponentRegister (TrxhBpmCallbackFunc, APPID_OAMS_TRXHM);
   bpmComponentConfigure ();
}
#endif /* BPM_PRESENT */




int checkDBErrorCode(I_S32 result)
{
	/*if(result == DBLIBERR_BASEDAO_NO_INDEX_ENTR ||
	result == DBLIBERR_BASEDAO_NO_INDEX_DEFINED ||
	result == DBLIBERR_PTOPAGE_HAS_NO_ROWS)*/
	
	if(result == DBLIBERR_BASEDAO_NO_INDEX_DEFINED ||
	result == DBLIBERR_PTOPAGE_HAS_NO_ROWS)
	{
		return 1;
	}
	else
	{
		return 0;
	}
}








    /* Logic for getting the TEI from the Incoming Message needs to be writen here.*/
I_U32 GetRefIdByTei(I_Void *rcvPtr)
{
   SysHdr              *sysHdr ;
   I_U16               msgType ;
   I_U32               refId = 0 ;
   sysHdr = (SysHdr *)rcvPtr ;
   msgType = sysHdr->msgType ;
   LOG_PRINT(INFO,"In Function GetRefIdByTei To Find RefId by Tei...");
   switch(msgType)
   {
       case CSAPP_ABIHM_TRXH_TRX_HELLO:
            refId = ((CsappAbihmTrxhTrxHello *)rcvPtr)->tei ;
            break ;

       case CSAPP_ABIHM_TRXH_OP_START_ACK:
            refId = ((CsappAbihmTrxhOpStartAck *)rcvPtr)->tei ;
            break ;

       case CSAPP_ABIHM_TRXH_OP_START_NACK:
            LOG_PRINT(INFO,"NACK CAUSE VALUE is %d",((CsappAbihmTrxhOpStartNack *)rcvPtr)->nackCause);
            refId = ((CsappAbihmTrxhOpStartNack *)rcvPtr)->tei ;
            break ;

       case CSAPP_ABIHM_TRXH_OP_STOP_ACK:
            refId = ((CsappAbihmTrxhOpStopAck *)rcvPtr)->tei ;
            break ; 
               
       case CSAPP_ABIHM_TRXH_OP_STOP_NACK:
            LOG_PRINT(INFO,"NACK CAUSE VALUE is %d",((CsappAbihmTrxhOpStopNack *)rcvPtr)->nackCause);
            refId = ((CsappAbihmTrxhOpStopNack *)rcvPtr)->tei ;
            break ;

       case CSAPP_ABIHM_TRXH_SET_BTS_ATTR_ACK:
            refId = ((CsappAbihmTrxhSetBtsAttrAck *)rcvPtr)->tei ;
            break ;

       case CSAPP_ABIHM_TRXH_SET_BTS_ATTR_NACK:
            refId = ((CsappAbihmTrxhSetBtsAttrNack *)rcvPtr)->tei ;
            LOG_PRINT(INFO,"NACK CAUSE VALUE is %d",((CsappAbihmTrxhSetBtsAttrNack *)rcvPtr)->nackCause);
            break ;

       case CSAPP_ABIHM_TRXH_SET_CHAN_ATTR_ACK:
            refId = ((CsappAbihmTrxhSetChanAttrAck *)rcvPtr)->tei ;
            break ;

       case CSAPP_ABIHM_TRXH_SET_CHAN_ATTR_NACK:
	    LOG_PRINT(INFO,"NACK CAUSE VALUE is %d",((CsappAbihmTrxhSetChanAttrNack *)rcvPtr)->nackCause);
            refId = ((CsappAbihmTrxhSetChanAttrNack *)rcvPtr)->tei ;
            break ;

       case CSAPP_ABIHM_TRXH_STATE_CHANGE_EVENT_REPORT:
            refId = ((CsappAbihmTrxhStateChangeEventReport *)rcvPtr)->tei ;
            break ;

       case CSAPP_ABIHM_TRXH_FAILURE_EVENT_REPORT:
            refId = ((CsappAbihmTrxhFailureEventReport *)rcvPtr)->tei ;
            break ;

       case CSAPP_ABIHM_TRXH_LAPD_LINK_UP:
            refId = ((CsappAbihmTrxhLapdLinkUp *)rcvPtr)->tei ;
            break ;

       case CSAPP_ABIHM_TRXH_LAPD_LINK_DOWN:
            refId = ((CsappAbihmTrxhLapdLinkDown *)rcvPtr)->tei ;
            break ;

       case CSAPP_ABIHM_TRXH_LINK_ESTAB_RESP:
            refId = ((CsappAbihmTrxhLinkEstabResp *)rcvPtr)->tei ;
            break ;

       case CSAPP_GRHM_TRXH_CRE_CHN_ACK :
            refId = ((CsappGrhmTrxhCreChanAck *)rcvPtr)->tei;
            break;

       case CSAPP_GRHM_TRXH_CRE_CHN_NACK :
	    LOG_PRINT(INFO,"NACK CAUSE VALUE is %d",((CsappGrhmTrxhCreChanNack *)rcvPtr)->cause);
            refId = ((CsappGrhmTrxhCreChanNack *)rcvPtr)->tei;
            break;

       case CSAPP_GRHM_TRXH_DEL_CHN_ACK :
            refId = ((CsappGrhmTrxhDelChanAck *)rcvPtr)->tei;
            break;
      /* Changes For ChannelActAck Retry Implementation : Start */
       case CSAPP_CPHM_TRXH_RETRY_EXHAUST_INDN :
            refId = ((CsappCphmTrxhRetryExhaustIndn*)rcvPtr)->tei;
            break;
       /* Changes For ChannelActAck Retry Implementation : End */

           /* R2.2 Changes : Starts */
       case CSAPP_ABIHM_TRXH_TM_HELLO :
            refId = ((CsappAbihmTrxhTmHello *)rcvPtr)->tei;
            break;

       case CSAPP_ABIHM_TRXH_TM_RESTART_ACK :
            refId = ((CsappAbihmTrxhTrxResetAck *)rcvPtr)->tei;
            break;
           /* R2.2 Changes : Ends */
       /* PCU R2.5 Changes : Starts  */
       case CSAPP_ABIHM_TRXH_SET_TRX_PS_ATTR_ACK:
            refId = ((CsappAbihmTrxhSetPsAttrAck *)rcvPtr)->tei ;
            break ;

       case CSAPP_ABIHM_TRXH_SET_TRX_PS_ATTR_NACK:
	    LOG_PRINT(INFO,"NACK CAUSE VALUE is %d",((CsappAbihmTrxhSetPsAttrNack *)rcvPtr)->nackCause);
            refId = ((CsappAbihmTrxhSetPsAttrNack *)rcvPtr)->tei ;
            break ;
       /* PCU R2.5 Changes : Ends  */
       /* R2.5.5 (ABIS HA No LAPD Down): Start
          Dated: 19-Aug-2010
       */
      case CSAPP_ABIHM_TRXH_LINK_STATUS_RESP:
            refId = ((CsappAbihmTrxhLinkStatusResp *)rcvPtr)->tei ;
            break ;
       
      /* R2.9 : Power Saving Feature - starts */
      case CSAPP_ABIHM_TRXH_BM_PWR_SAVING_CMD_ACK:
            refId = ((CsappAbihmTrxhBmPwrSavingCmdAck *)rcvPtr)->tei;
            break ;
      
      case CSAPP_ABIHM_TRXH_BM_PWR_SAVING_CMD_NACK:
            LOG_PRINT(INFO,"NACK CAUSE VALUE is %d",((CsappAbihmTrxhBmPwrSavingCmdNack *)rcvPtr)->nackCause);
            refId = ((CsappAbihmTrxhBmPwrSavingCmdNack *)rcvPtr)->tei;
            break ;
      /* R2.9 : Power Saving Feature - ends */
      
      default:
            refId = 0 ;
   }
   LOG_PRINT(INFO,"Returning From Function GetRefIdByTei...");
   return refId ;
}

     /* Logic for getting the TRXID from the Incoming Message needs to be writen here.*/

I_U32 GetRefIdByPtrxId(I_Void *rcvPtr)
{
   SysHdr          *sysHdr ;
   I_U16           msgType ;
   I_U32           refId = 0 ;

   LOG_PRINT(INFO,"In Function GetRefIdByPtrxId To Find RefId by Tei...");
   sysHdr = (SysHdr *)rcvPtr ;
   msgType = sysHdr->msgType ;
   switch(msgType)
   {
      case OAMS_CFG_TRXH_ADD_TRX_REQ:/*added in CS2.2*/
           refId = ((OamsCfgTrxhAddTrxReq *)rcvPtr)->ptrxId;
           break;


      case OAMS_CFG_TRXH_DEL_TRX_REQ:/*added in CS2.2*/
           refId = ((OamsCfgTrxhDelTrxReq *)rcvPtr)->ptrxId;
           break;

      case OAMS_MAPENT_TRXH_CRE_LTRX_PTRX_MAPPING_REQ:
           refId = ((OamsMapentTrxhCreLtrxPtrxMappingReq *)rcvPtr)->ptrxId;
           break;
      
      case OAMS_MAPENT_TRXH_DEL_LTRX_PTRX_MAPPING_REQ:
           refId = ((OamsMapentTrxhDelLtrxPtrxMappingReq *)rcvPtr)->ptrxId;
           break;

      case OAMS_CFG_TRXH_UNLOCK_REQ:
           refId = ((OamsCfgTrxhUnlockReq *)rcvPtr)->objId;
           break;
      
      case OAMS_CFG_TRXH_LOCK_REQ:
           refId = ((OamsCfgTrxhLockReq *)rcvPtr)->objId;
           break;
      /* R2.5.2 TRX BLOCK */
      case OAMS_CFG_TRXH_BLOCK_REQ:
           refId = ((OamsCfgTrxhBlockReq *)rcvPtr)->objId;
           break;
      /* R2.5.2 TRX BLOCK */

           /* R2.2 Changes : Starts */
      case OAMS_CFG_TRXH_TRX_RESET:
           refId = ((OamsCfgTrxhTrxReset *)rcvPtr)->objId;
           break;

      case OAMS_BICH_TRXH_LOCK_IND:
           refId = ((OamsBichTrxhLockInd *)rcvPtr)->ptrxId;
           break;

      case OAMS_BICH_TRXH_UNLOCK_IND:
           refId = ((OamsBichTrxhUnlockInd *)rcvPtr)->ptrxId;
           break;

      case OAMS_BICH_TRXH_LAPD_DISCONNECT_IND:
           refId = ((OamsBichTrxhLapdDiscInd *)rcvPtr)->ptrxId;
           break;
           /* R2.2 Changes : Ends */
      /* PCU R2.5 Changes : Starts  */
      case OAMS_BICH_TRXH_IP_LINK_DOWN:
           refId = ((OamsBichTrxhIpLinkDown *)rcvPtr)->ptrxId;
           break;

      case OAMS_BICH_TRXH_IP_LINK_UP:
           refId = ((OamsBichTrxhIpLinkUp *)rcvPtr)->ptrxId;
           break;

      case OAMS_PSCH_TRXH_PS_ATTR_CHANGE_IND:
           refId = ((OamsPschTrxhPsAttrChangeInd *)rcvPtr)->ptrxId;
           break;

      case OAMS_CELLH_TRXH_UPDATE_PS_CELL_ATTR:
           refId = ((OamsCellhTrxhUpdatePsCellAttr *)rcvPtr)->ptrxId;
           break;
      /* PCU R2.5 Changes : Ends  */

      default:
           refId = 0;
   }
   LOG_PRINT(INFO,"Returning From Function GetRefIdByPtrxId...");
   return refId ;
}


I_U32 FindTrxhLocalPidByPtrx(I_Void *rcvPtr)
{
   I_U32 lclPidPtr = 0 ;
   I_S32 instId = 0 ;
   I_U32 refId = 0 ;
   I_U8  actClsId = 0;

   refId = GetRefIdByPtrxId(rcvPtr) ; 
   actClsId = getActiveClassIdFromPtrxIdTei(refId,0);
   if (SearchAlocatedInst(&lclPidPtr,&instId,ENT_OAMS_TRXH,actClsId,refId,0,0,0,0) != INST_SUCCESS)
   {
      LOG_PRINT(CRITICAL,"No TRXHM Ins found for TRX = [%d]",refId);
      return 0;
   }
   if (lclPidPtr == 0)
   {
      LOG_PRINT(CRITICAL,"Invalid Inst Found...");
      return 0;
   }
   return lclPidPtr ;
}

/* R2.9 changes for handling PS clearing after switchover - starts*/
I_U32 FindTrxhLocalPidByTeiForSwitchover(I_Void *rcvPtr,I_U8 trxIndex)
{
  I_U32 lclPidPtr = 0 ;
  I_S32 instId = 0 ;
  I_U8  actClsId = 0;
  I_U32 refId = 0 ;
  refId = ((PsappPsmshTrxhBscSwitchoverInd *)rcvPtr)->trxPsRelStatus[trxIndex].trxAppTei;
  
  LOG_PRINT(INFO,"TRXH RefId for BSC Switchover Ind = [%d]",refId); //R2.9 changes
  /*Changes merged from R2.9 Issue #31185 Gaurav Sinha*/
  actClsId = getActiveClassIdFromPtrxIdTei(0,refId);

  if (SearchAlocatedInst(&lclPidPtr,&instId,ENT_OAMS_TRXH,actClsId,0,refId,0,0,0) != INST_SUCCESS)
  {
    LOG_PRINT(CRITICAL,"No TRXHM Ins found for TRX = [%d]",refId);
    return 0;
  }
  if (lclPidPtr == 0)
  {
    LOG_PRINT(CRITICAL,"Invalid Inst Found...");
    return 0;
  }
  return lclPidPtr ;
}
/* R2.9 changes for handling PS clearing after switchover - ends*/

I_U32 FindTrxhLocalPidByTei(I_Void *rcvPtr)
{
   I_U32 lclPidPtr = 0 ;
   I_S32 instId = 0 ;
   I_U32 refId = 0 ;
   I_U8  actClsId = 0;
   refId = GetRefIdByTei(rcvPtr) ;
   
   actClsId = getActiveClassIdFromPtrxIdTei(0,refId);

   if (SearchAlocatedInst(&lclPidPtr,&instId,ENT_OAMS_TRXH,actClsId,0,refId,0,0,0) != INST_SUCCESS)
   {
      LOG_PRINT(CRITICAL,"No TRXHM Ins found for TRX = [%d]",refId);
      return 0;
   }
   if (lclPidPtr == 0)
   {
      LOG_PRINT(CRITICAL,"Invalid Inst Found...");
      return 0;
   }
   return lclPidPtr ;
}





#ifndef XNOINITENV
/*---+---------------------------------------------------------------
     xInitEnv  extern
-------------------------------------------------------------------*/
#ifndef XENV_INIT
#define XENV_INIT
#endif

extern void xInitEnv(void)
{
  /* Code to initialize your SDL-system environment may be inserted here */

  /* Code to initialize your SDL-system environment may be inserted here */
   I_S32          result;
   selfEntIdG = (int)ENT_OAMS_TRXH;

#ifdef XTRACE
   xPrintString("xInitEnv called");
#endif

   //RegisterTrxhWithBpm(); //CLOUD
   if (RegisterWithIpcFrmwrk(selfEntIdG, (I_S8 *)"TRXH") < 0)
   {
      LOG_PRINT(CRITICAL,"Unable to Register itself with IPC FrameWork : Exiting");
      exit(0) ;
   }
   LOG_PRINT(INFO,"**Regn with IPC complete :: SystemName=%s, ModuleName=%s, Version=%s**",SYSTEM_NAME,SELF_ENTITY_NAME,VERSION);
   RegisterTrxhWithBpm();
   reg_sig_hndlr();
   SEM_INIT(&gSemHandler);
      LOG_PRINT(INFO, "SEM INIT SUCCESS with ptr :: %d",&gSemHandler)



   /*result = dbConnect();
   if (result != DBLIB_SUCCESS)
   {
      LOG_PRINT(CRITICAL,"TRXH: Unable to Register itself with DBServer:Exiting");
      exit(0);
   }
   LOG_PRINT(INFO,"Successfully Registered with DB Server.\n");*/
   /*retVal=SetInstCount(ENT_OAMS_TRXH,TRXHM_HANDLER,MAX_TRXHM_INST); */
   LOG_PRINT(CRITICAL,"TRXH Init Successful") ;
}
#endif


#ifndef XNOCLOSEENV
/*---+---------------------------------------------------------------
     xCloseEnv  extern
-------------------------------------------------------------------*/
#ifndef XENV_CLOSE
#define XENV_CLOSE
#endif

extern void xCloseEnv(void)
{
   I_S32 retVal;


  /* Need to delete the instance maps as well. Should use CleanInstMap () for this */
  /* DeRegister with DB */
   if ((retVal = dbDestroy()) != 0)
   {
      LOG_PRINT(CRITICAL,"clib_destroy failed for TRXH (Error = %d)",retVal);
      exit(0);
   }/*if retVal */
#ifdef XTRACE
   xPrintString("xCloseEnv called");
#endif

}
#endif


/*---+---------------------------------------------------------------
     Macros for xOutEnv
-------------------------------------------------------------------*/
#ifndef OUT_LOCAL_VARIABLES
#define OUT_LOCAL_VARIABLES
#endif

#ifndef IF_OUT_SIGNAL
#define IF_OUT_SIGNAL(SIGNAL_NAME, SIGNAL_NAME_STRING) \
  if (((*SignalOut)->NameNode) == SIGNAL_NAME) {
#define END_IF_OUT_SIGNAL(SIGNAL_NAME, SIGNAL_NAME_STRING) \
  }
#endif

#ifndef OUT_SIGNAL1
#define OUT_SIGNAL1(SIGNAL_NAME, SIGNAL_NAME_STRING)
#endif

#ifndef OUT_SIGNAL2
#define OUT_SIGNAL2(SIGNAL_NAME, SIGNAL_NAME_STRING)
#endif

#ifndef XENV_ENC
#define XENV_ENC(stmt) stmt
#endif

#ifndef XENV_OUT_START
#define XENV_OUT_START
#endif

#ifndef RELEASE_SIGNAL
#define RELEASE_SIGNAL   xReleaseSignal(SignalOut); return;
#endif


/*---+---------------------------------------------------------------
     xOutEnv  extern
-------------------------------------------------------------------*/
extern void xOutEnv( xSignalNode *SignalOut
#ifdef XPATH_INFO_IN_ENV_FUNC
  , xChannelIdNode Port
#endif
 )
{

   I_Void  *sndPtr;
   I_S32   msgSize;
   I_U32   lclPidPtr;
   I_S32   retVal;
   I_U8    actClsId = 0;
	static I_U8 	  recvdMsgs = 0;
  /*Added for BSC r2.0 (High Capacity BSC)*/
  /* Mantis#:9434 BSS Lock*/
  I_U32 selfPtrxId = 0;
  /*
    Added for R2.5 (HA No LAPD Down)
    Dated: 05-Aug-2010
  */
  I_U32 myParam1  = ZERO;

#ifdef XTRACE
   #ifdef XIDNAMES
      char  Temp[100];
      sprintf(Temp, "xOutEnv: %s received",(*SignalOut)->NameNode->Name );
      xPrintString(Temp);
      LOG_PRINT(INFO,"Signal No. Rcvd::[[%d]]:xOutEnv", (*SignalOut)->NameNode->SignalNumber);
   #else
      xPrintString("xOutEnv:One signal has been received by env");
   #endif
#endif

   switch((*SignalOut)->NameNode->SignalNumber)
   {
      /* Interfaces with CELLH */
      case SN_OAMS_TRXH_MAPENT_INITIATE_MAP:
           sndPtr = ((yPDP_sig_OAMS_TRXH_MAPENT_INITIATE_MAP)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_OAMS_TRXH_MAPENT_INITIATE_MAP)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
              LOG_PRINT(INFO,"Rcvd NULL Ptr from module,Returning without sending to FRM..SN_OAMS_TRXH_MAPENT_INITIATE_MAP") ;
              xReleaseSignal(SignalOut);
              return;
           }
           LOG_PRINT(INFO,"Send OAMS_TRXH_MAPENT_INITIATE_MAPP :: msgSize= %d msgType= 0x%x",msgSize , ((SysHdr *)sndPtr)->msgType);
           break;
  
      case SN_OAMS_TRXH_MAPENT_CRE_LTRX_PTRX_MAPPING_FAILED:
           sndPtr = ((yPDP_sig_OAMS_TRXH_MAPENT_CRE_LTRX_PTRX_MAPPING_FAILED)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_OAMS_TRXH_MAPENT_CRE_LTRX_PTRX_MAPPING_FAILED)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
              LOG_PRINT(INFO,"Rcvd NULL Ptr from module,Returning without sending to FRM..SN_OAMS_TRXH_MAPENT_CRE_LTRX_PTRX_MAPPING_FAILED") ;
              xReleaseSignal(SignalOut);
              return;
           }
           LOG_PRINT(INFO,"Send OAMS_TRXH_MAPENT_CRE_LTRX_PTRX_MAPPING_FAILED::msgSize= %d  msgType= 0x%x",
           msgSize , ((SysHdr *)sndPtr)->msgType);
           break;

      case SN_OAMS_TRXH_MAPENT_CRE_LTRX_PTRX_MAPPING_RESP:
           sndPtr = ((yPDP_sig_OAMS_TRXH_MAPENT_CRE_LTRX_PTRX_MAPPING_RESP)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_OAMS_TRXH_MAPENT_CRE_LTRX_PTRX_MAPPING_RESP)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
              LOG_PRINT(INFO,"Rcvd NULL Ptr from module,Returning without sending to FRM..") ;
              xReleaseSignal(SignalOut);
              return;
           }
           LOG_PRINT(INFO,"Send OAMS_TRXH_MAPENT_CRE_LTRX_PTRX_MAPPING_RESP::msgSize= %d  msgType= 0x%x",msgSize , ((SysHdr *)sndPtr)->msgType);
           break;

      case SN_OAMS_TRXH_MAPENT_DEL_LTRX_PTRX_MAPPING_RESP:
           sndPtr = ((yPDP_sig_OAMS_TRXH_MAPENT_DEL_LTRX_PTRX_MAPPING_RESP)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_OAMS_TRXH_MAPENT_DEL_LTRX_PTRX_MAPPING_RESP)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
              LOG_PRINT(INFO,"Rcvd NULL Ptr from module,Returning without sending to FRM..") ;
              xReleaseSignal(SignalOut);
              return;
           }
           LOG_PRINT(INFO,"Send OAMS_TRXH_MAPENT_DEL_LTRX_PTRX_MAPPING_RESP::msgSize= %d  msgType= 0x%x",msgSize , ((SysHdr *)sndPtr)->msgType);
           break;
 
      case SN_OAMS_TRXH_CELLH_BCCH_AVAIL:
           sndPtr = ((yPDP_sig_OAMS_TRXH_CELLH_BCCH_AVAIL)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_OAMS_TRXH_CELLH_BCCH_AVAIL)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
              LOG_PRINT(INFO,"Received NULL Pointer from module,Returning without sending to FRM..") ;
              xReleaseSignal(SignalOut);
              return;
           }
           LOG_PRINT(INFO,"Send OAMS_TRXH_CELLH_BCCH_AVAIL::msgSize= %d msgType= 0x%x",msgSize , ((SysHdr *)sndPtr)->msgType);
           break;
  
      case SN_OAMS_TRXH_CELLH_BCCH_UNAVAIL:
           sndPtr = ((yPDP_sig_OAMS_TRXH_CELLH_BCCH_UNAVAIL)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_OAMS_TRXH_CELLH_BCCH_UNAVAIL)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
              LOG_PRINT(INFO,"Received NULL Pointer from module,Returning without sending to FRM..") ;
              xReleaseSignal(SignalOut);
              return;
           }
           LOG_PRINT(INFO,"Send OAMS_TRXH_CELLH_BCCH_UNAVAIL::msgSize= %d msgType= 0x%x",msgSize , ((SysHdr *)sndPtr)->msgType);
           break;

      case SN_OAMS_TRXH_CELLH_SEND_SACCH_INFO:
           sndPtr = ((yPDP_sig_OAMS_TRXH_CELLH_SEND_SACCH_INFO)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_OAMS_TRXH_CELLH_SEND_SACCH_INFO)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
              LOG_PRINT(INFO,"Received NULL Pointer from module,Returning without sending to FRM..") ;
              xReleaseSignal(SignalOut);
              return;
           }
           LOG_PRINT(INFO,"Send OAMS_TRXH_CELLH_SEND_SACCH_INFO::msgSize= %d  msgType=0x%x",msgSize , ((SysHdr *)sndPtr)->msgType);
           break;
      
           /* Interface with CFG */
      
         /*added in CS2.2*/
      case SN_OAMS_TRXH_CFG_ADD_TRX_RESP:
           sndPtr = ((yPDP_sig_OAMS_TRXH_CFG_ADD_TRX_RESP)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_OAMS_TRXH_CFG_ADD_TRX_RESP)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
              LOG_PRINT(DEBUG,"Received NULL Pointer from module,Returning without sending to FRM..") ;
              xReleaseSignal(SignalOut);
              return;
           }
           LOG_PRINT(DEBUG,"Send OAMS_TRXH_CFG_ADD_TRX_RESP::msgSize= %d  msgTyp= 0x%x",msgSize , ((SysHdr *)sndPtr)->msgType);
           break;

      case SN_OAMS_TRXH_CFG_DEL_TRX_RESP:
           sndPtr = ((yPDP_sig_OAMS_TRXH_CFG_DEL_TRX_RESP)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_OAMS_TRXH_CFG_DEL_TRX_RESP)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
              LOG_PRINT(DEBUG,"Received NULL Pointer from module,Returning without sending to FRM..") ;
              xReleaseSignal(SignalOut);
              return;
           }
           LOG_PRINT(DEBUG," Send OAMS_TRXH_CFG_DEL_TRX_RESP::msgSize= %d msgTyp= 0x%x",msgSize , ((SysHdr *)sndPtr)->msgType);
           break;

      case SN_TRXH_INT_FREE_INST :
           actClsId =  ((yPDP_sig_TRXH_INT_FREE_INST)(*SignalOut))->Param1;
           lclPidPtr = (I_U32)((*SignalOut)->Sender.LocalPId);
      	   if ((retVal = FreInstId(lclPidPtr,ENT_OAMS_TRXH,actClsId)) != INST_SUCCESS)
           {
              LOG_PRINT(CRITICAL, "xOutEnv:FreeInstId Failed lclPidPtr= 0x%x [ActClsId= %d],[errCode =%d]",lclPidPtr, actClsId,retVal);
           }
           else
           {
              LOG_PRINT(DEBUG, "xOutEnv:FreeInstId Succ lclPidPtr= 0x%x [ActClsId= %d]",lclPidPtr, actClsId);
           }
           xReleaseSignal(SignalOut);
           return;
 
         /*added in CS2.2*/
      case SN_OAMS_TRXH_CFG_UNLOCK_RESP:
           sndPtr = ((yPDP_sig_OAMS_TRXH_CFG_UNLOCK_RESP)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_OAMS_TRXH_CFG_UNLOCK_RESP)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
              LOG_PRINT(INFO,"Received NULL Pointer from module,Returning without sending to FRM..") ;
              xReleaseSignal(SignalOut);
              return;
           }
           LOG_PRINT(INFO,"Send OAMS_TRXH_CFG_UNLOCK_RESP::msgSiz= %d msgTyp= 0x%x",msgSize , ((SysHdr *)sndPtr)->msgType);
           break;

      case SN_OAMS_TRXH_CFG_ALARM_IND:
           sndPtr = ((yPDP_sig_OAMS_TRXH_CFG_ALARM_IND)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_OAMS_TRXH_CFG_ALARM_IND)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
              LOG_PRINT(INFO,"Received NULL Pointer from module,Returning without sending to FRM..") ;
              xReleaseSignal(SignalOut);
              return;
           }
           LOG_PRINT(INFO,"Send OAMS_TRXH_CFG_ALARM_IND::msgSiz= %d  msgTyp= 0x%x",msgSize , ((SysHdr *)sndPtr)->msgType);
           break;

      case SN_OAMS_TRXH_CFG_LOCK_RESP:
           sndPtr = ((yPDP_sig_OAMS_TRXH_CFG_LOCK_RESP)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_OAMS_TRXH_CFG_LOCK_RESP)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
              LOG_PRINT(INFO,"Received NULL Pointer from module,Returning without sending to FRM..") ;
              xReleaseSignal(SignalOut);
              return;
           }
           LOG_PRINT(INFO,"Send OAMS_TRXH_CFG_LOCK_RESP::msgSiz= %d  msgTyp= 0x%x",msgSize , ((SysHdr *)sndPtr)->msgType);
           break;
         /* R2.5.2 TRX BLOCK */
      case SN_OAMS_TRXH_CFG_BLOCK_RESP:
           sndPtr = ((yPDP_sig_OAMS_TRXH_CFG_BLOCK_RESP)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_OAMS_TRXH_CFG_BLOCK_RESP)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
              LOG_PRINT(INFO,"Received NULL Pointer from module,Returning without sending to FRM..\n") ;
              xReleaseSignal(SignalOut);
              return;
           }
           LOG_PRINT(INFO," Send OAMS_TRXH_CFG_BLOCK_RESP :: msgSize = %d  msgType = 0x%x \n",msgSize ,\
           ((SysHdr *)sndPtr)->msgType);
           break;
      /* R2.5.2 TRX BLOCK */
      /* R2.2 Changes : Starts */

      case SN_OAMS_TRXH_CFG_TRX_RESET_ACK:
           sndPtr = ((yPDP_sig_OAMS_TRXH_CFG_TRX_RESET_ACK)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_OAMS_TRXH_CFG_TRX_RESET_ACK)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
              LOG_PRINT(INFO,"Received NULL Pointer from module,Returning without sending to FRM..") ;
              xReleaseSignal(SignalOut);
              return;
           }
           LOG_PRINT(INFO,"Send OAMS_TRXH_CFG_TRX_RESET_ACK::msgSiz= %d  msgTyp= 0x%x",msgSize , ((SysHdr *)sndPtr)->msgType);
           break;

      case SN_OAMS_TRXH_CFG_TRX_RESET_NACK:
           sndPtr = ((yPDP_sig_OAMS_TRXH_CFG_TRX_RESET_NACK)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_OAMS_TRXH_CFG_TRX_RESET_NACK)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
              LOG_PRINT(INFO,"Received NULL Pointer from module,Returning without sending to FRM..") ;
              xReleaseSignal(SignalOut);
              return;
           }
           LOG_PRINT(INFO,"Send OAMS_TRXH_CFG_TRX_RESET_NACK::msgSiz= %d  msgTyp= 0x%x",msgSize , ((SysHdr *)sndPtr)->msgType);
           break;

           /* R2.2 Changes : Ends   */

 

          /* Interface with GRHM */

      case SN_OAMS_TRXH_GRHM_CRE_CHN_REQ:
           sndPtr = ((yPDP_sig_OAMS_TRXH_GRHM_CRE_CHN_REQ)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_OAMS_TRXH_GRHM_CRE_CHN_REQ)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
              LOG_PRINT(INFO,"Received NULL Pointer from module,Returning without sending to FRM..") ;
              xReleaseSignal(SignalOut);
              return;
           }
           LOG_PRINT(INFO,"Send OAMS_TRXH_GRHM_CRE_CHN_REQ::msgSiz= %d  msgTyp= 0x%x",msgSize , ((SysHdr *)sndPtr)->msgType);
           break;

      case SN_OAMS_TRXH_GRHM_DEL_CHN_REQ:
           sndPtr = ((yPDP_sig_OAMS_TRXH_GRHM_DEL_CHN_REQ)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_OAMS_TRXH_GRHM_DEL_CHN_REQ)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
              LOG_PRINT(INFO,"Received NULL Pointer from module,Returning without sending to FRM..") ;
              xReleaseSignal(SignalOut);
              return;
           }
           LOG_PRINT(INFO,"Send OAMS_TRXH_GRHM_DEL_CHN_REQ::msgSiz= %d  msgTyp= 0x%x",msgSize , ((SysHdr *)sndPtr)->msgType);
           break;

          /* Interface with ABIHM */

     /* PCU R2.5 Changes : Starts  */
     case SN_OAMS_TRXH_GRHM_TRS_IND:
          sndPtr = ((yPDP_sig_OAMS_TRXH_GRHM_TRS_IND)(*SignalOut))->Param1;
          msgSize = ((yPDP_sig_OAMS_TRXH_GRHM_TRS_IND)(*SignalOut))->Param2;
          if (sndPtr == NULL)
          {
               LOG_PRINT(INFO,"Received NULL Pointer from module,Returning without sending to FRM..") ;
               xReleaseSignal(SignalOut);
               return;
          }
         LOG_PRINT(INFO,"Send OAMS_TRXH_GRHM_TRS_IND::msgSiz= %d  msgTyp= 0x%x",msgSize , ((SysHdr *)sndPtr)->msgType);
         break;
     /* PCU R2.5 Changes : End  */


         /* R2.2 Changes : Starts  */
      case SN_OAMS_TRXH_ABIHM_TM_RESTART:
           sndPtr = ((yPDP_sig_OAMS_TRXH_ABIHM_TM_RESTART)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_OAMS_TRXH_ABIHM_TM_RESTART)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
              LOG_PRINT(INFO,"Received NULL Pointer from module,Returning without sending to FRM..") ;
              xReleaseSignal(SignalOut);
              return;
           }
           LOG_PRINT(INFO,"Send OAMS_TRXH_ABIHM_TM_RESTART::msgSiz= %d  msgTyp= 0x%x",msgSize , ((SysHdr *)sndPtr)->msgType);
           break;
         /* R2.2 Changes : Ends   */

 

      case SN_OAMS_TRXH_ABIHM_OP_STOP_REQ:
           sndPtr = ((yPDP_sig_OAMS_TRXH_ABIHM_OP_STOP_REQ)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_OAMS_TRXH_ABIHM_OP_STOP_REQ)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
              LOG_PRINT(INFO,"Received NULL Pointer from module,Returning without sending to FRM..") ;
              xReleaseSignal(SignalOut);
              return;
           }
           LOG_PRINT(INFO,"Send OAMS_TRXH_ABIHM_OP_STOP_REQ::msgSiz= %d  msgTyp= 0x%x",msgSize , ((SysHdr *)sndPtr)->msgType);
           break;
  
      case SN_OAMS_TRXH_ABIHM_SET_BTS_ATTR_REQ:
           sndPtr = ((yPDP_sig_OAMS_TRXH_ABIHM_SET_BTS_ATTR_REQ)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_OAMS_TRXH_ABIHM_SET_BTS_ATTR_REQ)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
              LOG_PRINT(INFO,"Received NULL Pointer from module,Returning without sending to FRM..") ;
              xReleaseSignal(SignalOut);
              return;
           }
           LOG_PRINT(INFO,"Send OAMS_TRXH_ABIHM_SET_BTS_ATTR_REQ::msgSiz= %d  msgTyp= 0x%x",msgSize , ((SysHdr *)sndPtr)->msgType);
           break;

      /* PCU R2.5 Changes : Starts  */
      case SN_OAMS_TRXH_ABIHM_SET_TRX_PS_ATTR:
           sndPtr = ((yPDP_sig_OAMS_TRXH_ABIHM_SET_TRX_PS_ATTR)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_OAMS_TRXH_ABIHM_SET_TRX_PS_ATTR)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
                LOG_PRINT(INFO,"Received NULL Pointer from module,Returning without sending to FRM..") ;
                xReleaseSignal(SignalOut);
                return;
           }
           LOG_PRINT(INFO,"Send OAMS_TRXH_ABIHM_SET_TRX_PS_ATTR::msgSiz= %d  msgTyp= 0x%x",msgSize , ((SysHdr *)sndPtr)->msgType);
           break;
      /* PCU R2.5 Changes : End  */



      case SN_OAMS_TRXH_ABIHM_SET_CHAN_ATTR_REQ:
           sndPtr = ((yPDP_sig_OAMS_TRXH_ABIHM_SET_CHAN_ATTR_REQ)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_OAMS_TRXH_ABIHM_SET_CHAN_ATTR_REQ)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
              LOG_PRINT(INFO,"Received NULL Pointer from module,Returning without sending to FRM..") ;
              xReleaseSignal(SignalOut);
              return;
           }
           LOG_PRINT(INFO,"Send OAMS_TRXH_ABIHM_SET_CHAN_ATTR_REQ::msgSiz= %d  msgTyp= 0x%x",msgSize , ((SysHdr *)sndPtr)->msgType);
           break;

      case SN_OAMS_TRXH_ABIHM_OP_START_REQ:
           sndPtr = ((yPDP_sig_OAMS_TRXH_ABIHM_OP_START_REQ)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_OAMS_TRXH_ABIHM_OP_START_REQ)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
              LOG_PRINT(INFO,"Received NULL Pointer from module,Returning without sending to FRM..") ;
              xReleaseSignal(SignalOut);
              return;
           }
           LOG_PRINT(INFO,"Send OAMS_TRXH_ABIHM_OP_START_REQ::msgSiz= %d  msgTyp= 0x%x",msgSize , ((SysHdr *)sndPtr)->msgType);
           break;
      case SN_OAMS_TRXH_ABIHM_LINK_ESTAB_REQ:
           sndPtr = ((yPDP_sig_OAMS_TRXH_ABIHM_LINK_ESTAB_REQ)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_OAMS_TRXH_ABIHM_LINK_ESTAB_REQ)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
              LOG_PRINT(INFO,"Received NULL Pointer from module,Returning without sending to FRM..") ;
              xReleaseSignal(SignalOut);
              return;
           }
           LOG_PRINT(INFO,"Send OAMS_TRXH_ABIHM_LINK_ESTAB_REQ::msgSiz= %d  msgTyp= 0x%x",msgSize , ((SysHdr *)sndPtr)->msgType);
           break;

          /* Interface with PCU */

      case SN_OAMS_TRXH_PCU_PDCH_AVAIL:
           sndPtr = ((yPDP_sig_OAMS_TRXH_PCU_PDCH_AVAIL)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_OAMS_TRXH_PCU_PDCH_AVAIL)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
              LOG_PRINT(INFO,"Received NULL Pointer from module,Returning without sending to FRM..") ;
              xReleaseSignal(SignalOut);
              return;
           }
           LOG_PRINT(INFO,"Send OAMS_TRXH_PCU_PDCH_AVAIL::msgSiz= %d  msgTyp= 0x%x",msgSize , ((SysHdr *)sndPtr)->msgType);
           break;
  
      case SN_OAMS_TRXH_PSSCM_TRX_AVAIL:
           sndPtr = ((yPDP_sig_OAMS_TRXH_PSSCM_TRX_AVAIL)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_OAMS_TRXH_PSSCM_TRX_AVAIL)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
              LOG_PRINT(INFO,"Received NULL Pointer from module,Returning without sending to FRM..") ;
              xReleaseSignal(SignalOut);
              return;
           }
           LOG_PRINT(INFO,"Send OAMS_TRXH_PSSCM_TRX_AVAIL::msgSiz= %d  msgTyp= 0x%x",msgSize , ((SysHdr *)sndPtr)->msgType);
           break;

      case SN_OAMS_ADD_TAU_INST_IN_INSTMAP :
	   /*Change in CS2.2*/
           actClsId =  ((yPDP_sig_OAMS_ADD_TAU_INST_IN_INSTMAP)(*SignalOut))->Param1;
           lclPidPtr = (I_U32)((*SignalOut)->Sender.LocalPId);
           if ((retVal = AddTauInst(lclPidPtr,ENT_OAMS_TRXH,actClsId)) != INST_SUCCESS)
           {
              LOG_PRINT(CRITICAL,"xOutEnv:AddTauInstId Failed lclPid= 0x%x, [ActClsId= %d], [errCode= %d]",\
              (I_U32)lclPidPtr,actClsId ,retVal);
           }
           else
           {
               LOG_PRINT(DEBUG,"xOutEnv :AddTauInstId Success lclPid= 0x%x,[ActClsId= %d]",(I_U32)lclPidPtr, actClsId);
           }
				   recvdMsgs++;
           LOG_PRINT(INFO,"Here recvDMsgs are:: %d and gInstCount is :: %d", recvdMsgs, gInstCount);
				   
           if( recvdMsgs == gInstCount && gInstancesCreated == I_FALSE)
           {
					     if (CARDSTATE_STANDBY == gCurrentCardState)
               {
                  LOG_PRINT(DEBUG,"(R2.5 HA No LAPD Down) TRXH Instances are instantiated and Moving into STANDBY...");
               }
               else
               {
                  gCurrentCardState = CARDSTATE_IN_SERVICE;
                  LOG_PRINT(INFO,"Moving into INSERVICE...");
                  
               }
               gNewCardState = BSC_APP_CARDSTATE_INVALID;
               gInstancesCreated = I_TRUE;
               LOG_PRINT(INFO,"CurrentCardState = %d and NewCardState=%d", gCurrentCardState,gNewCardState) ;
               /*bpmRespondToAis (gInvocation, OK);*/
					     SEM_POST(&gSemHandler);
           		 LOG_PRINT(INFO,"Releasing sem..");
					     recvdMsgs = 0;
					     gInstCount = 0;
				   }

           xReleaseSignal(SignalOut);
           return;
           /*Change in CS2.2*/
          // CS4.0 HA changes 
					

	   /*Changes for CS3.0*/ 
      case SN_OAMS_TRXH_SWMH_TRX_HELLO:
           sndPtr = ((yPDP_sig_OAMS_TRXH_SWMH_TRX_HELLO)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_OAMS_TRXH_SWMH_TRX_HELLO)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
              LOG_PRINT(INFO,"Received NULL Pointer from module,Returning without sending to FRM..") ;
              xReleaseSignal(SignalOut);
              return;
           }
           LOG_PRINT(INFO,"Send OAMS_TRXH_SWMH_TRX_HELLO::msgSiz= %d msgTyp= 0x%x",msgSize , ((SysHdr *)sndPtr)->msgType);
           break;

      case SN_OAMS_TRXH_SWMH_LAPD_LINK_UP:
           sndPtr = ((yPDP_sig_OAMS_TRXH_SWMH_LAPD_LINK_UP)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_OAMS_TRXH_SWMH_LAPD_LINK_UP)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
              LOG_PRINT(INFO,"Received NULL Pointer from module,Returning without sending to FRM..") ;
              xReleaseSignal(SignalOut);
              return;
           }
           LOG_PRINT(INFO,"Send OAMS_TRXH_SWMH_LAPD_LINK_UP::msgSiz= %d msgTyp= 0x%x",msgSize , ((SysHdr *)sndPtr)->msgType);
           break;

      case SN_OAMS_TRXH_SWMH_LAPD_LINK_DOWN:
           sndPtr = ((yPDP_sig_OAMS_TRXH_SWMH_LAPD_LINK_DOWN)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_OAMS_TRXH_SWMH_LAPD_LINK_DOWN)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
              LOG_PRINT(INFO,"Received NULL Pointer from module,Returning without sending to FRM..") ;
              xReleaseSignal(SignalOut);
              return;
           }
           LOG_PRINT(INFO,"Send OAMS_TRXH_SWMH_LAPD_LINK_DOWN::msgSiz= %d msgTyp= 0x%x",msgSize , ((SysHdr *)sndPtr)->msgType);
           break;

			  //BSC-4.0 HA
	case SN_TRXH_INT_SELFCARD_STATE_CHANGE_RESP:
        myParam1 = ((yPDP_sig_TRXH_INT_SELFCARD_STATE_CHANGE_RESP)(*SignalOut))->Param1;
				LOG_PRINT(INFO,"xOutEnv: TRXH_INT_SELFCARD_STATE_CHANGE_RESP Rcvd with myParam1=%d & gMsgSent before decrement= %d",myParam1,gMsgsSent);
        
        /*
          Added for R2.5 (HA No LAPD Down)
          Dated: 05-Aug-2010
        */
        if (ONE == myParam1)
        {
           LOG_PRINT(DEBUG,"(R2.5-ABIS HA) value of gHaNoLapdDownStateChangeMsgSent=%d" ,\
           gHaNoLapdDownStateChangeMsgSent);
           
           if(ONE == gHaNoLapdDownStateChangeMsgSent)
           {
              gCurrentCardState = gNewCardState;
  		  			gNewCardState = BSC_APP_CARDSTATE_INVALID;
              /*
              Before Releasing Semaphore while SBY->AIP,
              OAMS_TRHM_RM_AIP_RESP to be sent to RM.
              */
              buildNSendRmAipResp(OAMS_TRXHM_RM_AIP_RESP);
              LOG_PRINT(INFO,"Releasing sem..");
		  		  	SEM_POST(&gSemHandler);
              gHaNoLapdDownStateChangeMsgSent = ZERO;
           }
           else
           {
              gHaNoLapdDownStateChangeMsgSent--;
           }
        }
        else
        {
           
				  if(ZERO == gMsgsSent)
  				{
	  				gCurrentCardState = gNewCardState;
		  			gNewCardState = BSC_APP_CARDSTATE_INVALID;
            LOG_PRINT(INFO,"Releasing sem..");
            freeTauInstId();
				  	SEM_POST(&gSemHandler);
					/* Not required...
          recvdMsgs = 0;
					gMsgsSent = 0;
          */
				  }
          else
          {
             gMsgsSent--;
             LOG_PRINT(INFO,"value of gMsgsSent after decrement is =%d",gMsgsSent);
          }
        }
        xReleaseSignal(SignalOut);
        return;

           /*Changes for CS3.0*/ 
	   /* Default */
	/*Mantis #: 0007309(If RSL Link is lost with a TRX then OML link should also be released). */
      case SN_OAMS_TRXH_ABIHM_LINK_DISC_REQ:
           sndPtr = ((yPDP_sig_OAMS_TRXH_ABIHM_LINK_DISC_REQ)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_OAMS_TRXH_ABIHM_LINK_DISC_REQ)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
              LOG_PRINT(INFO,"Received NULL Pointer from module,Returning without sending to FRM..") ;
              xReleaseSignal(SignalOut);
              return;
           }
           LOG_PRINT(INFO,"Send OAMS_TRXH_ABIHM_LINK_DISC_REQ::msgSiz= %d msgTyp= 0x%x", msgSize , ((SysHdr *)sndPtr)->msgType);
           break;

         /* R2.2 Changes : Starts */
      case SN_OAMS_TRXH_BICH_OPER_STATE_CHANGE_IND:
           sndPtr = ((yPDP_sig_OAMS_TRXH_BICH_OPER_STATE_CHANGE_IND)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_OAMS_TRXH_BICH_OPER_STATE_CHANGE_IND)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
              LOG_PRINT(INFO,"Received NULL Pointer from module,Returning without sending to FRM..") ;
              xReleaseSignal(SignalOut);
              return;
           }
           LOG_PRINT(INFO,"Send OAMS_TRXH_BICH_OPER_STATE_CHANGE_IND::msgSiz= %d  msgTyp= 0x%x ", msgSize , ((SysHdr *)sndPtr)->msgType);
           break;

         /* R2.2 Changes : Ends   */
       case SN_OAMS_TRXH_ABIHM_BIC_PWR_ORDER_REQ:
           sndPtr = ((yPDP_sig_OAMS_TRXH_ABIHM_BIC_PWR_ORDER_REQ)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_OAMS_TRXH_ABIHM_BIC_PWR_ORDER_REQ)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
              LOG_PRINT(INFO,"Received NULL Pointer from module,Returning without sending to FRM..") ;
              xReleaseSignal(SignalOut);
              return;
           }
           LOG_PRINT(INFO,"Send OAMS_TRXH_ABIHM_BIC_PWR_ORDER_REQ::msgSiz= %d msgTyp= 0x%x",msgSize , ((SysHdr *)sndPtr)->msgType);
           break;
      /* PCU R2.5 Changes : Starts */
      /* Interface with PSCH */
      case SN_OAMS_TRXH_PSCH_PS_ALLOWED:
           sndPtr = ((yPDP_sig_OAMS_TRXH_PSCH_PS_ALLOWED)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_OAMS_TRXH_PSCH_PS_ALLOWED)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
               LOG_PRINT(INFO,"Received NULL Pointer from module,Returning without sending to FRM..") ;
               xReleaseSignal(SignalOut);
               return;
           }
           LOG_PRINT(INFO,"Send OAMS_TRXH_PSCH_PS_ALLOWED::msgSiz= %d  msgTyp= 0x%x",msgSize , ((SysHdr *)sndPtr)->msgType);
           break;

      case SN_OAMS_TRXH_PSCH_PS_NOT_ALLOWED:
           sndPtr = ((yPDP_sig_OAMS_TRXH_PSCH_PS_NOT_ALLOWED)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_OAMS_TRXH_PSCH_PS_NOT_ALLOWED)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
               LOG_PRINT(INFO,"Received NULL Pointer from module,Returning without sending to FRM..") ;
               xReleaseSignal(SignalOut);
               return;
           }
           LOG_PRINT(INFO,"Send OAMS_TRXH_PSCH_PS_NOT_ALLOWED::msgSiz= %d  msgTyp= 0x%x",msgSize , ((SysHdr *)sndPtr)->msgType);
           break;
       /* Interface with TB */
      case SN_OAMS_TRXH_TB_ADD_BTS_TEI_MAPPING:
           sndPtr = ((yPDP_sig_OAMS_TRXH_TB_ADD_BTS_TEI_MAPPING)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_OAMS_TRXH_TB_ADD_BTS_TEI_MAPPING)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
                LOG_PRINT(INFO,"Received NULL Pointer from module,Returning without sending to FRM..") ;
                xReleaseSignal(SignalOut);
                return;
           }
           LOG_PRINT(INFO,"Send OAMS_TRXH_TB_ADD_BTS_TEI_MAPPING::msgSiz= %d msgTyp= 0x%x", msgSize , ((SysHdr *)sndPtr)->msgType);
           break;
															       
      case SN_OAMS_TRXH_TB_DEL_BTS_TEI_MAPPING:
           sndPtr = ((yPDP_sig_OAMS_TRXH_TB_DEL_BTS_TEI_MAPPING)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_OAMS_TRXH_TB_DEL_BTS_TEI_MAPPING)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
               LOG_PRINT(INFO,"Received NULL Pointer from module,Returning without sending to FRM..") ;
               xReleaseSignal(SignalOut);
               return;
           }
           LOG_PRINT(INFO,"Send OAMS_TRXH_TB_DEL_BTS_TEI_MAPPING::msgSiz= %d msgTyp= 0x%x",msgSize , ((SysHdr *)sndPtr)->msgType);
           break;
   /*R2.8 Added for Trx config issues*/   
      case SN_OAMS_TRXH_TB_READY_STATE_IND:
           sndPtr = ((yPDP_sig_OAMS_TRXH_TB_READY_STATE_IND)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_OAMS_TRXH_TB_READY_STATE_IND)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
                LOG_PRINT(INFO,"Received NULL Pointer from module,Returning without sending to FRM..") ;
                xReleaseSignal(SignalOut);
                return;
           }
           LOG_PRINT(INFO,"Send OAMS_TRXH_TB_READY_STATE_IND::msgSiz= %d msgTyp= 0x%x", msgSize , ((SysHdr *)sndPtr)->msgType);
           break;
															       
       /* PCU R2.5 Changes : End */
       /* R2.5.5 (ABIS HA No LAPD Down) : Start*/
      case SN_OAMS_TRXH_CELLH_OPR_STATE_IND:
           sndPtr = ((yPDP_sig_OAMS_TRXH_CELLH_OPR_STATE_IND)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_OAMS_TRXH_CELLH_OPR_STATE_IND)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
               LOG_PRINT(INFO,"Received NULL Pointer from module,Returning without sending to FRM..") ;
               xReleaseSignal(SignalOut);
               return;
           }
           LOG_PRINT(INFO,"Send OAMS_TRXH_CELLH_OPR_STATE_IND::msgSiz= %d msgTyp= 0x%x",msgSize , ((SysHdr *)sndPtr)->msgType);
           break;
           
       case SN_OAMS_TRXH_GRHM_OPER_STATE_IND:
           sndPtr = ((yPDP_sig_OAMS_TRXH_GRHM_OPER_STATE_IND)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_OAMS_TRXH_GRHM_OPER_STATE_IND)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
               LOG_PRINT(INFO,"Received NULL Pointer from module,Returning without sending to FRM..") ;
               xReleaseSignal(SignalOut);
               return;
           }
           LOG_PRINT(INFO,"Send OAMS_TRXH_GRHM_OPER_STATE_IND::msgSiz= %d  msgTyp= 0x%x", msgSize , ((SysHdr *)sndPtr)->msgType);
           break;
           
      case SN_OAMS_TRXH_ABIHM_LINK_STATUS_REQ:
           sndPtr = ((yPDP_sig_OAMS_TRXH_GRHM_OPER_STATE_IND)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_OAMS_TRXH_GRHM_OPER_STATE_IND)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
               LOG_PRINT(INFO,"Received NULL Pointer from module,Returning without sending to FRM..") ;
               xReleaseSignal(SignalOut);
               return;
           }
           LOG_PRINT(INFO,"Send OAMS_TRXH_ABIHM_LINK_STATUS_REQ::msgSiz= %d  msgTyp= 0x%x", msgSize , ((SysHdr *)sndPtr)->msgType);
           break;
       /* R2.5.5 (ABIS HA No LAPD Down) : End*/
     
        /* Changes for Mantis Id 24129 Starts*/
      case SN_OAMS_TRXH_GRHM_DEL_CHAN_ACK_TIMER_EXPIRY_IND:
           sndPtr = ((yPDP_sig_OAMS_TRXH_GRHM_DEL_CHAN_ACK_TIMER_EXPIRY_IND)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_OAMS_TRXH_GRHM_DEL_CHAN_ACK_TIMER_EXPIRY_IND)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
               LOG_PRINT(INFO,"Received NULL Pointer from module,Returning without sending to FRM..") ;
               xReleaseSignal(SignalOut);
               return;
           }
           LOG_PRINT(INFO,"Send OAMS_TRXH_GRHM_DEL_CHAN_ACK_TIMER_EXPIRY_IND::msgSiz= %d  msgTyp= 0x%x", msgSize , ((SysHdr *)sndPtr)->msgType);
           break;
       /* Changes for Mantis Id 24129 Ends*/
      
      /* R2.9 : Power Saving Feature - start */ 
      case SN_OAMS_TRXH_ABIHM_BM_PWR_SAVING_CMD:
           sndPtr = ((yPDP_sig_OAMS_TRXH_ABIHM_BM_PWR_SAVING_CMD)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_OAMS_TRXH_ABIHM_BM_PWR_SAVING_CMD)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
              LOG_PRINT(INFO,"Received NULL Pointer from module,Returning without sending to FRM..") ;
              xReleaseSignal(SignalOut);
              return;
           }
           LOG_PRINT(INFO,"Send OAMS_TRXH_ABIHM_BM_PWR_SAVING_CMD::msgSiz= %d  msgTyp= 0x%x",msgSize , ((SysHdr *)sndPtr)->msgType);
           PRINT_HEX_DUMP(INFO, sndPtr, (msgSize));
           break;
      /* R2.9 : Power Saving Feature - ends */                                      
        
      case SN_OAMS_TRXH_CPHM_TRX_MAPPED_IND:
           sndPtr = ((yPDP_sig_OAMS_TRXH_CPHM_TRX_MAPPED_IND)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_OAMS_TRXH_CPHM_TRX_MAPPED_IND)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
              LOG_PRINT(INFO,"Rcvd NULL Ptr from module,Returning without sending to FRM..") ;
              xReleaseSignal(SignalOut);
              return;
           }
           LOG_PRINT(INFO,"Send OAMS_TRXH_CPHM_TRX_MAPPED_IND::msgSize= %d  msgType= 0x%x",msgSize , ((SysHdr *)sndPtr)->msgType);
           break;

      case SN_OAMS_TRXH_CPHM_TRX_UNMAPPED_IND:
           sndPtr = ((yPDP_sig_OAMS_TRXH_CPHM_TRX_UNMAPPED_IND)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_OAMS_TRXH_CPHM_TRX_UNMAPPED_IND)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
              LOG_PRINT(INFO,"Rcvd NULL Ptr from module,Returning without sending to FRM..") ;
              xReleaseSignal(SignalOut);
              return;
           }
           LOG_PRINT(INFO,"Send OAMS_TRXH_CPHM_TRX_UNMAPPED_IND::msgSize= %d  msgType= 0x%x",msgSize , ((SysHdr *)sndPtr)->msgType);
           break;

       default:
           LOG_PRINT(INFO,"Entered Default Case : xOutEnv");
           sndPtr = ((yPDP_sig_OAMS_TRXH_CFG_ALARM_IND)(*SignalOut))->Param1;
           if (sndPtr!=NULL)
           {
              DalocMsgBuf((I_Void *)sndPtr);
           }
           xReleaseSignal(SignalOut);
           return;
  
   }/*switch */
   
   /*
   LOG_PRINT(INFO,"\n OUT OF SWITCH XOUT::ENV \n ");
   */
   if (msgSize != 0)
   {
      if (SendMsg(sndPtr, MSG_ORD_PRIO, msgSize) == SND_FAIL)
      {
         LOG_PRINT(INFO,"\n SENDING FAILED \n");
         //DalocMsgBuf((I_Void *)sndPtr);
         xReleaseSignal(SignalOut);
         return;
      }
      else
      {
         /*
         LOG_PRINT(INFO,"Successfully sent message out");
				 */
         xReleaseSignal(SignalOut);
         return;
      }
   }
   else
   {
      LOG_PRINT(CRITICAL,"TRXH: UNABLE TO ALLOCATE MEMORY FOR THE MESSAGE, msgSize is 0");
      xReleaseSignal(SignalOut);
   }
   /* Signals going to the env via the port ToEnv  */

}/*xOutEnv*/


/*---+---------------------------------------------------------------
     Macros for xInEnv
-------------------------------------------------------------------*/
#ifndef IN_LOCAL_VARIABLES
#define IN_LOCAL_VARIABLES \
  xSignalNode SignalIn;
#endif

#ifndef IN_SIGNAL1
#define IN_SIGNAL1(SIGNAL_NAME, SIGNAL_NAME_STRING) \
  SignalIn = xGetSignal(SIGNAL_NAME, xNotDefPId, xEnv);
#endif

#ifndef IN_SIGNAL2
#define IN_SIGNAL2(SIGNAL_NAME, SIGNAL_NAME_STRING) \
  SDL_Output(SignalIn xSigPrioPar(xDefaultPrioSignal), (xIdNode *)0);
#endif

#ifndef IF_IN_SIGNAL
#define IF_IN_SIGNAL(SIGNAL_NAME, SIGNAL_NAME_STRING) \
  if (TEST_IF_IN_SIGNAL(SIGNAL_NAME)) {
#define END_IF_IN_SIGNAL(SIGNAL_NAME, SIGNAL_NAME_STRING) \
  }
#endif

#ifndef TEST_IF_IN_SIGNAL
#define TEST_IF_IN_SIGNAL(SIGNAL_NAME)  0
#endif

#ifndef XENV_DEC
#define XENV_DEC(stmt) stmt
#endif

#ifndef XENV_IN_START
#define XENV_IN_START
#endif

#ifndef XENV_IN_END
#define XENV_IN_END
#endif


/*---+---------------------------------------------------------------
     xInEnv  extern
-------------------------------------------------------------------*/
#ifndef XTENV
extern void xInEnv ( SDL_Time Time_for_next_event )
#else
extern SDL_Duration xInEnv ( SDL_Time Time_for_next_event )
#endif
{
   xSignalNode S;


#ifdef XTRACE
#ifndef XNOXINENVTRACE
   xPrintString( "xInEnv: Called!\n");
#endif
#endif

   I_Void         *rcvPtr;
   I_S32          msgSize;
   I_S32          instId;
   I_U16          msgType;
   I_U8           subType;
   SDL_Pid        rcvr;
   I_U32          lclPidPtr;
   I_S32          errCode=ZERO;
   I_U32          tei=ZERO;
   I_U32          ptrxId=ZERO ;
   I_U32          isActiveReqRmRcvd = ZERO;
   /* R2.9 changes starts */
   I_U16 trxIndex = ZERO;
   I_U16 trxCount = ZERO; 
   TrxPsRelStatusData *trxPsRelStatusData;
  /* R2.9 changes ends */
	 struct sAisParam *param;
   I_U8           actClsId = 0;

   if ((rcvPtr = (I_Void *)RecvMsg(selfEntIdG, &msgSize)) != NULL)
   {
      msgType = ((SysHdr *)rcvPtr)->msgType;
      subType = ((SysHdr *)rcvPtr)->subType;
      instId = ((SysHdr *)rcvPtr)->dest.inst;
      LOG_PRINT(INFO,"Messgae Received for TRXHM msgTyp = 0x%x and subType = %d",msgType,subType);
      rcvr.GlobalNodeNr = (I_S32)selfEntIdG;
      rcvr.LocalPId = (xLocalPIdNode)0;
      lclPidPtr = 0;
		if ( gCurrentCardState == CARDSTATE_ACTIVE)
		{
											 
	      switch(msgType)
	      {
	         /* Send this Message into TAU model */
	         /* Interface to CFG */
	         /*added in CS2.2*/
	         case OAMS_CFG_TRXH_ADD_TRX_REQ:
	         {
	            LOG_PRINT(DEBUG,"xInEnv : OAMS_CFG_TRXH_ADD_TRX_REQ rcvd");
	            ptrxId = GetRefIdByPtrxId(rcvPtr) ;
              
              actClsId = getActiveClassIdFromPtrxIdTei(ptrxId,0);

              errCode = getTrxTeiTrxTsTeiTable(ptrxId,&tei);
              if(CLIB_SUCCESS != errCode)
              {
                LOG_PRINT(CRITICAL,"Error in getTrxTeiTrxTsTeiTable: err = %s",clib_strerror(errCode));
                return;
              }

	            if (AlocNewInst(&lclPidPtr, &instId, ENT_OAMS_TRXH,
	                            actClsId,ptrxId,
	                            tei, ZERO, ZERO, ZERO)  != INST_SUCCESS)
	            {
	                LOG_PRINT(CRITICAL, "xInEnv : AlocNewInst() Failed for TRXH");
	                return;
	            }
	            LOG_PRINT(DEBUG, "xInEnv : NEW INST ALLOCATED LCLPID: 0x%0x, INST-ID: %d,"
                  " PTRX-ID: %d ACTCLID[%d] tei[%d]", lclPidPtr, instId, ptrxId,actClsId,tei);
	            rcvr.LocalPId = (xLocalPIdNode)lclPidPtr;
	            S = xGetSignal( sig_OAMS_CFG_TRXH_ADD_TRX_REQ, rcvr, xEnv);
	            (((yPDP_sig_OAMS_CFG_TRXH_ADD_TRX_REQ)S)->Param1) = rcvPtr;
	            break;
	         }
	
	         case OAMS_CFG_TRXH_DEL_TRX_REQ:
	         {
	            LOG_PRINT(DEBUG,"OAMS_CFG_TRXH_DEL_TRX_REQ: rcvd from CFG");
	            if ((rcvr.LocalPId = (xLocalPIdNode)FindTrxhLocalPidByPtrx(rcvPtr)) == 0)
	            {
	               LOG_PRINT(DEBUG,"Failed to find Instance for Incoming request");
	               DalocMsgBuf((I_Void *)rcvPtr) ;
	               return ;
	            }
	            S = xGetSignal( sig_OAMS_CFG_TRXH_DEL_TRX_REQ, rcvr, xEnv);
	            (((yPDP_sig_OAMS_CFG_TRXH_DEL_TRX_REQ)S)->Param1) = rcvPtr;
	            break;
	         }
	
	         /*added in CS2.2*/
	         case OAMS_CFG_TRXH_UNLOCK_REQ:
	         {
	            LOG_PRINT(INFO,"CFG_TRXH_UNLOCK_REQ: rcvd from CFG");
	            if ((rcvr.LocalPId = (xLocalPIdNode)FindTrxhLocalPidByPtrx(rcvPtr)) == 0)
	            {
	               LOG_PRINT(INFO,"Failed to find Instance for Incoming request");
	               DalocMsgBuf((I_Void *)rcvPtr) ;
	               return ;
	            }
	            S = xGetSignal( sig_OAMS_CFG_TRXH_UNLOCK_REQ, rcvr, xEnv);
	            (((yPDP_sig_OAMS_CFG_TRXH_UNLOCK_REQ)S)->Param1) = rcvPtr;
	            break;
	         }
	         case OAMS_CFG_TRXH_LOCK_REQ:
	         {
	            LOG_PRINT(INFO,"CFG_TRXH_LOCK_REQ rcvd from CFG");
	            if ((rcvr.LocalPId = (xLocalPIdNode)FindTrxhLocalPidByPtrx(rcvPtr)) == 0)
	            {
	               LOG_PRINT(INFO,"Failed to find Instance for Incoming request");       
	               DalocMsgBuf((I_Void *)rcvPtr) ;
	               return ;
	            } 
	            S = xGetSignal( sig_OAMS_CFG_TRXH_LOCK_REQ, rcvr, xEnv);
	            (((yPDP_sig_OAMS_CFG_TRXH_LOCK_REQ)S)->Param1) = rcvPtr;
	            break;
	         }
          /* R2.5.2 TRX BLOCK */
           case OAMS_CFG_TRXH_BLOCK_REQ:
           {
              LOG_PRINT(INFO,"CFG_TRXH_BLOCK_REQ Signal received from CFG");
              if ((rcvr.LocalPId = (xLocalPIdNode)FindTrxhLocalPidByPtrx(rcvPtr)) == 0)
              {
                 LOG_PRINT(INFO,"Failed to find Instance for Incoming request\n");
                 DalocMsgBuf((I_Void *)rcvPtr) ;
                 return ;
              }
              S = xGetSignal( sig_OAMS_CFG_TRXH_BLOCK_REQ, rcvr, xEnv);
              (((yPDP_sig_OAMS_CFG_TRXH_BLOCK_REQ)S)->Param1) = rcvPtr;
              break;
           }
           /* R2.5.2 TRX BLOCK */

           /* R2.2 Changes : Starts */
           case OAMS_CFG_TRXH_TRX_RESET:
	         {
	            LOG_PRINT(INFO,"CFG_TRXH_TRX_RESET rcvd from CFG");
	            if ((rcvr.LocalPId = (xLocalPIdNode)FindTrxhLocalPidByPtrx(rcvPtr)) == 0)
	            {
	               LOG_PRINT(INFO,"Failed to find Instance for Incoming request");
	               DalocMsgBuf((I_Void *)rcvPtr) ;
	               return ;
	            }
	            S = xGetSignal( sig_OAMS_CFG_TRXH_TRX_RESET, rcvr, xEnv);
	            (((yPDP_sig_OAMS_CFG_TRXH_TRX_RESET)S)->Param1) = rcvPtr;
	            break;
	         }
                 /* R2.2 Changes : Ends   */

	         /* Interface to CELLH */
	         case OAMS_MAPENT_TRXH_CRE_LTRX_PTRX_MAPPING_REQ:
	         {
	            LOG_PRINT(INFO,"MAPENT_TRXH_CRE_LTRX_PTRX_MAPPING_REQ rcvd from Mapent");
	            if ((rcvr.LocalPId =(xLocalPIdNode)FindTrxhLocalPidByPtrx(rcvPtr)) == 0)
	            {
	                LOG_PRINT(INFO,"Failed to find Instance for Incoming request");
	                DalocMsgBuf((I_Void *)rcvPtr) ;
	                return ;
	            }
	            S = xGetSignal( sig_OAMS_MAPENT_TRXH_CRE_LTRX_PTRX_MAPPING_REQ, rcvr, xEnv);
	            (((yPDP_sig_OAMS_MAPENT_TRXH_CRE_LTRX_PTRX_MAPPING_REQ)S)->Param1) = rcvPtr;
	            break;
	         }
	
	         case OAMS_MAPENT_TRXH_DEL_LTRX_PTRX_MAPPING_REQ:
	         {
	            LOG_PRINT(INFO,"MAPENT_TRXH_DEL_LTRX_PTRX_MAPPING_REQ Signal rcvd from Mapent");
	            if ((rcvr.LocalPId =(xLocalPIdNode)FindTrxhLocalPidByPtrx(rcvPtr)) == 0)
	            {
	               LOG_PRINT(INFO,"Failed to find Instance for Incoming request");      
	               DalocMsgBuf((I_Void *)rcvPtr) ;
	               return ;
	            }
	            S = xGetSignal( sig_OAMS_MAPENT_TRXH_DEL_LTRX_PTRX_MAPPING_REQ, rcvr, xEnv);
	            (((yPDP_sig_OAMS_MAPENT_TRXH_DEL_LTRX_PTRX_MAPPING_REQ)S)->Param1) = rcvPtr;
	            break;
	         }
                  /* PCU R2.5 Changes : Starts */
                 case OAMS_CELLH_TRXH_UPDATE_PS_CELL_ATTR:
                 {
                     LOG_PRINT(INFO,"OAMS_CELLH_TRXH_UPDATE_PS_CELL_ATTR rcvd from Mapent");
                     if ((rcvr.LocalPId =(xLocalPIdNode)FindTrxhLocalPidByPtrx(rcvPtr)) == 0)
                     {
                         LOG_PRINT(INFO,"Failed to find Instance for Incoming request");
                         DalocMsgBuf((I_Void *)rcvPtr) ;
                         return ;
                     }
                     S = xGetSignal( sig_OAMS_CELLH_TRXH_UPDATE_PS_CELL_ATTR, rcvr, xEnv);
                     (((yPDP_sig_OAMS_CELLH_TRXH_UPDATE_PS_CELL_ATTR)S)->Param1) = rcvPtr;
                     break;
                 }
                  /* Interface to PSCH */
                case OAMS_PSCH_TRXH_PS_ATTR_CHANGE_IND:
                {
                    LOG_PRINT(INFO,"OAMS_PSCH_TRXH_PS_ATTR_CHANGE_IND rcvd from PSCH");
		    if ((rcvr.LocalPId =(xLocalPIdNode)FindTrxhLocalPidByPtrx(rcvPtr)) == 0)
                    {
                       LOG_PRINT(INFO,"Failed to find Instance for Incoming request");
                       DalocMsgBuf((I_Void *)rcvPtr) ;
                       return ;
                    }
                    S = xGetSignal( sig_OAMS_PSCH_TRXH_PS_ATTR_CHANGE_IND, rcvr, xEnv);
		    (((yPDP_sig_OAMS_PSCH_TRXH_PS_ATTR_CHANGE_IND)S)->Param1) = rcvPtr;
		    break;
                 }
                 /* PCU R2.5 Changes : End */
	         /* Interface to GRHM */
	         case CSAPP_GRHM_TRXH_CRE_CHN_ACK:
	         {
	            LOG_PRINT(INFO,"CSAPP_GRHM_TRXH_CRE_CHN_ACK: rcvd from Grhm");
	            if ((rcvr.LocalPId = (xLocalPIdNode)FindTrxhLocalPidByTei(rcvPtr)) == 0)
	            {
	               LOG_PRINT(INFO,"Failed to find Instance for Incoming request");       
	               DalocMsgBuf((I_Void *)rcvPtr) ;
	               return ;
	            }
	            S = xGetSignal( sig_CSAPP_GRHM_TRXH_CRE_CHN_ACK, rcvr, xEnv);
	            (((yPDP_sig_CSAPP_GRHM_TRXH_CRE_CHN_ACK)S)->Param1) = rcvPtr;
	            break;
	         }
	         
	         case CSAPP_GRHM_TRXH_CRE_CHN_NACK:
	         {
	            LOG_PRINT(INFO,"CSAPP_GRHM_TRXH_CRE_CHN_NACK: rcvd from Grhm");
	            if ((rcvr.LocalPId = (xLocalPIdNode)FindTrxhLocalPidByTei(rcvPtr)) == 0)
	            {
	                LOG_PRINT(INFO,"Failed to find Instance for Incoming request");
	                DalocMsgBuf((I_Void *)rcvPtr) ;
	                return ;
	            }
	            S = xGetSignal( sig_CSAPP_GRHM_TRXH_CRE_CHN_NACK, rcvr, xEnv);
	            (((yPDP_sig_CSAPP_GRHM_TRXH_CRE_CHN_NACK)S)->Param1) = rcvPtr;
	            break;
	         }
	         
	         case CSAPP_GRHM_TRXH_DEL_CHN_ACK:
	         {
	            LOG_PRINT(INFO,"CSAPP_GRHM_TRXH_DEL_CHN_ACK: rcvd from Grhm");
	            if ((rcvr.LocalPId = (xLocalPIdNode)FindTrxhLocalPidByTei(rcvPtr)) == 0)
	            {
	               LOG_PRINT(INFO,"Failed to find Instance for Incoming request"); 
	               DalocMsgBuf((I_Void *)rcvPtr) ;
	               return ;
	            }
	            S = xGetSignal( sig_CSAPP_GRHM_TRXH_DEL_CHN_ACK, rcvr, xEnv);
	            (((yPDP_sig_CSAPP_GRHM_TRXH_DEL_CHN_ACK)S)->Param1) = rcvPtr;
	            break;
	         }

                 /* Interface with BICH */
                 /* R2.2 Changes : Starts */
                 case OAMS_BICH_TRXH_LOCK_IND:
	         {
	            LOG_PRINT(INFO,"OAMS_BICH_TRXH_LOCK_IND rcvd from BICH");        
	            if ((rcvr.LocalPId = (xLocalPIdNode)FindTrxhLocalPidByPtrx(rcvPtr)) == 0)
	            {
	               LOG_PRINT(INFO,"Failed to find Instance for Incoming request");
	               DalocMsgBuf((I_Void *)rcvPtr) ;
	               return ;
	            }
	            S = xGetSignal( sig_OAMS_BICH_TRXH_LOCK_IND, rcvr, xEnv);
	            (((yPDP_sig_OAMS_BICH_TRXH_LOCK_IND)S)->Param1) = rcvPtr;
	            break;
	         }

                 case OAMS_BICH_TRXH_UNLOCK_IND:
	         {
	            LOG_PRINT(INFO,"OAMS_BICH_TRXH_UNLOCK_IND rcvd from BICH");        
	            if ((rcvr.LocalPId = (xLocalPIdNode)FindTrxhLocalPidByPtrx(rcvPtr)) == 0)
	            {
	               LOG_PRINT(INFO,"Failed to find Instance for Incoming request");
	               DalocMsgBuf((I_Void *)rcvPtr) ;
	               return ;
	            }
	            S = xGetSignal( sig_OAMS_BICH_TRXH_UNLOCK_IND, rcvr, xEnv);
	            (((yPDP_sig_OAMS_BICH_TRXH_UNLOCK_IND)S)->Param1) = rcvPtr;
	            break;
	         }

                 case OAMS_BICH_TRXH_LAPD_DISCONNECT_IND:
	         {
	            LOG_PRINT(INFO,"OAMS_BICH_TRXH_LAPD_DISCONNECT_IND rcvd from BICH");        
	            if ((rcvr.LocalPId = (xLocalPIdNode)FindTrxhLocalPidByPtrx(rcvPtr)) == 0)
	            {
	               LOG_PRINT(INFO,"Failed to find Instance for Incoming request");
	               DalocMsgBuf((I_Void *)rcvPtr) ;
	               return ;
	            }
	            S = xGetSignal( sig_OAMS_BICH_TRXH_LAPD_DISCONNECT_IND, rcvr, xEnv);
	            (((yPDP_sig_OAMS_BICH_TRXH_LAPD_DISCONNECT_IND)S)->Param1) = rcvPtr;
	            break;
	         }

                 /* R2.2 Changes : Ends   */
                 /* PCU R2.5 Changes : Start */
	         case OAMS_BICH_TRXH_IP_LINK_DOWN:
	         {
	              LOG_PRINT(INFO,"OAMS_BICH_TRXH_IP_LINK_DOWN rcvd from BICH");
	              if ((rcvr.LocalPId = (xLocalPIdNode)FindTrxhLocalPidByPtrx(rcvPtr)) == 0)
		      {
                          LOG_PRINT(INFO,"Failed to find Instance for Incoming request");
                          DalocMsgBuf((I_Void *)rcvPtr) ;
                          return ;
                      }
                      S = xGetSignal( sig_OAMS_BICH_TRXH_IP_LINK_DOWN, rcvr, xEnv);
                     (((yPDP_sig_OAMS_BICH_TRXH_IP_LINK_DOWN)S)->Param1) = rcvPtr;
                     break;
                 }

                 case OAMS_BICH_TRXH_IP_LINK_UP:
                 {
		     LOG_PRINT(INFO,"OAMS_BICH_TRXH_IP_LINK_UP rcvd from BICH");
		     if ((rcvr.LocalPId = (xLocalPIdNode)FindTrxhLocalPidByPtrx(rcvPtr)) == 0)
		     {
		          LOG_PRINT(INFO,"Failed to find Instance for Incoming request");
		          DalocMsgBuf((I_Void *)rcvPtr) ;
		          return ;
		     }
		     S = xGetSignal( sig_OAMS_BICH_TRXH_IP_LINK_UP, rcvr, xEnv);
		     (((yPDP_sig_OAMS_BICH_TRXH_IP_LINK_UP)S)->Param1) = rcvPtr;
		     break;
		 }
		  /* PCU R2.5 Changes : End */
	         /* Interface to ABIHM */
	         case CSAPP_ABIHM_TRXH_OP_STOP_ACK:
	         {
	            LOG_PRINT(INFO,"CSAPP_ABIHM_TRXH_OP_STOP_ACK: rcvd from ABIHM");
	            if ((rcvr.LocalPId = (xLocalPIdNode)FindTrxhLocalPidByTei(rcvPtr)) == 0)
	            {
	                LOG_PRINT(INFO,"Failed to find Instance for Incoming request");
	                DalocMsgBuf((I_Void *)rcvPtr) ;
	                return ;
	            }
	            S = xGetSignal( sig_CSAPP_ABIHM_TRXH_OP_STOP_ACK, rcvr, xEnv);
	            (((yPDP_sig_CSAPP_ABIHM_TRXH_OP_STOP_ACK)S)->Param1) = rcvPtr;
	            break;
	         }
	
	         case CSAPP_ABIHM_TRXH_OP_STOP_NACK:
	         {
	            LOG_PRINT(INFO,"CSAPP_ABIHM_TRXH_OP_STOP_NACK: rcvd from ABIHM");
	            if ((rcvr.LocalPId = (xLocalPIdNode)FindTrxhLocalPidByTei(rcvPtr)) == 0)
	            {
	               LOG_PRINT(INFO,"Failed to find Instance for Incoming request");  
	               DalocMsgBuf((I_Void *)rcvPtr) ;
	               return ;
	            }
	            S = xGetSignal( sig_CSAPP_ABIHM_TRXH_OP_STOP_NACK, rcvr, xEnv);
	            (((yPDP_sig_CSAPP_ABIHM_TRXH_OP_STOP_NACK)S)->Param1) = rcvPtr;
	            break;
	         }
	
	         case CSAPP_ABIHM_TRXH_TRX_HELLO:
	         {
	            LOG_PRINT(INFO,"CSAPP_ABIHM_TRXH_TRX_HELLO: rcvd from ABIHM");
	            if ((rcvr.LocalPId = (xLocalPIdNode)FindTrxhLocalPidByTei(rcvPtr)) == 0)
	            {
	               LOG_PRINT(INFO,"Failed to find Instance for Incoming request");  
	               DalocMsgBuf((I_Void *)rcvPtr) ;
	               return ;
	            }
	            S = xGetSignal( sig_CSAPP_ABIHM_TRXH_TRX_HELLO, rcvr, xEnv);
	            (((yPDP_sig_CSAPP_ABIHM_TRXH_TRX_HELLO)S)->Param1) = rcvPtr;
	            break;
	         }

                 /* R2.2 Changes : Starts  */
	         case CSAPP_ABIHM_TRXH_TM_HELLO:
	         {
	            LOG_PRINT(INFO,"CSAPP_ABIHM_TRXH_TM_HELLO: rcvd from ABIHM");
	            if ((rcvr.LocalPId = (xLocalPIdNode)FindTrxhLocalPidByTei(rcvPtr)) == 0)
	            {
	               LOG_PRINT(INFO,"Failed to find Instance for Incoming request");  
	               DalocMsgBuf((I_Void *)rcvPtr) ;
	               return ;
	            }
	            S = xGetSignal( sig_CSAPP_ABIHM_TRXH_TM_HELLO, rcvr, xEnv);
	            (((yPDP_sig_CSAPP_ABIHM_TRXH_TM_HELLO)S)->Param1) = rcvPtr;
	            break;
	         }

	         case CSAPP_ABIHM_TRXH_TM_RESTART_ACK:
	         {
	            LOG_PRINT(INFO,"CSAPP_ABIHM_TRXH_TM_RESTART_ACK: rcvd from ABIHM");
	            if ((rcvr.LocalPId = (xLocalPIdNode)FindTrxhLocalPidByTei(rcvPtr)) == 0)
	            {
	               LOG_PRINT(INFO,"Failed to find Instance for Incoming request");  
	               DalocMsgBuf((I_Void *)rcvPtr) ;
	               return ;
	            }
	            S = xGetSignal( sig_CSAPP_ABIHM_TRXH_TM_RESTART_ACK, rcvr, xEnv);
	            (((yPDP_sig_CSAPP_ABIHM_TRXH_TM_RESTART_ACK)S)->Param1) = rcvPtr;
	            break;
	         }
                 /* R2.2 Changes : Ends  */

	
	         case CSAPP_ABIHM_TRXH_SET_BTS_ATTR_ACK:
	         {
	            LOG_PRINT(INFO,"CSAPP_ABIHM_TRXH_SET_BTS_ATTR_ACK: rcvd from ABIHM");
	            if ((rcvr.LocalPId = (xLocalPIdNode)FindTrxhLocalPidByTei(rcvPtr)) == 0)
	            {
	               LOG_PRINT(INFO,"Failed to find Instance for Incoming request");    
	               DalocMsgBuf((I_Void *)rcvPtr) ;
	               return ;
	            }
	            S = xGetSignal( sig_CSAPP_ABIHM_TRXH_SET_BTS_ATTR_ACK, rcvr, xEnv);
	            (((yPDP_sig_CSAPP_ABIHM_TRXH_SET_BTS_ATTR_ACK)S)->Param1) = rcvPtr;
	            break;
	         }
	
	         case CSAPP_ABIHM_TRXH_SET_BTS_ATTR_NACK:
	         {
	            LOG_PRINT(CRITICAL,"CSAPP_ABIHM_TRXH_SET_BTS_ATTR_NACK: rcvd from ABIHM");
	            if ((rcvr.LocalPId = (xLocalPIdNode)FindTrxhLocalPidByTei(rcvPtr)) == 0)
	            {
	               LOG_PRINT(INFO,"Failed to find Instance for Incoming request"); 
	               DalocMsgBuf((I_Void *)rcvPtr) ;
	               return ;
	            }
	            S = xGetSignal( sig_CSAPP_ABIHM_TRXH_SET_BTS_ATTR_NACK, rcvr, xEnv);
	            (((yPDP_sig_CSAPP_ABIHM_TRXH_SET_BTS_ATTR_NACK)S)->Param1) = rcvPtr;
	            break;
	         }
                 /* PCU R2.5 Changes : Starts  */
                 case CSAPP_ABIHM_TRXH_SET_TRX_PS_ATTR_ACK:
		 {
		     LOG_PRINT(INFO,"CSAPP_ABIHM_TRXH_SET_TRX_PS_ATTR_ACK: rcvd from ABIHM");
		     if ((rcvr.LocalPId = (xLocalPIdNode)FindTrxhLocalPidByTei(rcvPtr)) == 0)
		     {
		          LOG_PRINT(INFO,"Failed to find Instance for Incoming request");
		          DalocMsgBuf((I_Void *)rcvPtr) ;
		          return ;
		     }
		     S = xGetSignal( sig_CSAPP_ABIHM_TRXH_SET_TRX_PS_ATTR_ACK, rcvr, xEnv);
		     (((yPDP_sig_CSAPP_ABIHM_TRXH_SET_TRX_PS_ATTR_ACK)S)->Param1) = rcvPtr;
		     break;
		 }
		 case CSAPP_ABIHM_TRXH_SET_TRX_PS_ATTR_NACK:
		 {
		    LOG_PRINT(CRITICAL,"CSAPP_ABIHM_TRXH_SET_TRX_PS_ATTR_NACK: rcvd from ABIHM");
		    if ((rcvr.LocalPId = (xLocalPIdNode)FindTrxhLocalPidByTei(rcvPtr)) == 0)
		    {
		        LOG_PRINT(INFO,"Failed to find Instance for Incoming request");
		        DalocMsgBuf((I_Void *)rcvPtr) ;
		        return ;
		    }
		    S = xGetSignal( sig_CSAPP_ABIHM_TRXH_SET_TRX_PS_ATTR_NACK, rcvr, xEnv);
		    (((yPDP_sig_CSAPP_ABIHM_TRXH_SET_TRX_PS_ATTR_NACK)S)->Param1) = rcvPtr;
		    break;
		 }
		 /* PCU R2.5 Changes : End  */
	         case CSAPP_ABIHM_TRXH_SET_CHAN_ATTR_ACK:
	         {
	            LOG_PRINT(INFO,"CSAPP_ABIHM_TRXH_SET_CHAN_ATTR_ACK: rcvd from ABIHM");
	            if ((rcvr.LocalPId = (xLocalPIdNode)FindTrxhLocalPidByTei(rcvPtr)) == 0)
	            {
	                LOG_PRINT(INFO,"Failed to find Instance for Incoming requestn");      
	                DalocMsgBuf((I_Void *)rcvPtr) ;
	                return ;
	            }
	            S = xGetSignal( sig_CSAPP_ABIHM_TRXH_SET_CHAN_ATTR_ACK, rcvr, xEnv);
	            (((yPDP_sig_CSAPP_ABIHM_TRXH_SET_CHAN_ATTR_ACK)S)->Param1) = rcvPtr;
	            break;
	         }
	           
	         case CSAPP_ABIHM_TRXH_SET_CHAN_ATTR_NACK:
	         {
	             LOG_PRINT(INFO,"CSAPP_ABIHM_TRXH_SET_CHAN_ATTR_NACK: rcvd from ABIHM");
	             if ((rcvr.LocalPId = (xLocalPIdNode)FindTrxhLocalPidByTei(rcvPtr)) == 0)
	             {
	                LOG_PRINT(INFO,"Failed to find Instance for Incoming request");    
	                DalocMsgBuf((I_Void *)rcvPtr) ;
	                return ;
	             }
	             S = xGetSignal( sig_CSAPP_ABIHM_TRXH_SET_CHAN_ATTR_NACK, rcvr, xEnv);
	             (((yPDP_sig_CSAPP_ABIHM_TRXH_SET_CHAN_ATTR_NACK)S)->Param1) = rcvPtr;
	             break;
	         }
	
	         case CSAPP_ABIHM_TRXH_STATE_CHANGE_EVENT_REPORT:
	         {
	            LOG_PRINT(INFO,"CSAPP_ABIHM_TRXH_STATE_CHANGE_EVENT_REPORT: rcvd from ABIHM");
	            if ((rcvr.LocalPId = (xLocalPIdNode)FindTrxhLocalPidByTei(rcvPtr)) == 0)
	            {
	               LOG_PRINT(INFO,"Failed to find Instance for Incoming request");   
	               DalocMsgBuf((I_Void *)rcvPtr) ;
	               return ;
	            }
	            S = xGetSignal( sig_CSAPP_ABIHM_TRXH_STATE_CHANGE_EVENT_REPORT, rcvr, xEnv);
	            (((yPDP_sig_CSAPP_ABIHM_TRXH_STATE_CHANGE_EVENT_REPORT)S)->Param1) = rcvPtr;
	            break;
	         }
	                       
	         case CSAPP_ABIHM_TRXH_FAILURE_EVENT_REPORT:
	         {
	             LOG_PRINT(INFO,"CSAPP_ABIHM_TRXH_FAILURE_EVENT_REPORT: rcvd from ABIHM");
	             if ((rcvr.LocalPId = (xLocalPIdNode)FindTrxhLocalPidByTei(rcvPtr)) == 0)
	             {
	                LOG_PRINT(INFO,"Failed to find Instance for Incoming request");
	                DalocMsgBuf((I_Void *)rcvPtr) ;
	                return ;
	             }
	             S = xGetSignal( sig_CSAPP_ABIHM_TRXH_FAILURE_EVENT_REPORT, rcvr, xEnv);
	             (((yPDP_sig_CSAPP_ABIHM_TRXH_FAILURE_EVENT_REPORT)S)->Param1) = rcvPtr;
	             break;
	         }
	
	         case CSAPP_ABIHM_TRXH_OP_START_ACK:
	         {
	            LOG_PRINT(INFO,"CSAPP_ABIHM_TRXH_OP_START_ACK: rcvd from ABIHM");
	            if ((rcvr.LocalPId = (xLocalPIdNode)FindTrxhLocalPidByTei(rcvPtr)) == 0)
	            {
	               LOG_PRINT(INFO,"Failed to find Instance for Incoming request"); 
	               DalocMsgBuf((I_Void *)rcvPtr) ;
	               return ;
	            }
	            S = xGetSignal( sig_CSAPP_ABIHM_TRXH_OP_START_ACK, rcvr, xEnv);
	            (((yPDP_sig_CSAPP_ABIHM_TRXH_OP_START_ACK)S)->Param1) = rcvPtr;
	            break;
	         }
	
	         case CSAPP_ABIHM_TRXH_OP_START_NACK:
	         {
	            LOG_PRINT(INFO,"CSAPP_ABIHM_TRXH_OP_START_NACK: rcvd from ABIHM");
	            if ((rcvr.LocalPId = (xLocalPIdNode)FindTrxhLocalPidByTei(rcvPtr)) == 0)
	            {
	               LOG_PRINT(INFO,"Failed to find Instance for Incoming request");
	               DalocMsgBuf((I_Void *)rcvPtr) ;
	               return ;
	            }
	            S = xGetSignal( sig_CSAPP_ABIHM_TRXH_OP_START_NACK, rcvr, xEnv);
	            (((yPDP_sig_CSAPP_ABIHM_TRXH_OP_START_NACK)S)->Param1) = rcvPtr;
	            break;
	         }
	
	         case CSAPP_ABIHM_TRXH_LAPD_LINK_UP:
	         {
	            LOG_PRINT(INFO,"CSAPP_ABIHM_TRXH_LAPD_LINK_UP: rcvd from ABIHM");
	            if ((rcvr.LocalPId = (xLocalPIdNode)FindTrxhLocalPidByTei(rcvPtr)) == 0)
	            {
	               LOG_PRINT(INFO,"Failed to find Instance for Incoming request"); 
	               DalocMsgBuf((I_Void *)rcvPtr) ;
	               return ;
	            }
	            S = xGetSignal( sig_CSAPP_ABIHM_TRXH_LAPD_LINK_UP, rcvr, xEnv);
	            (((yPDP_sig_CSAPP_ABIHM_TRXH_LAPD_LINK_UP)S)->Param1) = rcvPtr;
	            break;
	         }
	    
	         case CSAPP_ABIHM_TRXH_LAPD_LINK_DOWN:
	         {
	            LOG_PRINT(INFO,"CSAPP_ABIHM_TRXH_LAPD_LINK_DOWN: rcvd from ABIHM");
	            if ((rcvr.LocalPId = (xLocalPIdNode)FindTrxhLocalPidByTei(rcvPtr)) == 0)
	            {
	               LOG_PRINT(INFO,"Failed to find Instance for Incoming request");   
	               DalocMsgBuf((I_Void *)rcvPtr) ;
	               return ;
	            }
	            S = xGetSignal( sig_CSAPP_ABIHM_TRXH_LAPD_LINK_DOWN, rcvr, xEnv);
	            (((yPDP_sig_CSAPP_ABIHM_TRXH_LAPD_LINK_DOWN)S)->Param1) = rcvPtr;
	            break;
	         }
	 
	         case CSAPP_ABIHM_TRXH_LINK_ESTAB_RESP:
	         {
	            LOG_PRINT(INFO,"Msg rcvd CSAPP_ABIHM_TRXH_LINK_ESTAB_RESP from ABIHM");
	            if ((rcvr.LocalPId = (xLocalPIdNode)FindTrxhLocalPidByTei(rcvPtr)) == 0)
	            {
	               LOG_PRINT(INFO,"Failed to find Instance for Incoming request");  
	               DalocMsgBuf((I_Void *)rcvPtr) ;
	               return ;
	            }
	            S = xGetSignal( sig_CSAPP_ABIHM_TRXH_LINK_ESTAB_RESP, rcvr, xEnv);
	            (((yPDP_sig_CSAPP_ABIHM_TRXH_LINK_ESTAB_RESP)S)->Param1) = rcvPtr;
	            break;
	         }
                    /*  Changes For ChannelActAck Retry Implementation : Start */
             case CSAPP_CPHM_TRXH_RETRY_EXHAUST_INDN:
                 {
                    LOG_PRINT(INFO,"Msg rcvd CSAPP_CPHM_TRXH_RETRY_EXHAUST_INDN from ABIHM");
                    if ((rcvr.LocalPId = (xLocalPIdNode)FindTrxhLocalPidByTei(rcvPtr)) == 0)
                    {
                       LOG_PRINT(INFO,"Failed to find Instance for Incoming request");
                       DalocMsgBuf((I_Void *)rcvPtr) ;
                       return ;
                    }
                    S = xGetSignal( sig_CSAPP_CPHM_TRXH_RETRY_EXHAUST_INDN, rcvr, xEnv);
                    (((yPDP_sig_CSAPP_CPHM_TRXH_RETRY_EXHAUST_INDN)S)->Param1) = rcvPtr;
                    break;
                 }
                 /*  Changes For ChannelActAck Retry Implementation : End */

                  /* R2.5.5 ():Start
                    Dated: 19-Aug-2010
                 */
            case CSAPP_ABIHM_TRXH_LINK_STATUS_RESP:
	         {
	            LOG_PRINT(INFO,"Msg rcvd CSAPP_ABIHM_TRXH_LINK_STATUS_RESP from ABIHM");
	            if ((rcvr.LocalPId = (xLocalPIdNode)FindTrxhLocalPidByTei(rcvPtr)) == 0)
	            {
	               LOG_PRINT(INFO,"Failed to find Instance for Incoming request");  
	               DalocMsgBuf((I_Void *)rcvPtr) ;
	               return ;
	            }
	            S = xGetSignal( sig_CSAPP_ABIHM_TRXH_LINK_STATUS_RESP, rcvr, xEnv);
	            (((yPDP_sig_CSAPP_ABIHM_TRXH_LINK_STATUS_RESP)S)->Param1) = rcvPtr;
	            break;
	         }
           
           /* R2.9 changes starts */
           case PSAPP_PSMSH_TRXH_BSC_SWITCHOVER_IND:
	         {
	           
             LOG_PRINT(INFO,"Msg rcvd PSAPP_PSMSH_TRXH_BSC_SWITCHOVER_IND from PSMSH");
             trxCount = ((PsappPsmshTrxhBscSwitchoverInd *)rcvPtr)->trxCount; 
             if(trxCount == 0)
             {
	              LOG_PRINT(INFO,"TrxCount in PSAPP_PSMSH_TRXH_BSC_SWITCHOVER_IND is = %d", trxCount);  
	              DalocMsgBuf((I_Void *)rcvPtr);
                return;
             }
             for(trxIndex = 0; trxIndex < trxCount; trxIndex++)  
             {
               trxPsRelStatusData = (TrxPsRelStatusData *)AlocMsgBuf(sizeof(TrxPsRelStatusData) + sizeof(SysHdr));
               memcpy(trxPsRelStatusData,&(((PsappPsmshTrxhBscSwitchoverInd *)rcvPtr)->trxPsRelStatus[trxIndex]), sizeof(TrxPsRelStatusData));
               LOG_PRINT(INFO,"trxPsRelStatusData->trxAppTei = %d",trxPsRelStatusData->trxAppTei);  
               LOG_PRINT(INFO,"trxPsRelStatusData->status = %d",trxPsRelStatusData->status);  
               if ((rcvr.LocalPId = (xLocalPIdNode)FindTrxhLocalPidByTeiForSwitchover(rcvPtr,trxIndex)) == 0)
               {
                 LOG_PRINT(INFO,"Failed to find Instance for Incoming request");  
                 DalocMsgBuf((I_Void *)rcvPtr);
                 return ;
               }
               S = xGetSignal( sig_PSAPP_PSMSH_TRXH_BSC_SWITCHOVER_IND, rcvr, xEnv);
               (((yPDP_sig_PSAPP_PSMSH_TRXH_BSC_SWITCHOVER_IND)S)->Param1) = ((I_Void *)(trxPsRelStatusData));
              LOG_PRINT(INFO,"Going to send signal to TAU for TEI[%d]", trxPsRelStatusData->trxAppTei);  
               SDL_Output( S xSigPrioPar(xDefaultPrioSignal), (xIdNode *)ZERO );
             }  
             DalocMsgBuf((I_Void *)rcvPtr);
             return;
	         }
          /* R2.9 changes ends */
           
	        /* R2.9 : Power Saving Feature - starts */ 
           case CSAPP_ABIHM_TRXH_BM_PWR_SAVING_CMD_ACK:
	         {
	            LOG_PRINT(INFO,"CSAPP_ABIHM_TRXH_BM_PWR_SAVING_ACK: rcvd from ABIHM");
	            if ((rcvr.LocalPId = (xLocalPIdNode)FindTrxhLocalPidByTei(rcvPtr)) == 0)
	            {
	                LOG_PRINT(INFO,"Failed to find Instance for Incoming request");
	                DalocMsgBuf((I_Void *)rcvPtr) ;
	                return ;
	            }
	            S = xGetSignal( sig_CSAPP_ABIHM_TRXH_BM_PWR_SAVING_CMD_ACK, rcvr, xEnv);
	            (((yPDP_sig_CSAPP_ABIHM_TRXH_BM_PWR_SAVING_CMD_ACK)S)->Param1) = rcvPtr;
	            break;
	         }
	
	         case CSAPP_ABIHM_TRXH_BM_PWR_SAVING_CMD_NACK:
	         {
	            LOG_PRINT(INFO,"CSAPP_ABIHM_TRXH_BM_PWR_SAVING_CMD_NACK: rcvd from ABIHM");
	            if ((rcvr.LocalPId = (xLocalPIdNode)FindTrxhLocalPidByTei(rcvPtr)) == 0)
	            {
	               LOG_PRINT(INFO,"Failed to find Instance for Incoming request");  
	               DalocMsgBuf((I_Void *)rcvPtr) ;
	               return ;
	            }
	            S = xGetSignal( sig_CSAPP_ABIHM_TRXH_BM_PWR_SAVING_CMD_NACK, rcvr, xEnv);
	            (((yPDP_sig_CSAPP_ABIHM_TRXH_BM_PWR_SAVING_CMD_NACK)S)->Param1) = rcvPtr;
	            break;
	         }
          /* R2.9 : Power Saving Feature - ends */
           
           case OAMS_RM_TRXHM_ACTIVE_REQ:
           {
              DalocMsgBuf((I_Void *)rcvPtr) ;
              LOG_PRINT(DEBUG,"(R2.5.5-ABIS HA) OAMS_RM_TRXHM_ACTIVE_REQ received.");
              handleAipToActive();
              buildNSendRmAipResp(OAMS_TRXHM_RM_ACTIVE_RESP); 
              LOG_PRINT(DEBUG,"(R2.5.5-ABIS HA) OAMS_TRXHM_RM_ACTIVE_RESP sent.");
              isActiveReqRmRcvd = ONE;
              break;
           }

      		#if BPM_PRESENT != 1
      		case BPM_SELFCARD_STATE_CHANGE :


					LOG_PRINT(DEBUG,"xInEnv : LOCKING SEMAPHORE");
		         if( SEM_WAIT(&gSemHandler) !=0)
		            LOG_PRINT(DEBUG,"SEM_WAIT failed ");
		
		         LOG_PRINT(DEBUG,"xInEnv : BPM_SELFCARD_STATE_CHANGE received ");
		         param = (struct sAisParam *)(rcvPtr+sizeof(SysHdr));
		         cardStateChangeHandler(param);
		         LOG_PRINT(DEBUG,"xInEnv : WAITING FOR SEMAPHORE....");
		         if( SEM_TIMED_WAIT(&gSemHandler) != SEMAPHORE_WAIT_COMPLETE)
		         {
		            LOG_PRINT(INFO,"Got Sempahore.. ");
		            LOG_PRINT(INFO,"calling bpmRespondToAis.. ");
		            bpmRespondToAis (param->invocation, OK);
		            LOG_PRINT(INFO,"Response sent to BPM.. ");
		            LOG_PRINT(INFO,"Releasing Sempahore.. ");
		            SEM_POST(&gSemHandler);
		         }
		         else
		         {
		            LOG_PRINT(INFO,"Semaphore Wait Timed Out(4secs).. ");
		            LOG_PRINT(INFO,"Releasing semaphore.. ");
		            SEM_POST(&gSemHandler);
		         }


         		DalocMsgBuf((I_Void *)rcvPtr) ;
         		return;
      		#endif
         	default:
            	LOG_PRINT(INFO,"Entered Default Case : xInEnv");
            	DalocMsgBuf((I_Void *)rcvPtr) ;
            	return ;

      	}
        /* Added for R2.5.5 (ABIS-HA) */ 
        
        if(ONE != isActiveReqRmRcvd)
        {
      	  SDL_Output( S xSigPrioPar(xDefaultPrioSignal), (xIdNode *)ZERO );
        }
        else
        {
           isActiveReqRmRcvd  = ZERO;
        }
		}
		else
		{
   	   if (msgType == BPM_SELFCARD_STATE_CHANGE)
       {
	      #if BPM_PRESENT != 1
				 LOG_PRINT(DEBUG,"xInEnv : LOCKING SEMAPHORE");
	         if( SEM_WAIT(&gSemHandler) !=0)
	            LOG_PRINT(DEBUG,"SEM_WAIT failed ");
	
	         LOG_PRINT(DEBUG,"xInEnv : BPM_SELFCARD_STATE_CHANGE received ");
	         param = (struct sAisParam *)(rcvPtr+sizeof(SysHdr));
	         cardStateChangeHandler(param);
	         LOG_PRINT(DEBUG,"xInEnv : WAITING FOR SEMAPHORE....");
	         if( SEM_TIMED_WAIT(&gSemHandler) != SEMAPHORE_WAIT_COMPLETE)
	         {
	            LOG_PRINT(INFO,"Got Sempahore.. ");
	            LOG_PRINT(INFO,"calling bpmRespondToAis.. ");
	            bpmRespondToAis (param->invocation, OK);
	            LOG_PRINT(INFO,"Response sent to BPM.. ");
	            LOG_PRINT(INFO,"Releasing Sempahore.. ");
	            SEM_POST(&gSemHandler);
	         }
	         else
	         {
	            LOG_PRINT(INFO,"Semaphore Wait Timed Out(4secs).. ");
	            LOG_PRINT(INFO,"Releasing semaphore.. ");
	            SEM_POST(&gSemHandler);
	         }

     	   	#endif
		    }
		    else
		    {
	          switch(msgType)
            {
                case OAMS_RM_TRXHM_AIP_REQ:
	              {
                  DalocMsgBuf((I_Void *)rcvPtr) ;
                  if(CARDSTATE_STANDBY == gCurrentCardState)
                  {
                      if(I_TRUE == gIsBpmCallBackRcvd)
                      {
                        LOG_PRINT(DEBUG,"(R2.5.5-ABIS HA) OAMS_RM_TRXHM_AIP_REQ received After BPM Callback (SBY->AIP)");
                        handleStandByToAip();
                        gIsDbUnlockedByRm   = I_FALSE;
                        gIsBpmCallBackRcvd  = I_FALSE;
                      }
                      else
                      {
                        LOG_PRINT(DEBUG,"(R2.5.5-ABIS HA) OAMS_RM_TRXHM_AIP_REQ received before BPM Callback (SBY->AIP)");
                        gIsBpmCallBackRcvd = I_FALSE;
                        gIsDbUnlockedByRm   = I_TRUE;
                      }
                  }
                  else
                  {
                      LOG_PRINT(DEBUG,"(R2.5.5-ABIS HA) OAMS_RM_TRXHM_AIP_REQ received when Card State \
                      is not StandBy State");
                      /*
                        AIP_REQ is received in other than STANDBY, just send AIP_RESP to RM.
                        Don't wait for Semaphore to be released.
                      */
                      buildNSendRmAipResp(OAMS_TRXHM_RM_AIP_RESP);
                  }
                  break;  
                }
                default:
                {
                    LOG_PRINT(DEBUG," Card not Active [gCurrentCardState=%d],Discard recvd msg",gCurrentCardState);
         	          DalocMsgBuf((I_Void *)rcvPtr) ;
                }
            } //End of Switch
        } //End of Else
		}
 }
#ifdef XTENV
   return SDL_Time_Lit((xint32)0,(xint32)0);
#endif

}
/*Changes merged from R2.9 Issue #31185 Gaurav Sinha*/



/**********************R3-BTS CHANGES START ********************************/



/******************************* Function  Header*****************************
 Function Name : prepareAlarmFromFailureEventReportForR3()
 Parameters    : 1.Abihm Trxh Failure event report structure pointer
		 2.Alarm Id
		 3.Alarm Level
	         4.Alarm String
 Return type   : I_Void
 Purpose       : This func handles Failure Event Report rcvd from Bic/Bts
 *****************************************************************************/
/* Added for R3_BTS */

I_Void prepareAlarmFromFailureEventReportForR3(CsappAbihmTrxhFailureEventReport *pRcvdMsg,
	I_U32 *pAlarmId,I_U32 *pAlarmLevel,I_U8 alarmString[])
{ 
	LOG_PRINT(INFO,"Entering[%s]",__func__);

	I_U16 probableCause = 0;
	I_U16 addInfoLen = 0;

	/* Copying from Msg received from ABIHM */
	*pAlarmLevel = pRcvdMsg->severityValue;
	probableCause = pRcvdMsg->probableCause.causeValue[0]; 

	LOG_PRINT(INFO,"CauseValue %x\n Addition Info Length %d\n" 
		"SeverityType Info Received in FailureEventReport is %d\n"
		,probableCause,pRcvdMsg->addInfo.len,*pAlarmLevel); 
	
	addInfoLen = pRcvdMsg->addInfo.len;
	memset(alarmString,0,100);
	if(addInfoLen <= 99)
	{
		memcpy(alarmString,pRcvdMsg->addInfo.addInfo,addInfoLen);
	}
	else
	{	
		memcpy(alarmString,pRcvdMsg->addInfo.addInfo,99);
	
	}
	strcat(alarmString, "\0");
	switch(probableCause)
	{
		case TRAFFIC_MANAGEMENT_LOCK :
		{        
			LOG_PRINT(INFO,"[%s:]FAILURE_EVENT_REPORT contain Alarm cause as "
				"TRAFFIC_MANAGEMENT_LOCK",__func__);
			*pAlarmId = EVENT_TRAFFIC_MANAGEMENT_LOCK;
			break;
		}
		case FAULT_MANAGEMENT_CONFIGURATION_AND_START :	
		{  
			LOG_PRINT(INFO,"[%s:]FAILURE_EVENT_REPORT contain Alarm cause as "
				"FAULT_MANAGEMENT_CONFIGURATION_AND_START",__func__);
			*pAlarmId = EVENT_FAULT_MANAGEMENT_CONFIGURATION_AND_START;
			break;
		}
		case SOFTWARE_PACKAGE_CONFIGURATION_AND_START :
		{  
			LOG_PRINT(INFO,"[%s:]FAILURE_EVENT_REPORT contain Alarm cause as "
				"SOFTWARE_PACKAGE_CONFIGURATION_AND_START",__func__);
			*pAlarmId = EVENT_SOFTWARE_PACKAGE_CONFIGURATION_AND_START;
			break;
		}
		case WATCHDOG :
		{  
			LOG_PRINT(INFO,"[%s:]FAILURE_EVENT_REPORT contain Alarm cause as"
				" WATCHDOG",__func__);
			*pAlarmId = EVENT_WATCHDOG;
			break;
		}
		case DSP_LOAD_START_STATUS :
		{  
			LOG_PRINT(INFO,"[%s:]FAILURE_EVENT_REPORT contain Alarm cause as" 
				"DSP_LOAD_START_STATUS",__func__);
			if(*pAlarmLevel == TRAP_SEVERITY_CRITICAL)
			{
				*pAlarmId = ALARM_DSP_LOAD_START_STATUS;
			}
			else	
			{
				*pAlarmId = ALARM_DSP_LOAD_START_STATUS_OK;
			}
			break;
		}
		case DSP_TRX_OVERLOAD :
		{  
			LOG_PRINT(INFO,"[%s:]FAILURE_EVENT_REPORT contain Alarm cause"
				" as DSP_TRX_OVERLOAD",__func__);
			*pAlarmId = EVENT_DSP_TRX_OVERLOAD;
			break;
		}
		case RTM_TEMPERATURE :
		{ 
			LOG_PRINT(INFO,"[%s:]FAILURE_EVENT_REPORT contain Alarm cause"
				" as RTM_TEMPERATURE",__func__);
			if(*pAlarmLevel == TRAP_SEVERITY_WARNING)
			{
				*pAlarmId = EVENT_RTM_TEMPERATURE;
		}
			else if (*pAlarmLevel == TRAP_SEVERITY_CRITICAL)
			{
				*pAlarmId = ALARM_RTM_TEMPERATURE;
			}
			else 
			{
				*pAlarmId = ALARM_RTM_TEMPERATURE_OK;
			}
			break;
		}
		case CLOCK_REFERENCE :
		{
			LOG_PRINT(INFO,"[%s:]FAILURE_EVENT_REPORT contain Alarm cause"
				" as CLOCK_REFERENCE",__func__);
			if(*pAlarmLevel == TRAP_SEVERITY_WARNING)
			{
				*pAlarmId = ALARM_CLOCK_REFERENCE;
			}
			else
			{
				*pAlarmId = ALARM_CLOCK_REFERENCE_OK;
			}
			break;
		}
		case CLOCK_FREQUENCY :
		{
			LOG_PRINT(INFO,"[%s:]FAILURE_EVENT_REPORT contain Alarm cause"
				" as CLOCK_FREQUENCY",__func__);
			if(*pAlarmLevel == TRAP_SEVERITY_CRITICAL)
			{
				*pAlarmId = ALARM_CLOCK_FREQUENCY;
			}
			else
			{
				*pAlarmId = ALARM_CLOCK_FREQUENCY_OK;
			}
			break;
		}
		case FORWARD_POWER :
		{
			LOG_PRINT(INFO,"[%s:]FAILURE_EVENT_REPORT contain Alarm cause"
				" as FORWARD_POWER",__func__);
			if(*pAlarmLevel == TRAP_SEVERITY_WARNING)
			{
				*pAlarmId = ALARM_FORWARD_POWER;
			}
			else
			{
				*pAlarmId = ALARM_FORWARD_POWER_OK;
			}
			break;
		}
		case RADIO_CONFIGURATION_AND_START :
		{
			LOG_PRINT(INFO,"[%s:]FAILURE_EVENT_REPORT contain Alarm cause"
				" as RADIO_CONFIGURATION_AND_START",__func__);
			*pAlarmId = EVENT_RADIO_CONFIGURATION_AND_START;
			break;
		}
		case DSP_SW_EXECUTION :
		{
			LOG_PRINT(INFO,"[%s:]FAILURE_EVENT_REPORT contain Alarm cause"
				" as DSP_SW_EXECUTION",__func__);
			*pAlarmId = EVENT_DSP_SW_EXECUTION;
			break;
		}
		case PACKET_CONTROL :
		{
			LOG_PRINT(INFO,"[%s:]FAILURE_EVENT_REPORT contain Alarm cause"
				" as FORWARD_POWER",__func__);
			*pAlarmId = EVENT_PACKET_CONTROL;
			break;
		}
		case RTM_IDENTITY :	
		{
			LOG_PRINT(INFO,"[%s:]FAILURE_EVENT_REPORT contain Alarm cause"
				" as FORWARD_POWER",__func__);
			*pAlarmId = EVENT_RTM_IDENTITY;
			break;
		}
		case RTM_CALIBRATION :
		{
			LOG_PRINT(INFO,"[%s:]FAILURE_EVENT_REPORT contain Alarm cause"
				" as FORWARD_POWER",__func__);
			*pAlarmId = EVENT_RTM_CALIBRATION;
			break;
		}
		case RTM_FREQUENCY_BAND :
		{
			LOG_PRINT(INFO,"[%s:]FAILURE_EVENT_REPORT contain Alarm cause"
				" as FORWARD_POWER",__func__);
			*pAlarmId = EVENT_RTM_FREQUENCY_BAND;
			break;
		}
		case EDMA_INTERRUPT_RETRIEVE_TIMEOUT :
		{
			LOG_PRINT(INFO,"[%s:]FAILURE_EVENT_REPORT contain Alarm cause"
				" as FORWARD_POWER",__func__);
			*pAlarmId = EVENT_EDMA_INTERRUPT_RETRIEVE_TIMEOUT;
			break;
		}
		case TX_PLL_LOCK :
		{
			LOG_PRINT(INFO,"[%s:]FAILURE_EVENT_REPORT contain Alarm cause"
				" as FORWARD_POWER",__func__);
			*pAlarmId = EVENT_TX_PLL_LOCK;
			break;
		}
		case RX_PLL_LOCK :
		{
			LOG_PRINT(INFO,"[%s:]FAILURE_EVENT_REPORT contain Alarm cause"
				" as FORWARD_POWER",__func__);
			*pAlarmId = EVENT_RX_PLL_LOCK;
			break;
		}
		case VCP2_TIMEOUT :
		{
			LOG_PRINT(INFO,"[%s:]FAILURE_EVENT_REPORT contain Alarm cause"
				" as FORWARD_POWER",__func__);
			*pAlarmId = EVENT_VCP2_TIMEOUT;
			break;
		}
		case CORE_TS_BOUNDARY :
		{
			LOG_PRINT(INFO,"[%s:]FAILURE_EVENT_REPORT contain Alarm cause"
				" as FORWARD_POWER",__func__);
			*pAlarmId = EVENT_CORE_TS_BOUNDARY;
			break;
		}
		case CP_PA_TEMPERATURE :
		{
			LOG_PRINT(INFO,"[%s:]FAILURE_EVENT_REPORT contain Alarm cause"
				" as CP_PA_TEMPERATURE",__func__);
			if(*pAlarmLevel == TRAP_SEVERITY_WARNING)
			{
				*pAlarmId = EVENT_PA_TEMPERATURE;	
			}
			else if (*pAlarmLevel == TRAP_SEVERITY_CRITICAL)
			{
				*pAlarmId = ALARM_PA_TEMPERATURE;
			}
			else 
			{
				*pAlarmId = ALARM_PA_TEMPERATURE_OK;
			}
			break;
		}
		case PA_CURRENT:
		{
			LOG_PRINT(INFO,"[%s:]FAILURE_EVENT_REPORT contain Alarm cause"
				" as PA_CURRENT",__func__);
			*pAlarmId = EVENT_PA_CURRENT;	
			break;
		}
		case PA_IDENTITY:
		{
			LOG_PRINT(INFO,"[%s:]FAILURE_EVENT_REPORT contain Alarm cause"
				" as PA_IDENTITY",__func__);
			*pAlarmId = EVENT_PA_IDENTITY;
			break;	
		}
		case PA_CALIBRATION:
		{
			LOG_PRINT(INFO,"[%s:]FAILURE_EVENT_REPORT contain Alarm cause"
				" as PA_CALIBRATION",__func__);	
			*pAlarmId = EVENT_PA_CALIBRATION;
			break;
		}

		default :	
		{
			LOG_PRINT(INFO,"[%s:]FAILURE_EVENT_REPORT contain Unhandled"
				" Probable cause[%x]",__func__, probableCause);		
			break;
		}	
	}
	LOG_PRINT(INFO,"Exiting [%s]",__func__);
}

/**********************R3-BTS CHANGES END ********************************/

