
/* SKELETON for env functions */
/* Program generated by Cadvanced 4.3.0.0.14276 */
#define XSCT_CADVANCED
#define XUSE_SIGNAL_NUMBERS

#ifndef XENV
#define XENV
#endif

#define C_TRANSLATOR_4_1
#include "scttypes.h"
#ifdef XUSE_SIGNAL_NUMBERS
#include "Gbh.hs"
#endif
#ifdef XENV_INC
#include XENV_INC
#endif
#include "Gbh.ifc"
#define DB_FAILURE_EXIT_CODE 0
#define SELF_ENTITY_NAME "GBH" 
#include<pthread.h>
#include "bpmxxx_platformLib.h"
#include "bpmxxx_OAM_commonDef.h"
#include "bpmxxx_commonDef.h"
#include "oamsxxx_semaphore.h" 
#include "oams_sig_handler.h" 
I_S32 gCurrentCardState = CARDSTATE_INIT;

#ifndef XNOGLOBALNODENUMBER
/*---+---------------------------------------------------------------
     xGlobalNodeNumber  extern
-------------------------------------------------------------------*/
#ifndef XENV_NODENUMBER
#define XENV_NODENUMBER return 1;
#endif


sem_t gSemHandler;
I_S32  selfEntIdG = ENT_OAMS_GBH; 

int xGlobalNodeNumber(void)
{
  /* Assign a unique global system Id to each SDL system in a cluster of systems. */
  return ENT_OAMS_GBH ; 
}
#endif

  /** 
  * Interface with Base Platform Module (BPM)
  * Note1: BPM is an optional feature in the system.
  * All code pertaining to BPM interface should be under a compile time
  * flag.
  */
void GbhBpmCallbackFunc (struct sAisParam *param);

#if BPM_PRESENT != 1

   #define RegisterGbhWithBpm() bpmGetComponentReg(ENT_OAMS_GBH_STUB,&GbhBpmCallbackFunc); 
   /* Changes for HA Start */
   #define bpmRespondToAis(a,b)
   /* Changes for HA End */
   #warning "BPM support not compiled"

#else

void RegisterGbhWithBpm(void)
{
   bpmGetComponentRegister (GbhBpmCallbackFunc, APPID_OAMS_GBH);
   bpmComponentConfigure ();
}
#endif

 /* BPM_PRESENT */

I_U8* getCardStateNameStr(I_S32 cardState)
{
  I_U8 *pCardStateNameStr = "BSC_APP_CARDSTATE_INVALID" ;
  switch(cardState)
  {
    case CARDSTATE_INIT:
      pCardStateNameStr = "CARDSTATE_INIT";
      break;
    case CARDSTATE_PLATFORM_INS:
      pCardStateNameStr = "CARDSTATE_PLATFORM_INS";
      break;
    case CARDSTATE_IN_SERVICE:
      pCardStateNameStr = "CARDSTATE_IN_SERVICE";
      break;
    case CARDSTATE_ACTIVE:
      pCardStateNameStr = "CARDSTATE_ACTIVE";
      break;
    case CARDSTATE_STANDBY:
      pCardStateNameStr = "CARDSTATE_STANDBY";
      break;
    case CARDSTATE_OUT_OF_SERVICE:
      pCardStateNameStr = "CARDSTATE_OUT_OF_SERVICE";
      break;
    case CARDSTATE_RECOVERY:
      pCardStateNameStr = "CARDSTATE_RECOVERY";
      break;
    case CARDSTATE_FAIL:
      pCardStateNameStr = "CARDSTATE_FAIL";
      break;
    case CARDSTATE_TEST:
      pCardStateNameStr = "CARDSTATE_TEST";
      break;
    case CARDSTATE_ABSENT:
      pCardStateNameStr = "CARDSTATE_ABSENT";
      break;
    case CARDSTATE_ACTIVE_IN_PROGRESS:
      pCardStateNameStr = "CARDSTATE_ACTIVE_IN_PROGRESS";
      break;
    case CARDSTATE_UPGRADE:
      pCardStateNameStr = "CARDSTATE_UPGRADE";
      break;
    case CARDSTATE_RESTART:
      pCardStateNameStr = "CARDSTATE_RESTART";
      break;
    default:
      break;
  }
  return (pCardStateNameStr);
}

I_U32 sendCntxtDataToModel()
{
  LOG_PRINT(DEBUG,"in func sendCntxtDataToModel");
  xSignalNode     S;
  SDL_Pid         rcvr;
  I_U32           lclPidPtr = INVALID_LCL_PID_PTR ;
  I_S32           instId = ZERO;
  I_U16           instCount = ZERO;
  rcvr.GlobalNodeNr = (I_S32)selfEntIdG;
  I_S32 dbCallResult;
  I_U32 numRows;
  I_U16 dataSize;
  GbhCtxtTableApi *gbhCtxtbTable;
  GbhRedCtxt *gbhRedCtxt;
  I_U32 refId1,refId2;
  I_S32           index;
  /* Changes for HotStb start here     */
  //read db for context
  //getall new instance as the data is  

  dbCallResult = getallGbhCtxtTable(&(gbhCtxtbTable),&(numRows),&(dataSize));
  if (dbCallResult != DBLIB_SUCCESS)
  {
    LOG_PRINT(CRITICAL,"Failed: db call for GbhCtxtTable, error code = [%d]",dbCallResult);
    return BSS_FAILURE; 
  }
  else
  {
    LOG_PRINT(DEBUG,"db call for GbhCtxtTable success");
    //send message allocate new instances 
    for(instCount=0;instCount<numRows;instCount++)
    {
      gbhRedCtxt = AlocOrdBuf(sizeof(GbhRedCtxt));
      memcpy(gbhRedCtxt, (GbhCtxtTableApi *)( gbhCtxtbTable + sizeof(GbhCtxtTableApi)*instCount),sizeof(GbhRedCtxt));   
      LOG_PRINT(INFO,"gbhRedCtxt: gbIfIndex = %d, nsvcEnabled = %d, sigBvcResetFromSgsn = %d, cblNegotiated = %d, isCblChanged = %d",gbhRedCtxt->gbIfIndex,gbhRedCtxt->nsvcEnabled,gbhRedCtxt->sigBvcResetFromSgsn,gbhRedCtxt->cblNegotiated,gbhRedCtxt->isCblChanged);
      LOG_PRINT(INFO,"(BPM)Sending signal GBH_INT_STANDBY_TO_AIP to Model");
      // send message allocate new instances 
      //  send the data and move to the state 
      S = xGetSignal( sig_GBH_INT_STANDBY_TO_AIP, xNotDefPId, xEnv);
      ((yPDP_sig_GBH_INT_STANDBY_TO_AIP)S)->Param1 = gbhRedCtxt; 
      SDL_Output( S xSigPrioPar(xDefaultPrioSignal), (xIdNode *)0 );
    }//end for loop
    free(gbhCtxtbTable);

  }//else db call is success       

  /* Changes for HotStb end here     */
  return BSS_SUCCESS; 
}

/********************************************************************/
/* Changes for HA Start */
I_Void cardStateChangeHandler(struct sAisParam *param)
{
  xSignalNode     S;
  SDL_Pid         rcvr;
  I_S32           result = ZERO;

  rcvr.GlobalNodeNr = (I_S32)selfEntIdG;
  rcvr.LocalPId = (xLocalPIdNode)0;
  LOG_PRINT(INFO,"BPM_SELFCARD_STATE_CHANGE recd with CARD_STATE = %d", param->cardState) ;
  LOG_PRINT(INFO,"(BPM)BPM_SELFCARD_STATE_CHANGE received. Current State=[%s], Received State=[%s]",getCardStateNameStr(gCurrentCardState),getCardStateNameStr(param->cardState)) ;

  GbInterfaceTableApi *pGbInterfaceTable = NULL;
  I_U16 dbSize;
  I_U16 transportType;
  I_U32 dbCount;
  I_S32 dbResult;

  /* Init -> InService */
  if ( (param->cardState == CARDSTATE_IN_SERVICE) && (gCurrentCardState == CARDSTATE_INIT) )
  {
    LOG_PRINT(DEBUG,"Connecting with DB Server...");
    result = dbConnect();
    if ( result != DBLIB_SUCCESS )
    {
      LOG_PRINT(CRITICAL,"GBHandler: Unable to Connect itself with DBServer:Exiting");
      return;
    }
    LOG_PRINT(DEBUG,"Successfully Connected to DB Server.");
    LOG_PRINT(INFO,"Moving from INIT to INSERVICE.. ");

    gCurrentCardState = CARDSTATE_IN_SERVICE;
    LOG_PRINT(INFO,"(BPM)Releasing semaphore.. ");
    SEM_POST(&gSemHandler);
  }

  /* Active -> InService*/
  else if ( (param->cardState == CARDSTATE_IN_SERVICE) && ( gCurrentCardState == CARDSTATE_ACTIVE) )
  {

    LOG_PRINT(INFO,"Sending signal GBH_INT_SELFCARD_STATE_CHANGE to Model");
    S = xGetSignal( sig_GBH_INT_SELFCARD_STATE_CHANGE, xNotDefPId, xEnv);
    SDL_Output( S xSigPrioPar(xDefaultPrioSignal), (xIdNode *)0 );
    LOG_PRINT(INFO,"Moving from ACTIVE to INSERVICE.. ");
    gCurrentCardState = CARDSTATE_IN_SERVICE;
  }

  /* InService -> StandBy*/
  else if ( (param->cardState == CARDSTATE_STANDBY) && (gCurrentCardState == CARDSTATE_IN_SERVICE) )
  {
    gCurrentCardState = CARDSTATE_STANDBY;
    LOG_PRINT(INFO,"Moving from INSERVICE to StandBy.. ");
    LOG_PRINT(INFO,"(BPM)Releasing semaphore.. ");
    SEM_POST(&gSemHandler);
  }

  /* InService -> ActiveInProgress*/
  else if ( (param->cardState == CARDSTATE_ACTIVE_IN_PROGRESS) && (gCurrentCardState == CARDSTATE_IN_SERVICE) )
  {
    gCurrentCardState = CARDSTATE_ACTIVE_IN_PROGRESS;
    LOG_PRINT(INFO,"Moving from INSERVICE to ActiveInProgress.. ");
    LOG_PRINT(INFO,"(BPM)Releasing semaphore.. ");
    SEM_POST(&gSemHandler);
  }
  /* StandBy -> ActiveInProgress*/
  else if ( (param->cardState == CARDSTATE_ACTIVE_IN_PROGRESS) && ( gCurrentCardState == CARDSTATE_STANDBY) )
  {
    /* Changes for HotStb start here     */
    // read db for context
    // for fr configuration do not send cntxtdata to Model
    // read from db the gbtype 
    dbResult = getallGbInterfaceTable(&pGbInterfaceTable,&dbCount,&dbSize);
    if(CLIB_SUCCESS == dbResult)
    {
      transportType = pGbInterfaceTable->transportType;
      LOG_PRINT(DEBUG, "(GBH):  transportType value received from DB : %d", transportType);
      free(pGbInterfaceTable);
    }
    else
    {
      LOG_PRINT(MAJOR, "(GBH): DB call getallGbInterfaceTable failed..   ");
      LOG_PRINT(INFO, "(GBH): Exiting Function initialization.. ");
    } 
    if (PCU_GB_TRANSPORT_TYPE_FR == transportType)
    {
      result = updateGbInterfaceOprState(DISABLED);
      if(CLIB_SUCCESS != dbResult)
      {
        LOG_PRINT(DEBUG, "(GBH):  updateGbInterfaceOprState(DISABLED) failed  ");
      }
    }
    else 
    {  
      sendCntxtDataToModel();
    } 
    gCurrentCardState = CARDSTATE_ACTIVE_IN_PROGRESS;
    LOG_PRINT(INFO,"Moving from StandBy to ActiveInProgress.. ");
    LOG_PRINT(INFO,"(BPM)Releasing semaphore.. ");
    SEM_POST(&gSemHandler);
  }

  /* ActiveInProgress -> Active */
  else if ( (param->cardState == CARDSTATE_ACTIVE) && (gCurrentCardState == CARDSTATE_ACTIVE_IN_PROGRESS) )
  {
    LOG_PRINT(INFO,"Moving from ActiveInProgress to ACTIVE.. ");
    gCurrentCardState = CARDSTATE_ACTIVE;
    LOG_PRINT(INFO,"(BPM)Releasing semaphore.. ");
    SEM_POST(&gSemHandler);
  }

  /* StandBy -> Recovery */
  else if ( (param->cardState == CARDSTATE_RECOVERY) && (gCurrentCardState == CARDSTATE_STANDBY) )
  {
    gCurrentCardState = CARDSTATE_RECOVERY;
    LOG_PRINT(INFO,"Moving from StandBy to Recovery.. ");
    LOG_PRINT(INFO,"(BPM)Releasing semaphore.. ");
    SEM_POST(&gSemHandler);
  }

  /* STANDBY -> OUTOFSERVICE */
  else if ( (param->cardState == CARDSTATE_OUT_OF_SERVICE) && (gCurrentCardState == CARDSTATE_STANDBY) )
  {
    gCurrentCardState = CARDSTATE_OUT_OF_SERVICE;
    LOG_PRINT(INFO,"(BPM)Moving from STANDBY to OUTOFSERVICE.. ");
    LOG_PRINT(INFO,"(BPM)Releasing semaphore.. ");
    SEM_POST(&gSemHandler);
  }
  /* Active -> Recovery */
  else if ( (param->cardState == CARDSTATE_RECOVERY) && (gCurrentCardState == CARDSTATE_ACTIVE) )
  {
    S = xGetSignal( sig_GBH_INT_SELFCARD_STATE_CHANGE, xNotDefPId, xEnv);
    SDL_Output( S xSigPrioPar(xDefaultPrioSignal), (xIdNode *)0 );
    LOG_PRINT(INFO,"Moving from Active to Recovery.. ");
    gCurrentCardState = CARDSTATE_RECOVERY;
  }
  /* Recovery -> InService */
  else if ( (param->cardState == CARDSTATE_IN_SERVICE) && (gCurrentCardState == CARDSTATE_RECOVERY) )
  {
    /* DeRegister with DB */
    if ((result = dbDestroy()) != DBLIB_SUCCESS)
    {
      LOG_PRINT(CRITICAL,"clib_destroy failed for GBH (Error = %d)",result);
      return;
    }

    LOG_PRINT(DEBUG,"Registering with DB Server...");
    result = dbConnect();
    if ( result != DBLIB_SUCCESS )
    {
      LOG_PRINT(CRITICAL,"BPM: Unable to Register itself with DBServer:Exiting");
      return;
    }
    LOG_PRINT(DEBUG,"Successfully Registered with DB Server.");
    gCurrentCardState = CARDSTATE_IN_SERVICE;
    LOG_PRINT(INFO,"Moving to Recovery to InService.. ");
    LOG_PRINT(INFO,"(BPM)Releasing semaphore.. ");
    SEM_POST(&gSemHandler);
  }
  /* OUTOFSERVICE -> INSERVICE */
  else if ( (param->cardState == CARDSTATE_IN_SERVICE) && (gCurrentCardState == CARDSTATE_OUT_OF_SERVICE) )
  {
    gCurrentCardState = CARDSTATE_IN_SERVICE;
    /* DeRegister with DB */
    if ((result = dbDestroy()) != DBLIB_SUCCESS)
    {
      LOG_PRINT(MAJOR,"(BPM)dbDestroy failed for Module (Error = %d)",result);
      /* Need to re-confirm what to do in such case */
    }

    LOG_PRINT(DEBUG,"(BPM)Registering with DB Server...");
    result = dbConnect();
    if ( result != DBLIB_SUCCESS )
    {
      LOG_PRINT(CRITICAL,"(BPM)Unable to Register itself with DBServer:Exiting");
      exit(DB_FAILURE_EXIT_CODE);
    }
    LOG_PRINT(DEBUG,"(BPM)Successfully Registered with DB Server.");
    LOG_PRINT(INFO,"(BPM)Moving from OUTOFSERVICE to INSERVICE.. ");
    LOG_PRINT(INFO,"(BPM)Releasing semaphore.. ");
    SEM_POST(&gSemHandler);
  }
  /* ACTIVE -> OUTOFSERVICE */
  else if ( (param->cardState == CARDSTATE_OUT_OF_SERVICE) && (gCurrentCardState == CARDSTATE_ACTIVE) )
  {


    gCurrentCardState = CARDSTATE_OUT_OF_SERVICE;
    LOG_PRINT(INFO,"Sending signal GBH_INT_SELFCARD_STATE_CHANGE to Model");
    S = xGetSignal( sig_GBH_INT_SELFCARD_STATE_CHANGE, xNotDefPId, xEnv);
    SDL_Output( S xSigPrioPar(xDefaultPrioSignal), (xIdNode *)0 );
    LOG_PRINT(INFO,"Moving from ACTIVE to OUTOFSERVICE.. ");


  }   
  else
  {
    LOG_PRINT(INFO,"cardStateChangeHandler: Unexpected state received  = %d",param->cardState) ;
    LOG_PRINT(INFO,"(BPM)Releasing semaphore.. ");
    SEM_POST(&gSemHandler);
  }
}

void GbhBpmCallbackFunc (struct sAisParam *param)
{
   switch (param->messageId)
   {
      case BPM_HEALTHCHECK_MESSAGE:
           bpmRespondToAis (param->invocation, OK);
           break;

      case BPM_SELFCARD_STATE_CHANGE:
           /* Changes for HA Start*/
           cardStateChangeHandler(param);
           LOG_PRINT(INFO,"calling bpmRespondToAis.. ");
           bpmRespondToAis (param->invocation, OK);
           LOG_PRINT(INFO,"Moving to CARD_STATE: [%d]",param->cardState);
           /* Changes for HA End*/
           break;

      case BPM_PEERCARD_STATE_CHANGE:
           LOG_PRINT(INFO, "(GBH): (Env):BPM_PEERCARD_STATE_CHANGE recd, No Action Taken");
           bpmRespondToAis (param->invocation, OK);
           break;

      case BPM_MSG_ACK_PEER_HEALTH_BAD:
           LOG_PRINT(INFO, "(GBH): (Env):BPM_MSG_ACK_PEER_HEALTH_BAD recd, Not Expected");
           break;

      case BPM_MSG_ACK_CONFIGURE:
           LOG_PRINT(INFO, "(GBH): (Env):BPM_MSG_ACK_CONFIGURE recd");
           break;

      case BPM_MSG_ACK_CONFIGURE_RESET:
           LOG_PRINT(INFO, "(GBH): (Env):BPM_MSG_ACK_CONFIGURE_RESET recd, No Action Taken");
           break;

      case BPM_SHUTDOWN:
           LOG_PRINT(INFO, "(GBH): (Env):BPM_SHUTDOWN recd, Exiting");
           exit (1);
           break;

      default:
           LOG_PRINT(MAJOR, "(GBH): (Env):Unexpected msg from BPM: %d", param->messageId);
           break;
   }
}


#ifndef XNOINITENV
/*---+---------------------------------------------------------------
     xInitEnv  extern
-------------------------------------------------------------------*/
#ifndef XENV_INIT
#define XENV_INIT
#endif

void xInitEnv(void)
{
  /* Code to initialize your SDL-system environment may be inserted here */
  I_S32         retVal;
  I_U8          appId;
  I_U8          *appName;
  I_S32         result;

#ifdef XTRACE
  xPrintString("(GBH): (Env):xInitEnv called\n");
#endif

  LOG_PRINT(INFO,"(GBH): (Env):Registering with BPM....\n");
  //RegisterGbhWithBpm(); CLOUD 
  LOG_PRINT(INFO,"(GBH): (Env):Registering with IPC FramWork...\n");
  if (RegisterWithIpcFrmwrk(selfEntIdG, (I_S8 *)"ENT_OAMS_GBH") < 0)
  {
    LOG_PRINT(CRITICAL,"(GBH): (Env):Unable to Register itself with IPC FrameWork : Exiting");
    exit(0) ;
  }
  RegisterGbhWithBpm();

  LOG_PRINT(INFO,"CurrentCardState at initialization: [%d]", gCurrentCardState) ;
  REGISTER_SIGNAL_HANDLER(); 
   LOG_PRINT(INFO,"xInitEnv: registered signal handler");

#ifdef XTRACE
  xPrintString("xInitEnv called\n");
#endif
}
#endif


#ifndef XNOCLOSEENV
/*---+---------------------------------------------------------------
     xCloseEnv  extern
-------------------------------------------------------------------*/
#ifndef XENV_CLOSE
#define XENV_CLOSE
#endif

void xCloseEnv(void)
{
  /* Code to bring down the environment in a controlled manner
     may be inserted here. */
  I_S32 retVal;

  /* DeRegister with DB */
  if ((retVal = dbDestroy()) != DBLIB_SUCCESS)
  {
    LOG_PRINT(CRITICAL,"(GBH): (Env):clib_destroy failed for GBH (Error = %d)",retVal);
    exit(0);
  }/*if retVal */
#ifdef XTRACE
  xPrintString("xCloseEnv called\n");
#endif
}
#endif


/*---+---------------------------------------------------------------
     Macros for xOutEnv
-------------------------------------------------------------------*/
#ifndef OUT_LOCAL_VARIABLES
#define OUT_LOCAL_VARIABLES
#endif

#ifndef IF_OUT_SIGNAL
#define IF_OUT_SIGNAL(SIGNAL_NAME, SIGNAL_NAME_STRING) \
  if (((*SignalOut)->NameNode) == SIGNAL_NAME) {
#define END_IF_OUT_SIGNAL(SIGNAL_NAME, SIGNAL_NAME_STRING) \
  }
#endif

#ifndef OUT_SIGNAL1
#define OUT_SIGNAL1(SIGNAL_NAME, SIGNAL_NAME_STRING)
#endif

#ifndef OUT_SIGNAL2
#define OUT_SIGNAL2(SIGNAL_NAME, SIGNAL_NAME_STRING)
#endif

#ifndef XENV_ENC
#define XENV_ENC(stmt) stmt
#endif

#ifndef XENV_OUT_START
#define XENV_OUT_START
#endif

#ifndef RELEASE_SIGNAL
#define RELEASE_SIGNAL   xReleaseSignal(SignalOut); return;
#endif


/*---+---------------------------------------------------------------
     xOutEnv  extern
-------------------------------------------------------------------*/
extern void xOutEnv( xSignalNode *SignalOut
#ifdef XPATH_INFO_IN_ENV_FUNC
  , xChannelIdNode Port
#endif
 )
{
   I_Void  *sndPtr     = NULL;
   I_S32   msgSize     = 0;
   I_U16   msgType     = 0;

#ifdef XTRACE
#ifdef XIDNAMES
  char  Temp[100];
  sprintf(Temp, "(GBH): (Env):  xOutEnv:  %s has been received by env\n",
  (*SignalOut)->NameNode->Name );
  xPrintString(Temp);
#else
  xPrintString("(GBH): (Env): xOutEnv:  One signal has been received by env\n");
#endif
#endif

  /* Signals going to the env via the port pPort */
switch((*SignalOut)->NameNode->SignalNumber)
   {
       case SN_OAMS_GBH_PSCH_SIG_BVC_RESET_IND:
       {
          LOG_PRINT(DEBUG,"(GBH): (Env):  xOutEnv:  SN_OAMS_GBH_PSCH_SIG_BVC_RESET_IND has been received by env");
          sndPtr = ((yPDP_sig_OAMS_GBH_PSCH_SIG_BVC_RESET_IND)(*SignalOut))->Param1;
          msgSize = ((yPDP_sig_OAMS_GBH_PSCH_SIG_BVC_RESET_IND)(*SignalOut))->Param2;
          if (sndPtr == NULL)
          {
             LOG_PRINT(INFO,"(GBH): (Env):Received NULL pointer from Module, Returning without Sending to FRAMEWORK");
             xReleaseSignal(SignalOut);
             return ;
          }
          break;
       }

       case SN_OAMS_GBH_PSCH_GB_DOWN_IND:
       {
          LOG_PRINT(DEBUG,"(GBH): (Env):  xOutEnv:  SN_OAMS_GBH_PSCH_GB_DOWN_IND has been received by env");
          sndPtr = ((yPDP_sig_OAMS_GBH_PSCH_GB_DOWN_IND)(*SignalOut))->Param1;
          msgSize = ((yPDP_sig_OAMS_GBH_PSCH_GB_DOWN_IND)(*SignalOut))->Param2;
          if (sndPtr == NULL)
          {
             LOG_PRINT(INFO,"(GBH): (Env):Received NULL pointer from Module, Returning without Sending to FRAMEWORK");
             xReleaseSignal(SignalOut);
             return ;
          }
          break;
       }

       case SN_OAMS_GBH_BSSGP_SIG_BVC_RESET_ACK:
       {
          LOG_PRINT(DEBUG,"(GBH): (Env):  xOutEnv:  SN_OAMS_GBH_BSSGP_SIG_BVC_RESET_ACK has been received by env");
          sndPtr = ((yPDP_sig_OAMS_GBH_BSSGP_SIG_BVC_RESET_ACK)(*SignalOut))->Param1;
          msgSize = ((yPDP_sig_OAMS_GBH_BSSGP_SIG_BVC_RESET_ACK)(*SignalOut))->Param2;
          if (sndPtr == NULL)
          {
             LOG_PRINT(INFO,"(GBH): (Env):Received NULL pointer from Module, Returning without Sending to FRAMEWORK");
             xReleaseSignal(SignalOut);
             return ;
          }
          break;
       }

       case SN_OAMS_GBH_BSSGP_SIG_BVC_RESET:
       {
          LOG_PRINT(DEBUG,"(GBH): (Env):  xOutEnv:  SN_OAMS_GBH_BSSGP_SIG_BVC_RESET has been received by env");
          sndPtr = ((yPDP_sig_OAMS_GBH_BSSGP_SIG_BVC_RESET)(*SignalOut))->Param1;
          msgSize = ((yPDP_sig_OAMS_GBH_BSSGP_SIG_BVC_RESET)(*SignalOut))->Param2;
          if (sndPtr == NULL)
          {
             LOG_PRINT(INFO,"(GBH): (Env):Received NULL pointer from Module, Returning without Sending to FRAMEWORK");
             xReleaseSignal(SignalOut);
             return ;
          }
          break;
       }


       case SN_OAMS_GBH_CFG_ALARM_IND:
       {
          LOG_PRINT(DEBUG,"(GBH): (Env):  xOutEnv:  SN_OAMS_GBH_CFG_ALARM_IND has been received by env");
          sndPtr = ((yPDP_sig_OAMS_GBH_CFG_ALARM_IND)(*SignalOut))->Param1;
          msgSize = ((yPDP_sig_OAMS_GBH_CFG_ALARM_IND)(*SignalOut))->Param2;
          if (sndPtr == NULL)
          {
             LOG_PRINT(INFO,"(GBH): (Env):Received NULL pointer from Module, Returning without Sending to FRAMEWORK");
             xReleaseSignal(SignalOut);
             return ;
          }
          break;
       }

       case SN_GBH_INT_SELFCARD_STATE_CHANGE_RESP:
       {
          LOG_PRINT(DEBUG,"(GBH): (Env):  xOutEnv:  SN_GBH_INT_SELFCARD_STATE_CHANGE_RESP has been received by env");
          return;
       }

       default:
       {
          LOG_PRINT(INFO,"(GBH): (Env):Unknown signal received in xOutEnv");
          xReleaseSignal(SignalOut);
          return ;
       }
   }

   LOG_PRINT(INFO,"(GBH): (Env):OUT OF SWITCH XOUT::ENV \n ");
   if (SendMsg(sndPtr,MSG_ORD_PRIO,msgSize) == SND_FAIL)
   {
       LOG_PRINT(CRITICAL,"(GBH): (Env):MESSAGE SENDING FAILED \n");
   }
   else
   {
       LOG_PRINT(INFO,"(GBH): (Env):Successfully sent message out \n");
   }
       xReleaseSignal(SignalOut);
}
/*---+---------------------------------------------------------------
     Macros for xInEnv
-------------------------------------------------------------------*/
#ifndef IN_LOCAL_VARIABLES
#define IN_LOCAL_VARIABLES \
  xSignalNode SignalIn;
#endif

#ifndef IN_SIGNAL1
#define IN_SIGNAL1(SIGNAL_NAME, SIGNAL_NAME_STRING) \
  SignalIn = xGetSignal(SIGNAL_NAME, xNotDefPId, xEnv);
#endif

#ifndef IN_SIGNAL2
#define IN_SIGNAL2(SIGNAL_NAME, SIGNAL_NAME_STRING) \
  SDL_Output(SignalIn xSigPrioPar(xDefaultPrioSignal), (xIdNode *)0);
#endif

#ifndef IF_IN_SIGNAL
#define IF_IN_SIGNAL(SIGNAL_NAME, SIGNAL_NAME_STRING) \
  if (TEST_IF_IN_SIGNAL(SIGNAL_NAME)) {
#define END_IF_IN_SIGNAL(SIGNAL_NAME, SIGNAL_NAME_STRING) \
  }
#endif

#ifndef TEST_IF_IN_SIGNAL
#define TEST_IF_IN_SIGNAL(SIGNAL_NAME)  0
#endif

#ifndef XENV_DEC
#define XENV_DEC(stmt) stmt
#endif

#ifndef XENV_IN_START
#define XENV_IN_START
#endif

#ifndef XENV_IN_END
#define XENV_IN_END
#endif


/*---+---------------------------------------------------------------
     xInEnv  extern
-------------------------------------------------------------------*/
#ifndef XTENV
void xInEnv ( SDL_Time Time_for_next_event )
#else
SDL_Duration xInEnv ( SDL_Time Time_for_next_event )
#endif
{

  xSignalNode S;
  I_PVoid rcvPtr = NULL;
  I_U32   msgSize;
  SDL_Pid rcvr;
     I_U16          msgType;
  struct sAisParam *param;


  if ((rcvPtr = (I_Void *)RecvMsg(selfEntIdG, &msgSize)) != NULL)
  {
	   
           msgType = ((SysHdr *)rcvPtr)->msgType;
           if ( gCurrentCardState == CARDSTATE_ACTIVE)
		{
    switch(msgType)
		 {
		  case OAMS_CFG_GBH_FIRST_NSVC_ENABLED :
		  LOG_PRINT(DEBUG,"xInEnv : OAMS_CFG_GBH_FIRST_NSVC_ENABLED received ");
	     S = xGetSignal( sig_OAMS_CFG_GBH_FIRST_NSVC_ENABLED, xNotDefPId, xEnv);
		  ((yPDP_sig_OAMS_CFG_GBH_FIRST_NSVC_ENABLED)S)->Param1 = rcvPtr;
        break;
 
        case OAMS_CFG_GBH_LAST_NSVC_DISABLED :
        LOG_PRINT(DEBUG,"xInEnv : OAMS_CFG_GBH_LAST_NSVC_DISABLED received ");
        S = xGetSignal( sig_OAMS_CFG_GBH_LAST_NSVC_DISABLED, xNotDefPId, xEnv);
        ((yPDP_sig_OAMS_CFG_GBH_LAST_NSVC_DISABLED)S)->Param1 = rcvPtr;
        break;

        case OAMS_CFG_GBH_SIG_BVC_RESET_FAILED :
        LOG_PRINT(DEBUG,"xInEnv : OAMS_CFG_GBH_SIG_BVC_RESET_FAILED received ");
        S = xGetSignal( sig_OAMS_CFG_GBH_SIG_BVC_RESET_FAILED, xNotDefPId, xEnv);
        ((yPDP_sig_OAMS_CFG_GBH_SIG_BVC_RESET_FAILED)S)->Param1 = rcvPtr;
        break;
        case PSSKS_BSSGP_GBH_SIG_BVC_RESET :
        LOG_PRINT(DEBUG,"xInEnv : PSSKS_BSSGP_GBH_SIG_BVC_RESET received ");
        S = xGetSignal( sig_PSSKS_BSSGP_GBH_SIG_BVC_RESET, xNotDefPId, xEnv);
        ((yPDP_sig_PSSKS_BSSGP_GBH_SIG_BVC_RESET)S)->Param1 = rcvPtr;
        break;

        case PSSKS_BSSGP_GBH_SIG_BVC_RESET_ACK :
        LOG_PRINT(DEBUG,"xInEnv : PSSKS_BSSGP_GBH_SIG_BVC_RESET_ACK received ");
        S = xGetSignal( sig_PSSKS_BSSGP_GBH_SIG_BVC_RESET_ACK, xNotDefPId, xEnv);
        ((yPDP_sig_PSSKS_BSSGP_GBH_SIG_BVC_RESET_ACK)S)->Param1 = rcvPtr;
        break;

      default:
        LOG_PRINT(MAJOR,"Invalid Msg. Rcvd. From Outside(msgTyp = 0x%d) ",((SysHdr *)rcvPtr)->msgType);
        DalocMsgBuf(rcvPtr);
        return;
   	}/*End of Switch condition*/
    	SDL_Output( S xSigPrioPar(xDefaultPrioSignal), (xIdNode *)0 );
	}
       else
       {
          if (msgType == BPM_SELFCARD_STATE_CHANGE)
          {
           #if BPM_PRESENT != 1
             LOG_PRINT(DEBUG,"(ENV:xInEnv)Locking Semaphore...");
             if( SEM_WAIT(&gSemHandler) !=0)
                   LOG_PRINT(DEBUG,"(ENV:xInEnv)SEM_WAIT failed ");

                LOG_PRINT(DEBUG,"(ENV:xInEnv)BPM_SELFCARD_STATE_CHANGE received ");
             param = (struct sAisParam *)(rcvPtr+sizeof(SysHdr));
             cardStateChangeHandler(param);
             LOG_PRINT(DEBUG,"(ENV:xInEnv)Waiting For Semaphore....");
             if( SEM_TIMED_WAIT(&gSemHandler) != SEMAPHORE_WAIT_COMPLETE)
             {
                   LOG_PRINT(INFO,"(ENV:xInEnv)Got Sempahore.. ");
                   LOG_PRINT(INFO,"(ENV:xInEnv)calling bpmRespondToAis.. ");
                   bpmRespondToAis (param->invocation, OK);
                   LOG_PRINT(INFO,"(ENV:xInEnv)Response sent to BPM.. ");
                   LOG_PRINT(INFO,"(ENV:xInEnv)Releasing Sempahore.. ");
                   SEM_POST(&gSemHandler);
             }
             else
             {
                   LOG_PRINT(INFO,"(ENV:xInEnv)Semaphore Wait Timed Out... ");
                   LOG_PRINT(INFO,"(ENV:xInEnv)Releasing semaphore.. ");
                   SEM_POST(&gSemHandler);
             }
#endif
       }
       else
       {
          LOG_PRINT(DEBUG,"(ENV:xInEnv)Card isn't in Active State , So discarding the received message..... ");
          DalocMsgBuf((I_Void *)rcvPtr) ;
       }
    }
	}/*End of If Condition*/

#ifdef XTENV
  return SDL_Time_Lit((xint32) ZERO,(xint32) ZERO);
#endif

}
