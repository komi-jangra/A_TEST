
/* SKELETON for env functions */
/* Program generated by Cadvanced 3.0.0.0.2032 */
#define XSCT_CADVANCED

#define C_TRANSLATOR_2_6
#include "scttypes.h"
#ifdef XUSE_SIGNAL_NUMBERS
#include "System_CCUH.hs"
#endif
#ifdef XENV_INC
#include XENV_INC
#endif
#include "System_CCUH.ifc"

/*****************************/
//#include<oamssys_include.h>
#include <stdio.h>
#include "dbsxxx_commondefs.h"
#include "dbsxxx_commonwrappers.h"
#include "dbsxxx_cfg_dbwrapper.h"
#include "DBLIBError.h"
#include "sysxxx_typedef.h"
#include "sysxxx_hashdefs.h"
#include "sysxxx_msgstruct.h"
#include "sysxxx_proc.h"
#include "sysinst_hashdefs.h"

#include"ipcfrm_extern.h"
#include"ipcfrm_msgqueue.h"
#include"ipcfrm_syslog.h"
#include"sysxxx_msgopcode.h"
#include<CLIB.h>
/*CS4.0 HA Changes start*/
#include "bpmxxx_commonDef.h"
#include "bpmxxx_platformLib.h"
#include "bpmxxx_OAM_commonDef.h"
#include "oamsxxx_mutex.h"

I_S32 gCurrentCardState = CARDSTATE_INIT;
I_S32 gNewCardState = CARDSTATE_INVALID;
I_U32 gLclPidActiveClass = INVALID_LCL_PID_PTR ;
I_U32 gInstancesCreated  = I_FALSE ;
I_U32 gSignalSent = ZERO;
I_S32 gInvocation;

/* Defining Mutex */
DEFINE_MUTEX;
/* CS4.0: Changes for HA End */

#ifndef XNOGLOBALNODENUMBER
/*---+---------------------------------------------------------------
     xGlobalNodeNumber  extern
-------------------------------------------------------------------*/
#ifndef XENV_NODENUMBER
#define XENV_NODENUMBER return 1;
#endif
I_S32 selfEntIdG ;
#define SELF_ENTITY_ID ENT_OAMS_CCUH
#define SELF_ENTITY_NAME "CCUH"
int xGlobalNodeNumber(void)
{
  /* Assign a unique global system Id to each SDL system in a cluster of systems. */
     return ENT_OAMS_CCUH ;
  /*  XENV_NODENUMBER  */
}
#endif

/**
 * Interface with Base Platform Module (BPM)
 * Note1: BPM is an optional feature in the system.
 * All code pertaining to BPM interface should be under a compile time
 * flag.
 */

#if BPM_PRESENT != 1

#define RegisterCcuhWithBpm() bpmGetComponentReg(ENT_OAMS_CCUH_STUB,&CCUHBpmCallbackFunc);
#define bpmRespondToAis(a,b)
#warning "BPM support not compiled"

#else

//#include "bpmxxx_commonDef.h"
//#include 
void CCUHBpmCallbackFunc (struct sAisParam *param);
void RegisterCcuhWithBpm(void)
{
   bpmGetComponentRegister (CCUHBpmCallbackFunc, APPID_OAMS_CCUH);
   bpmComponentConfigure ();
}
#endif
I_Void  activeStateHandler()
{
   gCurrentCardState = gNewCardState;
   gNewCardState = CARDSTATE_INVALID;
   RELEASE_MUTEX;
   LOG_PRINT(DEBUG,"RELEASING MUTEX...");

}

I_U32 GetRefIdByCCUId(I_Void *rcvPtr)
{
   SysHdr          *sysHdr = NULL;
   I_U16           msgType = ZERO;
   I_U32           refId   = INVALID_REF_ID;
   LOG_PRINT(DEBUG,"[ENV]In Function GetRefIdByCCUId To Find RefId...");
   sysHdr = (SysHdr *)rcvPtr ;
   msgType = sysHdr->msgType ;
   switch(msgType)
   {
	   case CSAPP_ABIHM_CCUH_BIC_BSC_ALARM_IND:
		   refId = ((CsappAbihmCcuhBicBscAlarmInd *)rcvPtr)->ccuId;
               LOG_PRINT(INFO,"CcuId received from rcvptr is :  %u ",refId);
		   break;
	   case CSAPP_ABIHM_CCUH_BIC_CC_INFO_RESP:
		   refId = ((CsappAbihmCcuhBicCcInfoResp *)rcvPtr)->ccuId;
               LOG_PRINT(INFO,"CcuId received from rcvptr is :  %u ",refId);
		   break;
	   case CSAPP_ABIHM_CCUH_BIC_CC_DATA_RESP:
		   refId = ((CsappAbihmCcuhBicCcDataResp *)rcvPtr)->ccuId;
               LOG_PRINT(INFO,"CcuId received from rcvptr is :  %u ",refId);
		   break;
	   case CSAPP_ABIHM_CCUH_BIC_CC_DATA_NACK:
		   refId = ((CsappAbihmCcuhBicCcDataNack *)rcvPtr)->ccuId;
               LOG_PRINT(INFO,"CcuId received from rcvptr is :  %u ",refId);
		   break;
		   /* case OAMS_CFG_CCUH_BIC_CC_INFO_REQ:
		      refId = ((OamsCfgCcuhBicCcInfoReq *)rcvPtr)->ccuId;
		      break;*/

	   case OAMS_CFG_CCUH_BIC_SET_CC_CFG_REQ:
		   refId = ((OamsCfgCcuhBicSetCcCfgReq *)rcvPtr)->ccuId;
               LOG_PRINT(INFO,"CcuId received from rcvptr is :  %u ",refId);
		   break;
	   case CSAPP_ABIHM_CCUH_BIC_SET_CC_CFG_RESP:
		   refId = ((CsappAbihmCcuhBicSetCcCfgResp *)rcvPtr)->ccuId;
               LOG_PRINT(INFO,"CcuId received from rcvptr is :  %u ",refId);
		   break;
	   case CSAPP_ABIHM_CCUH_BIC_GET_CC_CFG_RESP:
		   refId = ((CsappAbihmCcuhBicGetCcCfgResp *)rcvPtr)->ccuId;
               LOG_PRINT(INFO,"CcuId received from rcvptr is :  %u ",refId);
		   break;
	   case OAMS_CFG_CCUH_BIC_CC_DATA_REQ:
		   refId = ((OamsCfgCcuhBicCcDataReq *)rcvPtr)->ccuId;
               LOG_PRINT(INFO,"CcuId received from rcvptr is :  %u ",refId);
		   break;
	   case OAMS_CFG_CCUH_BIC_CC_PWR_ORDER_REQ:
		   refId = ((OamsCfgCcuhBicCcPwrOrderReq *)rcvPtr)->ccuId;
               LOG_PRINT(INFO,"CcuId received from rcvptr is :  %u ",refId);
		   break;
	   case OAM_PDC_CCUH_BIC_CC_INFO_REQ:
		   refId = ((OamPdcCcuhBicCcInfoReq *)rcvPtr)->ccuId;
               LOG_PRINT(INFO,"CcuId received from rcvptr is :  %u ",refId);
		   break;
	   default:
		   refId = 0;
   }
   LOG_PRINT(DEBUG,"[ENV: ]Returning From Function GetRefIdbyCCUID...");
   return refId;
}

I_Void findLclPidPtr ( I_U32 instId, I_U8 classId, I_U32 *lclPidPtr, I_U8 entId)
{
   I_S32 retCode       = ZERO;
   I_S32 localInstId   = ZERO;
   InstMapTbl          instMapTblPtr;

   LOG_PRINT(INFO,"Finding LocalPidPtr for class: %d", classId);
   retCode = GetRowFrmInstId ( &instMapTblPtr, (I_S32)instId, entId, classId);
   if ( retCode != INST_SUCCESS )
   {
      LOG_PRINT(MAJOR,"[ENV] GetRowFrmInstId Db call failed.. ");
      *lclPidPtr = INVALID_LCL_PID_PTR;
      return;
   }
   if (  instMapTblPtr.status  == INST_FREE )
   {
       LOG_PRINT(INFO,"[ENV] Instance is not allocated.. ");
      *lclPidPtr = INVALID_LCL_PID_PTR;
      return;
   }
   retCode = SearchAlocatedInst( lclPidPtr, &localInstId,  entId, classId, instMapTblPtr.refId1, instMapTblPtr.refId2, instMapTblPtr.refId3, instMapTblPtr.refId4, instMapTblPtr.refId5);
   if ( ( retCode != INST_SUCCESS ) )
   {
     *lclPidPtr = INVALID_LCL_PID_PTR;
   }
}




I_U32 GetRefIdByBicId(I_Void *rcvPtr)
{
   SysHdr          *sysHdr = NULL;
   I_U16           msgType = ZERO;
   I_U32           refId   = INVALID_REF_ID;
   LOG_PRINT(DEBUG,"[ENV]In Function GetRefId To Find RefId...");
   sysHdr = (SysHdr *)rcvPtr ;
   msgType = sysHdr->msgType ;
   switch(msgType)
   {
	   case CSAPP_ABIHM_CCUH_BIC_BSC_ALARM_IND:
		   refId = ((CsappAbihmCcuhBicBscAlarmInd *)rcvPtr)->bicId;
               LOG_PRINT(INFO,"BicId received from rcvptr is :  %u ",refId);
		   break;
	   case OAMS_BICH_CCUH_LAPD_LINK_UP:
		   refId = ((OamsBichCcuhLapdLinkUp *)rcvPtr)->bicId;
               LOG_PRINT(INFO,"BicId received from rcvptr is :  %u ",refId);
		   break;
	   case OAMS_BICH_CCUH_LAPD_LINK_DOWN:
		   refId = ((OamsBichCcuhLapdLinkDown *)rcvPtr)->bicId;
               LOG_PRINT(INFO,"BicId received from rcvptr is :  %u ",refId);
		   break;
	   case CSAPP_ABIHM_CCUH_BIC_CC_INFO_RESP:
		   refId = ((CsappAbihmCcuhBicCcInfoResp *)rcvPtr)->bicId;
               LOG_PRINT(INFO,"BicId received from rcvptr is :  %u ",refId);
		   break;
	   case CSAPP_ABIHM_CCUH_BIC_CC_DATA_RESP:
		   refId = ((CsappAbihmCcuhBicCcDataResp *)rcvPtr)->bicId;
               LOG_PRINT(INFO,"BicId received from rcvptr is :  %u ",refId);
		   break;
	   case CSAPP_ABIHM_CCUH_BIC_CC_DATA_NACK:
		   refId = ((CsappAbihmCcuhBicCcDataNack *)rcvPtr)->bicId;
               LOG_PRINT(INFO,"BicId received from rcvptr is :  %u ",refId);
		   break;
		   /* case OAMS_CFG_CCUH_BIC_CC_INFO_REQ:
		      refId = ((OamsCfgCcuhBicCcInfoReq *)rcvPtr)->ccuId;
		      break;*/

	   case OAMS_CFG_CCUH_BIC_SET_CC_CFG_REQ:
		   refId = ((OamsCfgCcuhBicSetCcCfgReq *)rcvPtr)->bicId;
               LOG_PRINT(INFO,"BicId received from rcvptr is :  %u ",refId);
		   break;
	   case CSAPP_ABIHM_CCUH_BIC_SET_CC_CFG_RESP:
		   refId = ((CsappAbihmCcuhBicSetCcCfgResp *)rcvPtr)->bicId;
               LOG_PRINT(INFO,"BicId received from rcvptr is :  %u ",refId);
		   break;
	   case CSAPP_ABIHM_CCUH_BIC_GET_CC_CFG_RESP:
		   refId = ((CsappAbihmCcuhBicGetCcCfgResp *)rcvPtr)->bicId;
               LOG_PRINT(INFO,"BicId received from rcvptr is :  %u ",refId);
		   break;
	   case OAMS_CFG_CCUH_BIC_CC_DATA_REQ:
		   refId = ((OamsCfgCcuhBicCcDataReq *)rcvPtr)->bicId;
               LOG_PRINT(INFO,"BicId received from rcvptr is :  %u ",refId);
		   break;
	   case OAM_PDC_CCUH_BIC_CC_INFO_REQ:
		   refId = ((OamPdcCcuhBicCcInfoReq *)rcvPtr)->bicId;
               LOG_PRINT(INFO,"BicId received from rcvptr is :  %u ",refId);
		   break;
	   default:
		   refId = 0;

   }
   LOG_PRINT(DEBUG,"[ENV: ]Returning From Function GetRefIdByBicId...");
   return refId ;
}

int checkDBErrorCode(I_S32 result)
{

        if(result == DBLIBERR_BASEDAO_NO_INDEX_DEFINED ||
        result == DBLIBERR_PTOPAGE_HAS_NO_ROWS)
        {
                return 1;
        }
        else
        {
                return 0;
        }
}



I_U32 getCountAllocatedInst ( I_U32 instCount )
{
   I_U32 instId = ZERO;
   I_U32 count = ZERO;
   I_U32 lclPidPtr  = INVALID_LCL_PID_PTR ;

   LOG_PRINT(INFO," Entering getCountAllocatedInst");
   for ( instId = 1; instId <= instCount; instId++ )
   {
      findLclPidPtr ( instId, CCU_HANDLER, &lclPidPtr, (I_U8)ENT_OAMS_CCUH );
      if ( lclPidPtr != INVALID_LCL_PID_PTR )
      {
         count++;
      }
   }
   LOG_PRINT(INFO,"Total Allocated Instance [%d]",count);
   LOG_PRINT(INFO," Exiting getCountAllocatedInst");
   return count;
}


I_Void activeInProgressStateHandler()
{
   BicCcInfoTableApi                  *bicCcInfoTablePtr = NULL;
   BicCcInfoTableApi                  *bicCcInfoTempPtr = NULL;
   BicCcInfoTableIndices               bicCcInfoIndex;
   BicCcChargingDataTableApi          *bicCcChargingDataTablePtr = NULL;
   BicCcChargingDataTableApi          *bicCcChargingDataTempPtr = NULL;
   BicCcChargingDataTableIndices      bicCcChargingDataIndex;
   CcPowerOrderTableApi               *ccPowerOrderTablePtr = NULL;
   CcPowerOrderTableApi               *ccPowerOrderTempPtr = NULL;
   CcPowerOrderTableIndices            ccPowerOrderIndex;
   InstCcChargingDataTableApi         *instCcChargingDataTablePtr = NULL;
   InstCcChargingDataTableApi         *instCcChargingDataTempPtr = NULL;
   InstCcChargingDataTableIndices      instCcChargingDataIndex;
   I_U32                               outCount = ZERO;
   I_U16                               outSize = ZERO;
   I_S32                               retCode = ZERO;
   I_S32                               retVal = ZERO;
   I_U32                               lclPidPtr = INVALID_LCL_PID_PTR ;
   I_U32                               instId = INVALID_INST_ID ;
   I_U32                               index = ZERO;
   //I_S8                                instCountResult = ZERO;
   I_U16                               instCount = ZERO;
   SDL_Pid                   rcvr;
   xSignalNode               S;
   I_Void         *rcvPtr     =NULL;
   I_S32           result = ZERO;
   I_U32           ccuId =ZERO;
   I_U32           bicId =ZERO;
   I_U16           NoRowsFound;
   I_U16           counter;
   I_U32           refId   = INVALID_REF_ID;
   I_U32           refId2;

   selfEntIdG = (int)ENT_OAMS_CCUH;
   rcvr.GlobalNodeNr = (I_S32)selfEntIdG;

   if ( (gCurrentCardState == CARDSTATE_ACTIVE_IN_PROGRESS) &&  (gNewCardState = CARDSTATE_ACTIVE) )
   {
      retCode = getallBicCcInfoTable( &bicCcInfoTablePtr, &outCount, &outSize);
      if ( retCode != CLIB_SUCCESS )
      {
         LOG_PRINT(LOG_INFO,"activeInProgressStateHandler: No CCU configured");
      }
     /* Cleaning Transient BicCcInfo table */
      else
      {
         for ( index=0; index<outCount; index++ )
         {
            bicCcInfoTempPtr = (BicCcInfoTableApi*)((I_U8*)(bicCcInfoTablePtr) + index*outSize);
            bicCcInfoIndex.ccuId = bicCcInfoTempPtr->ccuId;
            bicCcInfoIndex.bicId = bicCcInfoTempPtr->bicId;
            if ((deleteBicCcInfoTable(&bicCcInfoIndex)) != CLIB_SUCCESS)
            {
               LOG_PRINT(CRITICAL,"deleteBicCcInfoTable failed for CcuId: %d and BicId :%d",bicCcInfoIndex.ccuId,bicCcInfoIndex.bicId);
            }
         }
         free(bicCcInfoTablePtr);
      }

      retCode = getallBicCcChargingDataTable( &bicCcChargingDataTablePtr, &outCount, &outSize);
      if ( retCode != CLIB_SUCCESS )
      {
         LOG_PRINT(LOG_INFO,"activeInProgressStateHandler: No CCU data available");
      }
     /* Cleaning Transient BicCcChargingData table */
      else
      {
         for ( index=0; index<outCount; index++ )
         {
            bicCcChargingDataTempPtr = (BicCcChargingDataTableApi*)((I_U8*)(bicCcChargingDataTablePtr) + index*outSize);
            bicCcChargingDataIndex.dummyIndex = index;
            //bicCcChargingDataIndex.ccuId = bicCcChargingDataTempPtr->ccuId;
            //bicCcChargingDataIndex.bicId = bicCcChargingDataTempPtr->bicId;
            if ((deleteBicCcChargingDataTable(&bicCcChargingDataIndex)) != CLIB_SUCCESS)
            {
               LOG_PRINT(CRITICAL,"deleteBicCcChargingDataTable failed for dummyIndex :%d",bicCcChargingDataIndex.dummyIndex);
            }
         }
         free(bicCcChargingDataTablePtr);
      }


      retCode = getallCcPowerOrderTable( &ccPowerOrderTablePtr, &outCount, &outSize);
      if ( retCode != CLIB_SUCCESS )
      {
         LOG_PRINT(LOG_INFO,"activeInProgressStateHandler: No CCU  Power Order configured");
      }
     /* Cleaning Transient CcPowerOrderTable table */
      else
      {
         for ( index=0; index<outCount; index++ )
         {
            ccPowerOrderTempPtr = (CcPowerOrderTableApi*)((I_U8*)(ccPowerOrderTablePtr) + index*outSize);
            ccPowerOrderIndex.ccuId = ccPowerOrderTempPtr->ccuId;
            if ((deleteCcPowerOrderTable(&ccPowerOrderIndex)) != CLIB_SUCCESS)
            {
               LOG_PRINT(CRITICAL,"deleteBicCcPowerOrderTable failed for CcuId: %d ",ccPowerOrderIndex.ccuId);
            }
         }
         free(ccPowerOrderTablePtr);
      }


      retCode = getallInstCcChargingDataTable( &instCcChargingDataTablePtr, &outCount, &outSize);
      if ( retCode != CLIB_SUCCESS )
      {
         LOG_PRINT(LOG_INFO,"activeInProgressStateHandler: No CCU InstCcChargingDataTable  configured");
      }
     /* Cleaning Transient InstCcChargingDataTable table */
      else
      {
         for ( index=0; index<outCount; index++ )
         {
            instCcChargingDataTempPtr = (InstCcChargingDataTableApi*)((I_U8*)(instCcChargingDataTablePtr) + index*outSize);
            instCcChargingDataIndex.ccuId = instCcChargingDataTempPtr->ccuId;
            if ((deleteInstCcChargingDataTable(&instCcChargingDataIndex)) != CLIB_SUCCESS)
            {
               LOG_PRINT(CRITICAL,"deleteInstCcChargingDataTable failed for CcuId: %d ",instCcChargingDataIndex.ccuId);
            }
         }
         free(instCcChargingDataTablePtr);
      }
/*Instance to be created at INSERVICE Gaurav Sinha 14-03-2016*/
#if 0 /*Gaurav Sinha 14-03-2016*/
      instCountResult = GetInstCount(ENT_OAMS_CCUH, CCU_HANDLER , &instCount);
      if ( instCountResult != INST_SUCCESS )
      {
         LOG_PRINT(MAJOR,"[ENV] GetInstCount Db call failed.. ");
         return;
      }
      if ( gInstancesCreated == I_FALSE )
      {
         InitInstMap(ENT_OAMS_CCUH,CCU_HANDLER);
         /* Sending internal signal to system class for creating tau instances */
         LOG_PRINT(INFO,"activeInProgressStateHandler: Sending internal signal CCUH_INT_ADD_TAU_INSTANCE to model");
         rcvr.LocalPId = (xLocalPIdNode)gLclPidActiveClass;
         S = xGetSignal( sig_CCUH_INT_ADD_TAU_INSTANCE, rcvr, xEnv);
         SDL_Output( S xSigPrioPar(xDefaultPrioSignal), (xIdNode *)0 );
         gSignalSent = instCount;
         LOG_PRINT(INFO, "gSignalSent: %d", gSignalSent);
      }
      else
      {
#endif
/*Instance to be created at INSERVICE Gaurav Sinha 14-03-2016*/

			for ( instId = 1; instId <= instCount; instId++ )
         {
            findLclPidPtr ( instId, CCU_HANDLER, &lclPidPtr, (I_U8)ENT_OAMS_CCUH );
            LOG_PRINT(DEBUG,"findLclPidPtr Success lclPid = " \
                          "0x%x",(I_U32)lclPidPtr);
            if ( lclPidPtr != INVALID_LCL_PID_PTR )
            {
               if ((retVal = FreInstId(lclPidPtr, ENT_OAMS_CCUH, CCU_HANDLER)) != INST_SUCCESS)
               {
                  LOG_PRINT(CRITICAL, "activeInProgressStateHandler: FreeInstId() Failed lclPidPtr = 0x%x [Act Cls Id = %d], [errCode =%d]",lclPidPtr, CCU_HANDLER,retVal);
                 return;
               }
               else
               {
                 LOG_PRINT(DEBUG,"activeInProgressStateHandler: FreeInstId() Success lclPidPtr = 0x%x [Act Cls Id = %d]",lclPidPtr, CCU_HANDLER);
               }
            }
            else
            {
               LOG_PRINT(INFO,"activeInProgressStateHandler: Invalid Instance Found...");
            }
         }

			
      //ccuId = GetRefIdByCCUId(rcvPtr) ;
      //bicId = GetRefIdByBicId(rcvPtr) ;
              /*for(counter = 0; counter < outCount; counter++)
              {
                      refId=ccuId; //refId points to the ccuId here
                      refId2=bicId;
                      LOG_PRINT(INFO,"refId is :: %d ,refId2 is :: %d", refId,refId2);


                      if (SearchAlocatedInst(&lclPidPtr,&instId,ENT_OAMS_CCUH,CCU_HANDLER,refId,refId2,ZERO,ZERO,ZERO) != INST_SUCCESS)
                      {
                              LOG_PRINT(CRITICAL,"No CCUH Ins found CCU = [%d]\n",refId);
                              continue;
                      }
                      if (lclPidPtr == 0)
                      {
                              LOG_PRINT(CRITICAL,"Invalid Instance Found...\n");
                              continue;
                      }
                      if ( lclPidPtr != INVALID_LCL_PID_PTR )
		      {
			      if ((retVal = FreInstId(lclPidPtr, ENT_OAMS_CCUH, CCU_HANDLER)) != INST_SUCCESS)
			      {
				      LOG_PRINT(CRITICAL, "activeInProgressStateHandler: FreeInstId() Failed lclPidPtr = 0x%x [Act Cls Id = %d],[errCode =%d]",lclPidPtr, CCU_HANDLER,retVal);
				      return;
			      }
			      else
			      {
				      LOG_PRINT(DEBUG,"activeInProgressStateHandler: FreeInstId() Success lclPidPtr = 0x%x [Act Cls Id = %d]",lclPidPtr, CCU_HANDLER);
			      }
		      }
		      else
		      {
			      LOG_PRINT(INFO,"activeInProgressStateHandler: Invalid Instance Found...");
		      }
	      }*/
	      gCurrentCardState = gNewCardState;
	      gNewCardState = CARDSTATE_INVALID;
	      LOG_PRINT(INFO,"CurrentCardState: [%d]", gCurrentCardState) ;
	      LOG_PRINT(INFO,"NewCardState: [%d]", gNewCardState) ;
	      RELEASE_MUTEX;
	      LOG_PRINT(INFO,"Moving to ACTIVE ");
      
 // }# if 0 Gaurav 14-03-2016
}
   else
      LOG_PRINT(MAJOR,"Unexpected State change notification received");
}
I_Void cardStateChangeHandler(struct sAisParam *param)
{
   xSignalNode     S;
   I_Void         *rcvPtr     =NULL;
   SDL_Pid         rcvr;
   I_U32           lclPidPtr = INVALID_LCL_PID_PTR ;
   I_S32           result = ZERO;
   I_U32           instId = ZERO;
   I_S8            instCountResult = ZERO;
   I_U16           instCount = ZERO;
   I_U32           ccuId =ZERO;
   I_U32           bicId =ZERO;
   I_U32          fromCcuId   =ZERO;
   I_U8            numCcu      =ZERO;
   I_U16           NoRowsFound;
   I_U16           counter;
   I_U32           outCount = ZERO;
   I_U16           outSize = ZERO;
   I_S32           retCode = ZERO;
   I_S32           retVal = ZERO;
   I_U32           refId   = INVALID_REF_ID;
   I_U32           refId2;
   I_U32           signalSentToModel = I_FALSE;



   rcvr.GlobalNodeNr = (I_S32)selfEntIdG;
   rcvr.LocalPId = (xLocalPIdNode)0;
   LOG_PRINT(INFO,"BPM_SELFCARD_STATE_CHANGE recd with CARD_STATE = %d", param->cardState) ;

   /* Init -> InService */
   if ( (param->cardState == CARDSTATE_IN_SERVICE) && (gCurrentCardState == CARDSTATE_INIT) )
   {
      gNewCardState = CARDSTATE_IN_SERVICE;
      LOG_PRINT(DEBUG,"Registering with DB Server...");
      result = dbConnect();
      if ( result != DBLIB_SUCCESS )
      {
         LOG_PRINT(CRITICAL,"CCUHandler: Unable to Register itself with DBServer:Exiting");
         return;
      }
      LOG_PRINT(DEBUG,"Successfully Registered with DB Server.");
/*Instance to be created at INSERVICE Gaurav Sinha 14-03-2016*/
      I_S8 instCountResult = ZERO;
      instCountResult = GetInstCount(ENT_OAMS_CCUH, CCU_HANDLER , &instCount);
      if ( instCountResult != INST_SUCCESS )
      {
         LOG_PRINT(MAJOR,"[ENV] GetInstCount Db call failed.. ");
         return;
      }
      if ( gInstancesCreated == I_FALSE )
      {
         InitInstMap(ENT_OAMS_CCUH,CCU_HANDLER);
         /* Sending internal signal to system class for creating tau instances */
         LOG_PRINT(INFO,"(CLOUD_BSC) Sending internal signal CCUH_INT_ADD_TAU_INSTANCE to model");
         rcvr.LocalPId = (xLocalPIdNode)gLclPidActiveClass;
         S = xGetSignal( sig_CCUH_INT_ADD_TAU_INSTANCE, rcvr, xEnv);
         SDL_Output( S xSigPrioPar(xDefaultPrioSignal), (xIdNode *)0 );
         gSignalSent = instCount;
         LOG_PRINT(INFO, "gSignalSent: %d", gSignalSent);
      }
     else
     {
        LOG_PRINT(DEBUG,"(CLOUD_BSC) TAU Instances  already created ");
		 }
/*Instance to be created at INSERVICE Gaurav Sinha 14-03-2016*/

      gCurrentCardState = CARDSTATE_IN_SERVICE;
      gNewCardState = CARDSTATE_INVALID;
      RELEASE_MUTEX;
   }


   /* Active -> InService*/
 else if ( (param->cardState == CARDSTATE_IN_SERVICE) && ( gCurrentCardState == CARDSTATE_ACTIVE) )
 {
      
      gNewCardState = CARDSTATE_IN_SERVICE;
      instCountResult = GetInstCount(ENT_OAMS_CCUH, CCU_HANDLER , &instCount);
      if ( instCountResult != INST_SUCCESS )
      {
         LOG_PRINT(MAJOR,"[ENV] GetInstCount Db call failed.. ");
         return;
      }
      gSignalSent = getCountAllocatedInst ( instCount ); /* To track No. of Signal sent to Model */
      LOG_PRINT(INFO, "gSignalSent: %d", gSignalSent);

      for ( instId = 1; instId <= instCount; instId++ )
      {
         findLclPidPtr ( instId, CCU_HANDLER, &lclPidPtr, (I_U8)ENT_OAMS_CCUH );
         LOG_PRINT(DEBUG,"findLclPidPtr Success lclPid = " \
                          "0x%x",(I_U32)lclPidPtr);
         if ( lclPidPtr != INVALID_LCL_PID_PTR )
         {
            rcvr.LocalPId = (xLocalPIdNode)lclPidPtr;
            LOG_PRINT(INFO,"Sending signal CCUH_INT_SELFCARD_STATE_CHANGE to Model");
            S = xGetSignal( sig_CCUH_INT_SELFCARD_STATE_CHANGE, rcvr, xEnv);

            //(((yPDP_sig_CCUH_INT_SELFCARD_STATE_CHANGE)S)->Param1) = gCurrentCardState;
            //(((yPDP_sig_CCUH_INT_SELFCARD_STATE_CHANGE)S)->Param2) = gNewCardState;
            SDL_Output( S xSigPrioPar(xDefaultPrioSignal), (xIdNode *)0 );
            signalSentToModel = I_TRUE;
         }
     }

      if ( signalSentToModel == I_FALSE)
      {
         activeStateHandler();
      }







		
  }


 /* InService -> StandBy*/
   else if ( (param->cardState == CARDSTATE_STANDBY) && (gCurrentCardState == CARDSTATE_IN_SERVICE) )
   {
      gNewCardState = CARDSTATE_STANDBY;
      gCurrentCardState = CARDSTATE_STANDBY;
      gNewCardState = CARDSTATE_INVALID;
      RELEASE_MUTEX;
   }

   /* InService,StandBy -> ActiveInProgress*/
   else if ( (param->cardState == CARDSTATE_ACTIVE_IN_PROGRESS) && ( ( gCurrentCardState == CARDSTATE_IN_SERVICE) || (gCurrentCardState == CARDSTATE_STANDBY) ) )
   {
      gNewCardState = CARDSTATE_ACTIVE_IN_PROGRESS;
      gCurrentCardState = CARDSTATE_ACTIVE_IN_PROGRESS;
      gNewCardState = CARDSTATE_INVALID;
      RELEASE_MUTEX;
   }

   /* ActiveInProgress -> Active */
   else if ( (param->cardState == CARDSTATE_ACTIVE) && (gCurrentCardState == CARDSTATE_ACTIVE_IN_PROGRESS) )
   {
      gNewCardState = CARDSTATE_ACTIVE;
      activeInProgressStateHandler();
   }

   /* StandBy -> Recovery */
   else if ( (param->cardState == CARDSTATE_RECOVERY) && (gCurrentCardState == CARDSTATE_STANDBY) )
   {
      gNewCardState = CARDSTATE_RECOVERY;
      gCurrentCardState = CARDSTATE_RECOVERY;
      gNewCardState = CARDSTATE_INVALID;
      RELEASE_MUTEX;
   }

/* Active -> Recovery */
   else if ( (param->cardState == CARDSTATE_RECOVERY) && (gCurrentCardState == CARDSTATE_ACTIVE) )
   {
      gNewCardState = CARDSTATE_RECOVERY;
      instCountResult = GetInstCount(ENT_OAMS_CCUH, CCU_HANDLER , &instCount);
      if ( instCountResult != INST_SUCCESS )
      {
         LOG_PRINT(MAJOR,"[ENV] GetInstCount Db call failed.. ");
         return;
      }
      gSignalSent = getCountAllocatedInst ( instCount ); /* To track No. of Signal sent to Model */
      LOG_PRINT(INFO, "gSignalSent: %d", gSignalSent);

      for ( instId = 1; instId <= instCount; instId++ )
      {
         findLclPidPtr ( instId, CCU_HANDLER, &lclPidPtr, (I_U8)ENT_OAMS_CCUH );
         LOG_PRINT(DEBUG,"findLclPidPtr Success lclPid = " \
                          "0x%x",(I_U32)lclPidPtr);
         if ( lclPidPtr != INVALID_LCL_PID_PTR )
         {
            rcvr.LocalPId = (xLocalPIdNode)lclPidPtr;
            LOG_PRINT(INFO,"Sending signal CCUH_INT_SELFCARD_STATE_CHANGE to Model");
            S = xGetSignal( sig_CCUH_INT_SELFCARD_STATE_CHANGE, rcvr, xEnv);

            //(((yPDP_sig_CCUH_INT_SELFCARD_STATE_CHANGE)S)->Param1) = gCurrentCardState;
            //(((yPDP_sig_CCUH_INT_SELFCARD_STATE_CHANGE)S)->Param2) = gNewCardState;
            SDL_Output( S xSigPrioPar(xDefaultPrioSignal), (xIdNode *)0 );
            signalSentToModel = I_TRUE;
         }
     }

      if ( signalSentToModel == I_FALSE)
      {
         activeStateHandler();
      }



		
 }


  /* Recovery -> InService */
   else if ( (param->cardState == CARDSTATE_IN_SERVICE) && 
             (gCurrentCardState == CARDSTATE_RECOVERY)   )
   {
      gNewCardState = CARDSTATE_IN_SERVICE;
      /* DeRegister with DB */
      if ((result = dbDestroy()) != DBLIB_SUCCESS)
      {
         LOG_PRINT(CRITICAL,"clib_destroy failed for CCUH (Error = %d)",result);
         return;
      }

      LOG_PRINT(DEBUG,"Registering with DB Server...");
      result = dbConnect();
      if ( result != DBLIB_SUCCESS )
      {
         LOG_PRINT(CRITICAL,"CCUHandler: Unable to Register itself with DBServer:Exiting");
         return;
      }
      LOG_PRINT(DEBUG,"Successfully Registered with DB Server.");
      gCurrentCardState = CARDSTATE_IN_SERVICE;
      gNewCardState = CARDSTATE_INVALID;
      RELEASE_MUTEX;
      LOG_PRINT(INFO,"Moving to INSERVICE.. ");
   }
   else if( (param->cardState == CARDSTATE_IN_SERVICE) && (gCurrentCardState == CARDSTATE_DIAGNOSTIC) )
   {
      gNewCardState = param->cardState;
      RELEASE_MUTEX;
   } 

   else if ( (param->cardState == CARDSTATE_DIAGNOSTIC) || (param->cardState == CARDSTATE_UPGRADE ) || (param->cardState == CARDSTATE_OUT_OF_SERVICE) || (param->cardState == CARDSTATE_PLATFORM_INS))
   {
      gCurrentCardState = param->cardState;     
      RELEASE_MUTEX;
   }
   else
   {
      LOG_PRINT(INFO,"cardStateChangeHandler: Unexpected state received  = %d",param->cardState) ;
      RELEASE_MUTEX;
   }
   LOG_PRINT(INFO,"CurrentCardState: [%d]", gCurrentCardState) ;
   LOG_PRINT(INFO,"NewCardState: [%d]", gNewCardState) ;
}
void CCUHBpmCallbackFunc (struct sAisParam *param)
{

  switch (param->messageId)
  {
	  case BPM_HEALTHCHECK_MESSAGE:
		  bpmRespondToAis (param->invocation, OK);
		  break;

	  case BPM_SELFCARD_STATE_CHANGE:
                   /* CS4.0: Changes for HA Start*/
		  LOCK_MUTEX;
		  LOG_PRINT(DEBUG, "CCUHBpmCallbackFunc: MUTEX is Locked");
		  cardStateChangeHandler(param);
		  if ( LOCK_MUTEX_AND_WAIT != MUTEX_WAIT_COMPLETE )
		  {
			  LOG_PRINT(INFO,"calling bpmRespondToAis.. ");
			  bpmRespondToAis (param->invocation, OK);
			  LOG_PRINT(INFO,"Moving to CARD_STATE: [%d]",param->cardState);
		  }
		  else
		  {
			  LOG_PRINT(CRITICAL,"MUTEX Wait Timed Out.. Not sending OK notification");
		  }
		  RELEASE_MUTEX;
                  /* CS4.0: Changes for HA End*/
                  break;

	  case BPM_PEERCARD_STATE_CHANGE:
		  LOG_PRINT(DEBUG, "BPM_PEERCARD_STATE_CHANGE recd, No Action Taken");
		  bpmRespondToAis (param->invocation, OK);
		  break;
	  case BPM_MSG_ACK_PEER_HEALTH_BAD:
		  LOG_PRINT(DEBUG, "BPM_MSG_ACK_PEER_HEALTH_BAD recd, Not Expected");
		  break;

	  case BPM_MSG_ACK_CONFIGURE:
		  LOG_PRINT(DEBUG, "BPM_MSG_ACK_CONFIGURE recd");
		  break;

	  case BPM_MSG_ACK_CONFIGURE_RESET:
		  LOG_PRINT(DEBUG, "BPM_MSG_ACK_CONFIGURE_RESET recd, No Action Taken");
		  break;

	  case BPM_SHUTDOWN:
		  LOG_PRINT(DEBUG, "BPM_SHUTDOWN recd, Exiting");
		  exit (1);
		  break;

	  default:
		  LOG_PRINT(MAJOR, "Unexpected msg from BPM: %d", param->messageId);
		  break;
  }
}

/********************************************************************/




 I_U32 FindCcuhLocalPidPtrByCCUId(I_Void *rcvPtr)
  {
     I_U32 lclPidPtr = INVALID_LCL_PID_PTR ;
     I_S32 instId    = INVALID_INST_ID ;
     I_U32 refId     = INVALID_REF_ID ;
     I_U32 refId2     = 0;
     refId = GetRefIdByCCUId(rcvPtr) ;
     refId2= GetRefIdByBicId(rcvPtr);
     LOG_PRINT(INFO,"RefId received from FindCcuhLocalPidPtrByCCUId is :  %u ",refId);
     LOG_PRINT(INFO,"RefId2 received from FindCcuhLocalPidPtrByBicId is :  %u ",refId2);
     if(refId == ZERO)
     {
	LOG_PRINT(MAJOR,"[ENV]Invalid Instance Found...");
        return INVALID_LCL_PID_PTR;
     }
     if (SearchAlocatedInst(&lclPidPtr,&instId,ENT_OAMS_CCUH,CCU_HANDLER,refId,refId2,ZERO,ZERO,ZERO) != INST_SUCCESS)
     {
        LOG_PRINT(DEBUG,"[ENV: ]Returning From Function GetRefId...");
        return INVALID_LCL_PID_PTR ;
     }
     if (lclPidPtr == INVALID_LCL_PID_PTR)
     {
        LOG_PRINT(CRITICAL,"[ENV]Invalid Instance Found...");
        return INVALID_LCL_PID_PTR;
     }
     return lclPidPtr ;
  }


I_U32 FindCcuhLocalPidPtrByBicId(I_Void *rcvPtr)
{
	I_U32 lclPidPtr = INVALID_LCL_PID_PTR ;
	I_S32 instId    = INVALID_INST_ID ;
	I_U32 refId     = INVALID_REF_ID ;
	I_U32 refId2=0;
	refId = GetRefIdByBicId(rcvPtr) ;
	if(refId == ZERO)
	{
		LOG_PRINT(MAJOR,"[ENV]Invalid Instance Found...");
		return INVALID_LCL_PID_PTR;
	}
	if (SearchAlocatedInst(&lclPidPtr,&instId,ENT_OAMS_CCUH,CCU_HANDLER,ZERO,refId,ZERO,ZERO,ZERO) != INST_SUCCESS)
	{
		LOG_PRINT(DEBUG,"[ENV: ]Returning  :: %u refId From Function GetRefId...", refId);
		return INVALID_LCL_PID_PTR;
	}

	if (lclPidPtr == INVALID_LCL_PID_PTR)
	{
		LOG_PRINT(CRITICAL,"[ENV]Invalid Instance Found...");
		return INVALID_LCL_PID_PTR;
	}
	return lclPidPtr ;
}
#ifndef XNOINITENV
/*---+---------------------------------------------------------------
  xInitEnv  extern
  -------------------------------------------------------------------*/
#ifndef XENV_INIT
#define XENV_INIT
#endif

extern void xInitEnv(void)
{
	/* Code to initialize your SDL-system environment may be inserted here */
	I_S32          result = ZERO;
	selfEntIdG     = (int)ENT_OAMS_CCUH;
#ifdef XTRACE
	xPrintString("xInitEnv called\n");
#endif
//#if BPM_PRESENT == 1
//RegisterCcuhWithBpm();CLOUD
//#endif

if (RegisterWithIpcFrmwrk(SELF_ENTITY_ID, SELF_ENTITY_NAME) < 0)
 {
   LOG_PRINT(CRITICAL,"[ENV]Unable to Register itself with IPC FrameWork : Exiting");
   exit(0) ;
 }
RegisterCcuhWithBpm();
   LOG_PRINT(DEBUG,"Initializing the mutex");
   INIT_MUTEX;
   LOG_PRINT(DEBUG,"After Initializing the mutex");
   LOG_PRINT(DEBUG,"** SystemName=%s, ModuleName=%s, Version=%s **",SYSTEM_NAME,SELF_ENTITY_NAME,VERSION);
   LOG_PRINT(DEBUG,"Registering with IPC FramWork Complete...");
   LOG_PRINT(INFO,"CCUH Process Initialized Successfully") ;
   LOG_PRINT(INFO,"CurrentCardState at initialization: [%d]", gCurrentCardState) ;
   LOG_PRINT(INFO,"NewCardState at initialization: [%d]", gNewCardState) ;

}
#endif


#ifndef XNOCLOSEENV
/*---+---------------------------------------------------------------
     xCloseEnv  extern
-------------------------------------------------------------------*/
#ifndef XENV_CLOSE
#define XENV_CLOSE
#endif

extern void xCloseEnv(void)
{
   /* Code to bring down the environment in a controlled manner
			  may be inserted here. */
   I_S32 retVal=ZERO;
   
   /* Need to delete the instance maps as well. Should use CleanInstMap () for this */
   /* DeRegister with DB */
   if ((retVal = dbDestroy()) != 0)
   {
     LOG_PRINT(CRITICAL,"clib_destroy failed for CCUH (Error = %d)",retVal);
     exit(0);
   }/*if retVal */

#ifdef XTRACE
  xPrintString("xCloseEnv called\n");
#endif
}
#endif


/*---+---------------------------------------------------------------
     Macros for xOutEnv
-------------------------------------------------------------------*/
#ifndef OUT_LOCAL_VARIABLES
#define OUT_LOCAL_VARIABLES
#endif

#ifndef IF_OUT_SIGNAL
#define IF_OUT_SIGNAL(SIGNAL_NAME, SIGNAL_NAME_STRING) \
  if (((*SignalOut)->NameNode) == SIGNAL_NAME) {
#define END_IF_OUT_SIGNAL(SIGNAL_NAME, SIGNAL_NAME_STRING) \
  }
#endif

#ifndef OUT_SIGNAL1
#define OUT_SIGNAL1(SIGNAL_NAME, SIGNAL_NAME_STRING)
#endif

#ifndef OUT_SIGNAL2
#define OUT_SIGNAL2(SIGNAL_NAME, SIGNAL_NAME_STRING)
#endif

#ifndef XENV_ENC
#define XENV_ENC(stmt) stmt
#endif

#ifndef XENV_OUT_START
#define XENV_OUT_START
#endif

#ifndef RELEASE_SIGNAL
#define RELEASE_SIGNAL   xReleaseSignal(SignalOut); return;
#endif


/*---+---------------------------------------------------------------
     xOutEnv  extern
-------------------------------------------------------------------*/
extern void xOutEnv( xSignalNode *SignalOut
#ifdef XPATH_INFO_IN_ENV_FUNC
  , xChannelIdNode Port
#endif
 )
{
  

     I_Void  *sndPtr    =NULL;
	  I_S32   msgSize    =ZERO;
	  I_U32   lclPidPtr  =INVALID_LCL_PID_PTR ;
	  I_S32   retVal     =ZERO;
	  I_U8    actClsId   =INVALID_ACT_CLASS_ID ;
	  I_U8    bicTei     =ZERO;
	  I_U8    conStatus  =ZERO;

#ifdef XTRACE
#ifdef XIDNAMES
  char  Temp[100];
  sprintf(Temp, "xOutEnv:  %s has been received by env\n",
          (*SignalOut)->NameNode->Name );
  xPrintString(Temp);
  LOG_PRINT(DEBUG," Signal Number Received :::: [[%d]] : xOutEnv ", (*SignalOut)->NameNode->SignalNumber);
#else
  xPrintString("xOutEnv:  One signal has been received by env\n");
#endif
#endif
switch((*SignalOut)->NameNode->SignalNumber)
{

						 /* Interface with CFG */
  case SN_OAMS_CCUH_CFG_ALARM_IND:
	  sndPtr = ((yPDP_sig_OAMS_CCUH_CFG_ALARM_IND)(*SignalOut))->Param1;
	  msgSize = ((yPDP_sig_OAMS_CCUH_CFG_ALARM_IND)(*SignalOut))->Param2;
	  if (sndPtr == NULL)
	  {
		  LOG_PRINT(DEBUG,"[ENV:]Received NULL Pointer from module,Returning without sending to FRM..") ;
		  xReleaseSignal(SignalOut);
		  return;
	  }
	  LOG_PRINT(DEBUG,"[ENV]Send OAMS_CCUH_CFG_ALARM_IND :: msgSize = %d  msgType = 0x%x",msgSize , ((SysHdr *)sndPtr)->msgType);
	  break;

  case SN_OAMS_CCUH_ABIHM_BIC_CC_INFO_REQ:
	  sndPtr = ((yPDP_sig_OAMS_CCUH_ABIHM_BIC_CC_INFO_REQ)(*SignalOut))->Param1;
	  msgSize = ((yPDP_sig_OAMS_CCUH_ABIHM_BIC_CC_INFO_REQ)(*SignalOut))->Param2;
	  if (sndPtr == NULL)
	  {
		  LOG_PRINT(DEBUG,"[ENV:]Received NULL Pointer from module,Returning without sending to FRM..") ;
		  xReleaseSignal(SignalOut);
		  return;
	  }
	  LOG_PRINT(DEBUG,"[ENV]Send OAMS_CCUH_ABIHM_BIC_CC_INFO_REQ :: msgSize = %d  msgType = 0x%x",msgSize , ((SysHdr *)sndPtr)->msgType);
	  break;

  case SN_OAMS_CCUH_ABIHM_BIC_SET_CC_CFG_REQ:
	  sndPtr = ((yPDP_sig_OAMS_CCUH_ABIHM_BIC_SET_CC_CFG_REQ)(*SignalOut))->Param1;
	  msgSize = ((yPDP_sig_OAMS_CCUH_ABIHM_BIC_SET_CC_CFG_REQ)(*SignalOut))->Param2;
	  if (sndPtr == NULL)
	  {
		  LOG_PRINT(DEBUG,"[ENV:]Received NULL Pointer from module,Returning without sending to FRM..") ;
		  xReleaseSignal(SignalOut);
		  return;
	  }
	  LOG_PRINT(DEBUG,"[ENV]Send OAMS_CCUH_ABIHM_BIC_SET_CC_CFG_REQ :: msgSize = %d  msgType = 0x%x",msgSize , ((SysHdr *)sndPtr)->msgType);
	  break;

  case SN_OAMS_CCUH_ABIHM_BIC_GET_CC_CFG_REQ:
	  sndPtr = ((yPDP_sig_OAMS_CCUH_ABIHM_BIC_GET_CC_CFG_REQ)(*SignalOut))->Param1;
	  msgSize = ((yPDP_sig_OAMS_CCUH_ABIHM_BIC_GET_CC_CFG_REQ)(*SignalOut))->Param2;
	  if (sndPtr == NULL)
	  {
		  LOG_PRINT(DEBUG,"[ENV:]Received NULL Pointer from module,Returning without sending to FRM..") ;
		  xReleaseSignal(SignalOut);
		  return;
	  }
	  LOG_PRINT(DEBUG,"[ENV]Send OAMS_CCUH_ABIHM_BIC_GET_CC_CFG_REQ :: msgSize = %d  msgType = 0x%x",msgSize , ((SysHdr *)sndPtr)->msgType);
	  break;

  case SN_OAMS_CCUH_ABIHM_BIC_CC_DATA_REQ:
	  sndPtr = ((yPDP_sig_OAMS_CCUH_ABIHM_BIC_CC_DATA_REQ)(*SignalOut))->Param1;
	  msgSize = ((yPDP_sig_OAMS_CCUH_ABIHM_BIC_CC_DATA_REQ)(*SignalOut))->Param2;
	  if (sndPtr == NULL)
	  {
		  LOG_PRINT(DEBUG,"[ENV:]Received NULL Pointer from module,Returning without sending to FRM..") ;
		  xReleaseSignal(SignalOut);
		  return;
	  }
	  LOG_PRINT(DEBUG,"[ENV]Send OAMS_CCUH_ABIHM_BIC_CC_DATA_REQ  :: msgSize = %d  msgType = 0x%x",msgSize , ((SysHdr *)sndPtr)->msgType);
	  break;

  case SN_OAMS_CCUH_ABIHM_BIC_CC_PWR_ORDER_REQ:
	  sndPtr = ((yPDP_sig_OAMS_CCUH_ABIHM_BIC_CC_PWR_ORDER_REQ)(*SignalOut))->Param1;
	  msgSize = ((yPDP_sig_OAMS_CCUH_ABIHM_BIC_CC_PWR_ORDER_REQ)(*SignalOut))->Param2;
	  if (sndPtr == NULL)
	  {
		  LOG_PRINT(DEBUG,"[ENV:]Received NULL Pointer from module,Returning without sending to FRM..") ;
		  xReleaseSignal(SignalOut);
		  return;
	  }
	  LOG_PRINT(DEBUG,"[ENV]Send OAMS_CCUH_ABIHM_BIC_CC_PWR_ORDER_REQ  :: msgSize = %d  msgType = 0x%x",msgSize , ((SysHdr *)sndPtr)->msgType);
	  break;

  case SN_OAMS_CCUH_PDC_BIC_CC_INFO_RESP:
	  sndPtr = ((yPDP_sig_OAMS_CCUH_PDC_BIC_CC_INFO_RESP)(*SignalOut))->Param1;                 
	  msgSize = ((yPDP_sig_OAMS_CCUH_PDC_BIC_CC_INFO_RESP)(*SignalOut))->Param2;                  
	  if (sndPtr == NULL)
	  {
		  LOG_PRINT(DEBUG,"[ENV:]Received NULL Pointer from module,Returning without sending to FRM..") ; 
		  xReleaseSignal(SignalOut);
		  return;
	  }
	  LOG_PRINT(DEBUG,"[ENV]Send OAMS_CCUH_PDC_BIC_CC_INFO_RESP  :: msgSize = %d  msgType = 0x%x",msgSize , ((SysHdr *)sndPtr)->msgType);
	  break;

  case SN_CCUH_INT_ADD_TAU_INST_IN_INSTMAP :
	  actClsId = ((yPDP_sig_CCUH_INT_ADD_TAU_INST_IN_INSTMAP)(*SignalOut))->Param1;
	  lclPidPtr = (I_U32)((*SignalOut)->Sender.LocalPId);
	  if ((retVal = AddTauInst(lclPidPtr, SELF_ENTITY_ID, actClsId)) != INST_SUCCESS)
	  {
		  LOG_PRINT(CRITICAL,"xOutEnv: AddTauInstId Failed lclPid = " \
				  "0x%x, [Act Cls Id = %d], [errCode = %d]",(I_U32)lclPidPtr, actClsId ,retVal);
	  }
	  else
	  {
		  LOG_PRINT(DEBUG,"xOutEnv :AddTauInstId Success lclPid = " \
				  "0x%x, [Act Cls Id = %d]",(I_U32)lclPidPtr, actClsId);
                /* CS4.0: HA changes start */
               gSignalSent--;
               LOG_PRINT(INFO, "gSignalSent: %d", gSignalSent);
               if ( gSignalSent == 0 && gInstancesCreated == I_FALSE )
               {
                  gCurrentCardState = gNewCardState;
                  gNewCardState = CARDSTATE_INVALID;
                  gInstancesCreated = I_TRUE;
                  LOG_PRINT(INFO,"CurrentCardState: [%d]", gCurrentCardState) ;
                  LOG_PRINT(INFO,"NewCardState:  [%d]", gNewCardState) ;
                  RELEASE_MUTEX;
                  LOG_PRINT(INFO,"Moving to ACTIVE.. ");
               }
               /* CS4.0: HA changes End */
	  }
	  xReleaseSignal(SignalOut);
	  return;

  case SN_CCUH_INT_FREE_INST :
	  actClsId = ((yPDP_sig_CCUH_INT_FREE_INST)(*SignalOut))->Param1;
	  lclPidPtr = (I_U32)((*SignalOut)->Sender.LocalPId);
	  if ((retVal = FreInstId(lclPidPtr, SELF_ENTITY_ID,actClsId)) != INST_SUCCESS)
	  {
		  LOG_PRINT(CRITICAL, "xOutEnv : FreeInstId() Failed lclPidPtr = 0x%x [Act Cls Id = %d], [errCode =%d]",lclPidPtr, actClsId,retVal);
	  }
	  else
	  {
		  LOG_PRINT(DEBUG, "xOutEnv : FreeInstId() Success lclPidPtr = 0x%x [Act Cls Id = %d]",lclPidPtr, actClsId);
	  }
	  xReleaseSignal(SignalOut);
	  return;


/* CS4.0: HA changes start */
      case SN_CCUH_INT_ACTIVE_CLASS_PID :
           gLclPidActiveClass = (I_U32)((*SignalOut)->Sender.LocalPId);
           LOG_PRINT(DEBUG, "xOutEnv : System class LCLPID: 0x%0x", \
                              gLclPidActiveClass);
           LOG_PRINT(DEBUG," [ENV]LocalPid for active class is %d",gLclPidActiveClass);
           xReleaseSignal(SignalOut);
           return;

        case SN_CCUH_INT_SELFCARD_STATE_CHANGE_RESP :
           LOG_PRINT(DEBUG, "xOutEnv : Received signal SN_CCUH_INT_SELFCARD_STATE_CHANGE_RESP");
           gSignalSent--;
           LOG_PRINT(INFO, "gSignalSent: %d", gSignalSent);
           if ( gSignalSent == 0 )
           {
              LOG_PRINT(INFO," Timers stopped for all the instances while going ACTIVE to INSERVICE/RECOVERY state ");
              activeStateHandler();
           }
           xReleaseSignal(SignalOut);
           return;

      /* CS4.0: HA changes End */

  default:
	  LOG_PRINT(DEBUG," Entered Default Case : xOutEnv \n");
	  sndPtr = ((yPDP_sig_OAMS_CCUH_CFG_ALARM_IND)(*SignalOut))->Param1;
	  if (sndPtr!=NULL)
	  {
		  DalocMsgBuf((I_Void *)sndPtr);
	  }
	  xReleaseSignal(SignalOut);
	  return;

}/*switch */

LOG_PRINT(DEBUG,"OUT OF SWITCH XOUT::ENV");
if (sndPtr != NULL)
{
	if (SendMsg(sndPtr, MSG_ORD_PRIO, msgSize) == SND_FAIL)
	{
		LOG_PRINT(MAJOR,"[ENV]SENDING FAILED");
		DalocMsgBuf((I_Void *)sndPtr);
		xReleaseSignal(SignalOut);
		return;
	}
	else
	{
		LOG_PRINT(DEBUG,"[ENV]Successfully sent message out");
		xReleaseSignal(SignalOut);
		return;
	}
}
else
{
	LOG_PRINT(CRITICAL,"[ENV]CCUH: UNABLE TO ALLOCATE MEMORY FOR THE MESSAGE, sndPtr is NULL");
}
/* Signals going to the env via the port ToEnv  */

}/*xOutEnv*/





/*---+---------------------------------------------------------------
  Macros for xInEnv
  -------------------------------------------------------------------*/
#ifndef IN_LOCAL_VARIABLES
#define IN_LOCAL_VARIABLES \
	xSignalNode SignalIn;
#endif

#ifndef IN_SIGNAL1
#define IN_SIGNAL1(SIGNAL_NAME, SIGNAL_NAME_STRING) \
	SignalIn = xGetSignal(SIGNAL_NAME, xNotDefPId, xEnv);
#endif

#ifndef IN_SIGNAL2
#define IN_SIGNAL2(SIGNAL_NAME, SIGNAL_NAME_STRING) \
	SDL_Output(SignalIn xSigPrioPar(xDefaultPrioSignal), (xIdNode *)0);
#endif

#ifndef IF_IN_SIGNAL
#define IF_IN_SIGNAL(SIGNAL_NAME, SIGNAL_NAME_STRING) \
	if (TEST_IF_IN_SIGNAL(SIGNAL_NAME)) {
#define END_IF_IN_SIGNAL(SIGNAL_NAME, SIGNAL_NAME_STRING) \
	}
#endif

#ifndef TEST_IF_IN_SIGNAL
#define TEST_IF_IN_SIGNAL(SIGNAL_NAME)  0
#endif

#ifndef XENV_DEC
#define XENV_DEC(stmt) stmt
#endif

#ifndef XENV_IN_START
#define XENV_IN_START
#endif

#ifndef XENV_IN_END
#define XENV_IN_END
#endif


/*---+---------------------------------------------------------------
  xInEnv  extern
  -------------------------------------------------------------------*/
#ifndef XTENV
extern void xInEnv ( SDL_Time Time_for_next_event )
#else
extern SDL_Duration xInEnv ( SDL_Time Time_for_next_event )
#endif
{
		  xSignalNode S;

#ifdef XTRACE
#ifndef XNOXINENVTRACE
		  xPrintString( "xInEnv: Called!\n");
#endif
#endif
 I_Void         *rcvPtr     =NULL;
 I_Void         *rcvPtr1     =NULL;
 I_S32          msgSize     =ZERO;
 I_S32          instId      =INVALID_INST_ID;
 I_U16          msgType     =ZERO;
 I_U8           subType     =ZERO;
 SDL_Pid        rcvr;
 I_U32          lclPidPtr   =INVALID_LCL_PID_PTR;
 CsappAbihmCcuhBicCcInfoResp *myptr;
 I_U32          ccuId       =ZERO;
 I_U32          bicId       =ZERO;
 I_U32          fromCcuId   =ZERO;
 I_U8           numCcu      =ZERO;
 I_U8           count;
 I_U16          errCode;
 CsappAbihmCcuhBicBscAlarmInd* bicBscAlarmInd;
 struct sAisParam *param;

 if ((rcvPtr = (I_Void *)RecvMsg(selfEntIdG, &msgSize)) != NULL)
    {
         msgType = ((SysHdr *)rcvPtr)->msgType;
	 subType = ((SysHdr *)rcvPtr)->subType;
	 instId = ((SysHdr *)rcvPtr)->dest.inst;
	 LOG_PRINT(DEBUG,"[ENV]Messgae Received for CCUH msgTyp = 0x%x and \
			 subType = %d",msgType,subType);
	 rcvr.GlobalNodeNr = (I_S32)selfEntIdG;
	 rcvr.LocalPId = (xLocalPIdNode)0;
	 lclPidPtr = INVALID_LCL_PID_PTR;
 	/* CS4.0: Changes for HA Start */
      if ( gCurrentCardState == CARDSTATE_ACTIVE )
      {
         /* CS4.0: Changes for HA End */
 
      switch(msgType)
	 	{
		    /* Send this Message into TAU model */
	    case CSAPP_ABIHM_CCUH_BIC_BSC_ALARM_IND:
		    {
		           LOG_PRINT(DEBUG,"xInEnv : CSAPP_ABIHM_CCUH_BIC_BSC_ALARM_IND \
			    received");
                             
                            LOG_PRINT(INFO,"getting ccuid");
			   					 ccuId = GetRefIdByCCUId(rcvPtr) ;
                            LOG_PRINT(INFO,"getting Bicid");
                            bicId = GetRefIdByBicId(rcvPtr) ;
			   /* errCode=getBicIdFromBicCcInfoTable(ccuId,&bicId);
			    if(CLIB_SUCCESS != errCode)
			    {
				    LOG_PRINT(CRITICAL,"Error in getBicCcInfoTable: err = %s",clib_strerror(errCode));
				    return;
			    }*/
                           bicBscAlarmInd = (CsappAbihmCcuhBicBscAlarmInd *)rcvPtr;
				LOG_PRINT(DEBUG, "xInEnv : Alarm cause rcvd from BIC is %d",bicBscAlarmInd->alarmCause);
			   if ( bicBscAlarmInd->alarmCause == CCU_ALARM_BIC_CC_CONNECTED_OK && ccuId > 0)
			    {


			    	if (AlocNewInst(&lclPidPtr, &instId, SELF_ENTITY_ID,CCUH_ACT_CLID,ccuId,bicId, ZERO, ZERO, ZERO)  != INST_SUCCESS)
			    	{
				    LOG_PRINT(CRITICAL, "xInEnv : AlocNewInst() Failed for CCUH");
				    DalocMsgBuf((I_Void *)rcvPtr) ;
				    return;
			    	}
			    	LOG_PRINT(DEBUG, "xInEnv : NEW INSTANCE ALLOCATED FOR CCUH  \
					    LCLPID: 0x%0x, INSTANCE-ID: %d, CCU-ID: %u ,BIC-ID: %u",
					    lclPidPtr, instId,ccuId,bicId);
			    	rcvr.LocalPId = (xLocalPIdNode)lclPidPtr;
			    }
			    else
			    {
				//find the instance and send alarm in	
       	                        if ((rcvr.LocalPId = (xLocalPIdNode)FindCcuhLocalPidPtrByCCUId(rcvPtr)) == INVALID_LCL_PID_PTR)
                                {
                                    LOG_PRINT(DEBUG,"[ENV]Failed to find Instance for Incoming request");
                                    DalocMsgBuf((I_Void *)rcvPtr) ;
                                    return ;
                                }
			    }

			    	S = xGetSignal( sig_CSAPP_ABIHM_CCUH_BIC_BSC_ALARM_IND, rcvr, xEnv);
			    	(((yPDP_sig_CSAPP_ABIHM_CCUH_BIC_BSC_ALARM_IND)S)->Param1) = rcvPtr;
			    break;
		    }


		    /* case OAMS_BICH_CCUH_LAPD_LINK_DOWN:
		       {
		       LOG_PRINT(DEBUG,"[ENV]OAMS_BICH_CCUH_LAPD_LINK_DOWN: signal received from BICH");
		       if ((rcvr.LocalPId = (xLocalPIdNode)FindCcuhLocalPidPtrByBicId(rcvPtr)) == INVALID_LCL_PID_PTR)
		       {
		       LOG_PRINT(DEBUG,"[ENV]Failed to find Instance for Incoming request");
		       DalocMsgBuf((I_Void *)rcvPtr) ;
		       return ;
		       }
		       S = xGetSignal( sig_OAMS_BICH_CCUH_LAPD_LINK_DOWN, rcvr, xEnv);
		       (((yPDP_sig_OAMS_BICH_CCUH_LAPD_LINK_DOWN)S)->Param1) = rcvPtr;
		       break;
		       }*/

	    case OAMS_BICH_CCUH_LAPD_LINK_UP:
			    LOG_PRINT(DEBUG,"[ENV]OAMS_BICH_CCUH_LAPD_LINK_UP: signal received from BICH");
			    /*if ((rcvr.LocalPId = (xLocalPIdNode)FindCcuhLocalPidPtrByBicId(rcvPtr)) == INVALID_LCL_PID_PTR)
			    {
				    LOG_PRINT(DEBUG,"[ENV]Failed to find Instance for Incoming request");
				    DalocMsgBuf((I_Void *)rcvPtr) ;
				    return ;
			    }*/
			    //S = xGetSignal( sig_OAMS_BICH_CCUH_LAPD_LINK_UP, rcvr, xEnv);
			    //(((yPDP_sig_OAMS_BICH_CCUH_LAPD_LINK_UP)S)->Param1) = rcvPtr;
				 DalocMsgBuf((I_Void *)rcvPtr) ;
			    LOG_PRINT(DEBUG,"[ENV]free msgbuffer successfully for LAPD_LINK_UP");
				 return;
	    case OAMS_BICH_CCUH_LAPD_LINK_DOWN:
		    {
			    LOG_PRINT(DEBUG,"[ENV]OAMS_BICH_CCUH_LAPD_LINK_DOWN: signal received from BICH");
			    LOG_PRINT(DEBUG,"[ENV]OAMS_BICH_CCUH_LAPD_LINK_DOWN: value of localPid is :: %d", rcvr.LocalPId);
			    rcvr.LocalPId = (xLocalPIdNode)FindCcuhLocalPidPtrByBicId(rcvPtr);
			    LOG_PRINT(DEBUG,"[ENV]OAMS_BICH_CCUH_LAPD_LINK_DOWN: value of localPid is :: %d", rcvr.LocalPId);
			    if ((rcvr.LocalPId = (xLocalPIdNode)FindCcuhLocalPidPtrByBicId(rcvPtr)) == INVALID_LCL_PID_PTR)
			    {
				    LOG_PRINT(DEBUG,"[ENV]Failed to find Instance for Incoming request");
				    DalocMsgBuf((I_Void *)rcvPtr) ;
				    return ;
			    }
			    LOG_PRINT(DEBUG,"[ENV]Sending signal to tau");
			    S = xGetSignal( sig_OAMS_BICH_CCUH_LAPD_LINK_DOWN, rcvr, xEnv);
			    LOG_PRINT(DEBUG,"[ENV]Sending signal to tau");
			    (((yPDP_sig_OAMS_BICH_CCUH_LAPD_LINK_DOWN)S)->Param1) = rcvPtr;
			    LOG_PRINT(DEBUG,"[ENV]Sending signal to tau");
			    break;
		    }

	    case CSAPP_ABIHM_CCUH_BIC_CC_INFO_RESP:
		    {
			    LOG_PRINT(DEBUG,"[ENV]CSAPP_ABIHM_CCUH_BIC_CC_INFO_RESP: signal received from ABIHM");
			    if ((rcvr.LocalPId = (xLocalPIdNode)FindCcuhLocalPidPtrByCCUId(rcvPtr)) == INVALID_LCL_PID_PTR)
			    {
				    LOG_PRINT(DEBUG,"[ENV]Failed to find Instance for Incoming request");
				    DalocMsgBuf((I_Void *)rcvPtr) ;
				    return ;
			    }
			    S = xGetSignal( sig_CSAPP_ABIHM_CCUH_BIC_CC_INFO_RESP, rcvr, xEnv);
			    (((yPDP_sig_CSAPP_ABIHM_CCUH_BIC_CC_INFO_RESP)S)->Param1) = rcvPtr;
                            myptr=(CsappAbihmCcuhBicCcInfoResp *)rcvPtr;
                            LOG_PRINT(INFO,"*************Result is %d",myptr->result);
			    break;

		    }

	    case CSAPP_ABIHM_CCUH_BIC_CC_DATA_RESP:
		    {
			    LOG_PRINT(DEBUG,"[ENV]CSAPP_ABIHM_CCUH_BIC_CC_DATA_RESP: signal received from ABIHM");
			    if ((rcvr.LocalPId = (xLocalPIdNode)FindCcuhLocalPidPtrByCCUId(rcvPtr)) == INVALID_LCL_PID_PTR)
			    {
				    LOG_PRINT(DEBUG,"[ENV]Failed to find Instance for Incoming request");
				    DalocMsgBuf((I_Void *)rcvPtr) ;
				    return ;
			    }
			    S = xGetSignal( sig_CSAPP_ABIHM_CCUH_BIC_CC_DATA_RESP, rcvr, xEnv);
			    (((yPDP_sig_CSAPP_ABIHM_CCUH_BIC_CC_DATA_RESP)S)->Param1) = rcvPtr;
			    break;
		    }

	    case CSAPP_ABIHM_CCUH_BIC_CC_DATA_NACK:
		    {
			    LOG_PRINT(DEBUG,"[ENV]CSAPP_ABIHM_CCUH_BIC_CC_DATA_NACK: signal received from ABIHM");
			    if ((rcvr.LocalPId = (xLocalPIdNode)FindCcuhLocalPidPtrByCCUId(rcvPtr)) == INVALID_LCL_PID_PTR)
			    {
				    LOG_PRINT(DEBUG,"[ENV]Failed to find Instance for Incoming request");
				    DalocMsgBuf((I_Void *)rcvPtr) ;
				    return ;
			    }
			    S = xGetSignal( sig_CSAPP_ABIHM_CCUH_BIC_CC_DATA_NACK, rcvr, xEnv);
			    (((yPDP_sig_CSAPP_ABIHM_CCUH_BIC_CC_DATA_NACK)S)->Param1) = rcvPtr;
			    break;
		    }

	    case OAMS_CFG_CCUH_BIC_CC_INFO_REQ:
		    {
			    LOG_PRINT(DEBUG,"[ENV]OAMS_CFG_CCUH_BIC_CC_INFO_REQ : signal received from CFG");
			    if ((rcvr.LocalPId = (xLocalPIdNode)FindCcuhLocalPidPtrByCCUId(rcvPtr)) == INVALID_LCL_PID_PTR)
			    {
				    LOG_PRINT(DEBUG,"[ENV]Failed to find Instance for Incoming request");
				    DalocMsgBuf((I_Void *)rcvPtr) ;
				    return ;
			    }
			    S = xGetSignal( sig_OAMS_CFG_CCUH_BIC_CC_INFO_REQ, rcvr, xEnv);
			    (((yPDP_sig_OAMS_CFG_CCUH_BIC_CC_INFO_REQ)S)->Param1) = rcvPtr;
			    break;
		    }
	    case OAMS_CFG_CCUH_BIC_SET_CC_CFG_REQ:
		    {
			    LOG_PRINT(DEBUG,"[ENV]OAMS_CFG_CCUH_BIC_SET_CC_CFG_REQ : signal received from CFG");
			    if ((rcvr.LocalPId = (xLocalPIdNode)FindCcuhLocalPidPtrByCCUId(rcvPtr)) == INVALID_LCL_PID_PTR)
			    {
				    LOG_PRINT(DEBUG,"[ENV]Failed to find Instance for Incoming request");
				    DalocMsgBuf((I_Void *)rcvPtr) ;
				    return ;
			    }
			    S = xGetSignal( sig_OAMS_CFG_CCUH_BIC_SET_CC_CFG_REQ, rcvr, xEnv);
			    (((yPDP_sig_OAMS_CFG_CCUH_BIC_SET_CC_CFG_REQ)S)->Param1) = rcvPtr;
			    break;
		    }

	    case CSAPP_ABIHM_CCUH_BIC_SET_CC_CFG_RESP:
		    {
			    LOG_PRINT(DEBUG,"[ENV]CSAPP_ABIHM_CCUH_BIC_SET_CC_CFG_RESP : signal received from ABIHM");
			    if ((rcvr.LocalPId = (xLocalPIdNode)FindCcuhLocalPidPtrByCCUId(rcvPtr)) == INVALID_LCL_PID_PTR)
			    {
				    LOG_PRINT(DEBUG,"[ENV]Failed to find Instance for Incoming request");
				    DalocMsgBuf((I_Void *)rcvPtr) ;
				    return ;
			    }
			    S = xGetSignal( sig_CSAPP_ABIHM_CCUH_BIC_SET_CC_CFG_RESP, rcvr, xEnv);
			    (((yPDP_sig_CSAPP_ABIHM_CCUH_BIC_SET_CC_CFG_RESP)S)->Param1) = rcvPtr;
			    break;
		    }


	    case CSAPP_ABIHM_CCUH_BIC_GET_CC_CFG_RESP:
		    {
			    LOG_PRINT(DEBUG,"[ENV]CSAPP_ABIHM_CCUH_BIC_GET_CC_CFG_RESP : signal received from ABIHM");
			    if ((rcvr.LocalPId = (xLocalPIdNode)FindCcuhLocalPidPtrByCCUId(rcvPtr)) == INVALID_LCL_PID_PTR)
			    {
				    LOG_PRINT(DEBUG,"[ENV]Failed to find Instance for Incoming request");
				    DalocMsgBuf((I_Void *)rcvPtr) ;
				    return ;
			    }
			    S = xGetSignal( sig_CSAPP_ABIHM_CCUH_BIC_GET_CC_CFG_RESP, rcvr, xEnv);
			    (((yPDP_sig_CSAPP_ABIHM_CCUH_BIC_GET_CC_CFG_RESP)S)->Param1) = rcvPtr;
			    break;
		    }

	    case OAMS_CFG_CCUH_BIC_CC_DATA_REQ:
		    {
			    LOG_PRINT(DEBUG,"[ENV]OAMS_CFG_CCUH_BIC_CC_DATA_REQ : signal received from CFG");
			    if ((rcvr.LocalPId = (xLocalPIdNode)FindCcuhLocalPidPtrByCCUId(rcvPtr)) == INVALID_LCL_PID_PTR)
			    {
				    LOG_PRINT(DEBUG,"[ENV]Failed to find Instance for Incoming request");
				    DalocMsgBuf((I_Void *)rcvPtr) ;
				    return ;
			    }
			    S = xGetSignal( sig_OAMS_CFG_CCUH_BIC_CC_DATA_REQ, rcvr, xEnv);
			    (((yPDP_sig_OAMS_CFG_CCUH_BIC_CC_DATA_REQ)S)->Param1) = rcvPtr;
			    break;
		    }

	    case OAMS_CFG_CCUH_BIC_CC_PWR_ORDER_REQ:
		    {
			    LOG_PRINT(DEBUG,"[ENV]OAMS_CFG_CCUH_BIC_CC_PWR_ORDER_REQ : signal received from CFG");
			    if ((rcvr.LocalPId = (xLocalPIdNode)FindCcuhLocalPidPtrByCCUId(rcvPtr)) == INVALID_LCL_PID_PTR)
			    {
				    LOG_PRINT(DEBUG,"[ENV]Failed to find Instance for Incoming request");
				    DalocMsgBuf((I_Void *)rcvPtr) ;
				    return ;
			    }
			    S = xGetSignal( sig_OAMS_CFG_CCUH_BIC_CC_PWR_ORDER_REQ, rcvr, xEnv);
			    (((yPDP_sig_OAMS_CFG_CCUH_BIC_CC_PWR_ORDER_REQ)S)->Param1) = rcvPtr;
			    break;
		    }

	    case OAM_PDC_CCUH_BIC_CC_INFO_REQ:
		    {
			    LOG_PRINT(DEBUG,"[ENV]OAM_PDC_CCUH_BIC_CC_INFO_REQ: signal received from PDC");
			    if ((rcvr.LocalPId = (xLocalPIdNode)FindCcuhLocalPidPtrByCCUId(rcvPtr)) == INVALID_LCL_PID_PTR)
			    {
				    LOG_PRINT(DEBUG,"[ENV]Failed to find Instance for Incoming request");
				    DalocMsgBuf((I_Void *)rcvPtr) ;
				    return ;
			    }
			    S = xGetSignal( sig_OAM_PDC_CCUH_BIC_CC_INFO_REQ, rcvr, xEnv);
			    (((yPDP_sig_OAM_PDC_CCUH_BIC_CC_INFO_REQ)S)->Param1) = rcvPtr;
			    break;
		    }
            #if BPM_PRESENT != 1
	    case BPM_SELFCARD_STATE_CHANGE:
		    {
			    LOG_PRINT(DEBUG,"[ENV]BPM_SELFCARD_STATE_CHANGE: signal received from BPM");
			    param = (struct sAisParam *)(rcvPtr+sizeof(SysHdr));
			    cardStateChangeHandler(param); 
			    DalocMsgBuf((I_Void *)rcvPtr) ;
			    return;
		    }
            #endif 


		    /* Default */
	    default:
		    LOG_PRINT(DEBUG," Entered Default Case : xInEnv");
		    DalocMsgBuf((I_Void *)rcvPtr) ;
		    return ;

	 }
			    LOG_PRINT(DEBUG,"[ENV]Sending signal to tau");
	 SDL_Output( S xSigPrioPar(xDefaultPrioSignal), (xIdNode *)0 );
			    LOG_PRINT(DEBUG,"[ENV]Sending signal to tau");
    }	
    else
    {
              #if BPM_PRESENT != 1
	      if ( msgType == BPM_SELFCARD_STATE_CHANGE )
	      {
		      LOG_PRINT(DEBUG,"[ENV]BPM_SELFCARD_STATE_CHANGE: signal received from BPM");
		      param = (struct sAisParam *)(rcvPtr+sizeof(SysHdr));
		      cardStateChangeHandler(param); 
		      DalocMsgBuf((I_Void *)rcvPtr) ;
		      return;
	      }
#endif  
	      LOG_PRINT(DEBUG," Card is not in Active..... Dalocating message ");
	      DalocMsgBuf((I_Void *)rcvPtr) ;
	      return ;
    }

}
#ifdef XTENV
 return SDL_Time_Lit((xint32)0,(xint32)0);
#endif

}
