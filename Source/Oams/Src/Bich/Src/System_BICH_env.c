
  /* SKELETON for env functions */
  /* Program generated by Cadvanced 3.0.0.0.2032 */
#define XSCT_CADVANCED

#define C_TRANSLATOR_2_6
#include "scttypes.h"
#ifdef XUSE_SIGNAL_NUMBERS
#include "System_BICH.hs"
#endif
#ifdef XENV_INC
#include XENV_INC
#endif
#include "System_BICH.ifc"

  /*****************************/
  /* Module Specific Macros */
#define SELF_ENTITY_ID ENT_OAMS_BICH
#define SELF_ENTITY_NAME "BICHM"
  /*****************************/
#include<oamsxxx_listdefs.h>
#include<oamsxxx_treedefs.h>
#include<oamsbich_abis_chain_mgr.h>
#include<string.h>
#include<CLIB.h>

  /* CS4.0: Changes for HA Start */
  I_Void reg_sig_hndlr(I_Void);
  I_S32 gCurrentCardState = CARDSTATE_INIT;
  I_S32 gNewCardState = CARDSTATE_INVALID;
  I_U32 gLclPidActiveClass = INVALID_LCL_PID_PTR ;
  I_U32 gInstancesCreated  = I_FALSE ;
  I_U32 gSignalSent = ZERO;
  I_S32 gInvocation;
  /* Added For HA ABIS */
  I_S32 gIsStandbyCard = I_FALSE; 
  I_S32 gCardStateDiagnostic = I_FALSE; 
  I_S32 gBpmAipRcvd = I_FALSE; 
  I_S32 gRmAipRcvd = I_FALSE; 
  OamsCfgBichAddBicReq *retMsgPtr=NULL;
  I_U32 gHandleMsgAllowed = I_FALSE;

  /* Defining Mutex */
  DEFINE_MUTEX;
  /* CS4.0: Changes for HA End */

#ifndef XNOGLOBALNODENUMBER
  /*---+---------------------------------------------------------------
       xGlobalNodeNumber  extern
  -------------------------------------------------------------------*/
#ifndef XENV_NODENUMBER
#define XENV_NODENUMBER return 1;
#endif
  I_S32  selfEntIdG ;
  //I_Bool abisChainsInitialized = I_FALSE;
  extern int xGlobalNodeNumber(void)
  {
     /* Assign a unique global system Id to each SDL system in a cluster of systems. */
     return ENT_OAMS_BICH ;
     /*  XENV_NODENUMBER  */
  }
#endif

    /**
    * Interface with Base Platform Module (BPM)
    * Note1: BPM is an optional feature in the system.
    * All code pertaining to BPM interface should be under a compile time
    * flag.
    */


#if BPM_PRESENT != 1

     #define RegisterBichWithBpm() bpmGetComponentReg(ENT_OAMS_BICH_STUB,&BichBpmCallbackFunc); 
     /* CS4.0: Changes for HA Start */
     #define bpmRespondToAis(a,b) 
     /* CS4.0: Changes for HA End */
     #warning "BPM support not compiled"
#else
  void BichBpmCallbackFunc (struct sAisParam *param);
  void RegisterBichWithBpm(void) 
  {
     bpmGetComponentRegister (BichBpmCallbackFunc, APPID_OAMS_BICHM);
     bpmComponentConfigure ();
  }
#endif //   BPM_PRESENT

  void BichBpmCallbackFunc (struct sAisParam *param)
  {

     switch (param->messageId)
     {
        case BPM_HEALTHCHECK_MESSAGE:
             bpmRespondToAis (param->invocation, OK);
             break;

        case BPM_SELFCARD_STATE_CHANGE:
             /* CS4.0: Changes for HA Start*/
             LOCK_MUTEX;
             LOG_PRINT(DEBUG, "BichBpmCallbackFunc: MUTEX is Locked");
             cardStateChangeHandler(param);
             if ( LOCK_MUTEX_AND_WAIT != MUTEX_WAIT_COMPLETE )
             {
                LOG_PRINT(INFO,"calling bpmRespondToAis.. ");
                bpmRespondToAis (param->invocation, OK);
                LOG_PRINT(INFO,"Moving to CARD_STATE: [%d]",param->cardState);
             } 
             else
             {
                LOG_PRINT(CRITICAL,"MUTEX Wait Timed Out.. Not sending OK notification");
             }
             RELEASE_MUTEX;
             /* CS4.0: Changes for HA End*/
             break;

        case BPM_PEERCARD_STATE_CHANGE:
             LOG_PRINT(DEBUG, "BPM_PEERCARD_STATE_CHANGE recd, No Action Taken");
             bpmRespondToAis (param->invocation, OK);
             break;

        case BPM_MSG_ACK_PEER_HEALTH_BAD:
             LOG_PRINT(DEBUG, "BPM_MSG_ACK_PEER_HEALTH_BAD recd, Not Expected");
             break;

        case BPM_MSG_ACK_CONFIGURE:
             LOG_PRINT(DEBUG, "BPM_MSG_ACK_CONFIGURE recd");
             break;

        case BPM_MSG_ACK_CONFIGURE_RESET:
             LOG_PRINT(DEBUG, "BPM_MSG_ACK_CONFIGURE_RESET recd, No Action Taken");
             break;

        case BPM_SHUTDOWN:
             LOG_PRINT(DEBUG, "BPM_SHUTDOWN recd, Exiting");
             exit (1);
             break;

        default:
             LOG_PRINT(MAJOR, "Unexpected msg from BPM: %d", param->messageId);
             break;
     }
  }

  /********************************************************************/
  /* Added for HA ABIS BSC-R2.5.5  Start*/
  /****************************************************************************************************************/
  I_U32  prepareAddBicRequestRcvPtr(I_U32 bicId,I_U32 e1Id ,I_U32 btsType,I_U32 adminState)
  {
  BtsContextTableIndices         inDataBtsContextTable = {0};
  BtsContextTableApi						 *outDataBtsContextTable;
  OamsBichStandbyCardContext     *bichContext = NULL;
  I_S32 												  errCode;

  /* Allocate memory to msgPtr */
  OamsCfgBichAddBicReq *msgPtr = (OamsCfgBichAddBicReq *)AlocMsgBuf(sizeof (OamsCfgBichAddBicReq) );
  if (!msgPtr ) {
      LOG_PRINT(CRITICAL,"ENV: Could Not allocate memory for OamsCfgBichAddBicReq ");
      return I_FALSE;
    }
  /* Allocate memory to bichContext */
  bichContext = (OamsBichStandbyCardContext *)AlocOrdBuf(sizeof(OamsBichStandbyCardContext));
  if (bichContext == NULL ) {
      LOG_PRINT(CRITICAL,"ENV: Could Not allocate memory for OamsBichStandbyCardContext ");
      DalocMsgBuf((I_Void *)msgPtr);
      return I_FALSE;
    }

  inDataBtsContextTable.btsId=bicId;
  /* Db Query to get Context data for Bic */
  errCode = getBtsContextTable(&inDataBtsContextTable,&outDataBtsContextTable);
  if(errCode != CLIB_SUCCESS)
      {
      LOG_PRINT(INFO,"get of context failed for bicId : %d",bicId);
      DalocOrdBuf((I_Void *)bichContext);
      DalocMsgBuf((I_Void *)msgPtr);
      return I_FALSE;
      }
  /* Copy Context Data */
  memcpy(bichContext,outDataBtsContextTable->data,sizeof(OamsBichStandbyCardContext));
  /* print Context data */
  LOG_PRINT(INFO,"Context :e1Ts (%d), bicTei (%d) , bicId (%d)",bichContext->e1Ts,bichContext->bicTei,bicId);
  retMsgPtr = ((OamsCfgBichAddBicReq *)msgPtr);

  /* Filling SysHdr */
  FILL_SYS_HDR(msgPtr,
                 OAMS_CFG_BICH_ADD_BIC_REQ,
                 MSG_SUB_TYPE,
                 PRCR_CP,
                 ENT_OAMS_BICH,
                 ZERO ,
                 PRCR_CP,
                 ENT_OAMS_BICH,
                 ZERO);

  /* Filling msgPtr */
  msgPtr->bicId = bicId; 
  msgPtr->e1Id = e1Id;
  msgPtr->e1Ts = bichContext->e1Ts;
  msgPtr->btsType = btsType;
  msgPtr->adminState = adminState;
  msgPtr->applTei = bichContext->bicTei;

  LOG_PRINT(INFO,"retMsgPtr :e1Ts (%d), bicTei (%d) , bicId (%d)",retMsgPtr->e1Ts,retMsgPtr->applTei,retMsgPtr->bicId);
  /* freeing Context data pointer*/
  if(outDataBtsContextTable != NULL)
  {
    free(outDataBtsContextTable);	
    LOG_PRINT(INFO,"freed outDataBtsContextTable");
  }
  DalocOrdBuf((I_Void *)bichContext);

    
  return I_TRUE;
  }

  I_S32 sendBichRmAipResp(void)
  {
    I_PVoid  sndAipPtr = NULL;
    I_U32    msgAipSize = ZERO;

  msgAipSize = sizeof(OamsBichRmAipResp);
  sndAipPtr = (OamsBichRmAipResp *)(AlocMsgBuf(msgAipSize));

  if(sndAipPtr == NULL)
  {
      LOG_PRINT(CRITICAL,"sendBichRmAipResp: Memory Alloc Fail");
      return I_FALSE;
  }

  FILL_SYS_HDR(sndAipPtr, OAMS_BICHM_RM_AIP_RESP, 0, 0, ENT_OAMS_BICH, 0, 0, ENT_OAMS_RM, 0);

  if (SendMsg(sndAipPtr, MSG_ORD_PRIO, msgAipSize) == SND_FAIL) {
        LOG_PRINT(MAJOR,"xOutEnv : Snd. Fail.Message OAMS_BICHM_RM_AIP_RESP");
        return I_FALSE;
      }

  LOG_PRINT(INFO," Snd. Message Success: OAMS_BICHM_RM_AIP_RESP");
  return I_TRUE;
  }

  I_S32 sendBichRmActiveResp(void)
  {
    I_PVoid  sndActPtr = NULL;
    I_U32    msgActSize = ZERO;

  msgActSize = sizeof(OamsBichRmActiveResp);
  sndActPtr = (OamsBichRmActiveResp *)(AlocMsgBuf(msgActSize));

  if(sndActPtr == NULL)
  {
      LOG_PRINT(CRITICAL,"sendBichRmActiveResp: Memory Alloc Fail");
      return I_FALSE;
  }

  FILL_SYS_HDR(sndActPtr, OAMS_BICHM_RM_ACTIVE_RESP, 0, 0, ENT_OAMS_BICH, 0, 0, ENT_OAMS_RM, 0);

  if (SendMsg(sndActPtr, MSG_ORD_PRIO, msgActSize) == SND_FAIL) {
        LOG_PRINT(MAJOR,"xOutEnv : Snd. Fail.Message OAMS_BICHM_RM_ACTIVE_RESP");
        return I_FALSE;
      }

  LOG_PRINT(INFO," Snd. Message Success: OAMS_BICHM_RM_ACTIVE_RESP");
  return I_TRUE;
  }

  I_U32 handleRmBichAipReq()
  {
     I_U32                     outCount = ZERO;
     I_U16                     outSize = ZERO;
     I_S32                     retCode = ZERO;
     I_U32                     lclPidPtr = INVALID_LCL_PID_PTR ;
     I_U32                     instId = INVALID_INST_ID ;
     I_U32                     index = ZERO;
     I_S8                      instCountResult = ZERO;
     I_U16                     instCount = ZERO;
     SDL_Pid                   rcvr;
     xSignalNode               S;
     BicTableApi        			 *bicTablePtr = NULL; 
     BicTableApi         			 *bicTempPtr = NULL; 
     I_U32										 	retResult;
     I_U32										 	retRefId = INVALID_REF_ID;
     I_U32										 	*e1Num = NULL;
     I_U32										 	e1RecCount;
     I_U32										 	i = ZERO;
     OamsCfgBichInitAbisE1 		 oamsCfgBichInitAbisE1 ;

              selfEntIdG = (int)ENT_OAMS_BICH;
              rcvr.GlobalNodeNr = (I_S32)selfEntIdG;
              rcvr.LocalPId = (xLocalPIdNode)0;
              
                /* Initialize Abis E1 */
               if(getE1NumTrunkTable(SYS_E1_USAGE_ABISIF, &e1Num, &e1RecCount) == DBLIB_SUCCESS)
               {
                  for(i = 0; i < e1RecCount; i++)
                    {
                      oamsCfgBichInitAbisE1.e1Id = e1Num[i];
                      initAbisChain(&oamsCfgBichInitAbisE1); 
                    }
                  free(e1Num);
               }
    
              retCode = getallBicTable( &bicTablePtr, &outCount, &outSize);
              if ( retCode != CLIB_SUCCESS )
              {
                LOG_PRINT(LOG_INFO,"activeInProgressStateHandler: No BIC configured");
              }
              else
              {
      
                for (index = 0; index < outCount ; index ++)
                {
                  /* Initialize */
                  lclPidPtr = INVALID_LCL_PID_PTR;
                  retRefId = INVALID_REF_ID;
                  instId = INVALID_INST_ID ;
        
                  bicTempPtr = (BicTableApi*)((I_U8*)(bicTablePtr) + index*outSize);
                  retRefId = bicTempPtr->bicId;
                  
               /* R2.9 changes starts */
                
                if (SearchAlocatedInst(&lclPidPtr,&instId,ENT_OAMS_BICH,BIC_HANDLER,retRefId,ZERO,ZERO,ZERO,ZERO)                     != INST_SUCCESS)
                 {
                   LOG_PRINT(CRITICAL,"[ENV]No BICHandler Ins found for BIC ID = [%u]",bicTempPtr->bicId);
                   
                   if(AlocNewInst(&lclPidPtr, &instId, SELF_ENTITY_ID,
                              BICHM_ACT_CLID,retRefId,
                              ZERO, ZERO, ZERO, ZERO)  != INST_SUCCESS) 
                   {
                      LOG_PRINT(CRITICAL, "xInEnv : AlocNewInst() Failed for BICHM");
                      gCurrentCardState = gNewCardState; 
                      gNewCardState = CARDSTATE_INVALID;
                      gBpmAipRcvd = I_FALSE;
                      gRmAipRcvd = I_FALSE;
                      sendBichRmAipResp();
                      LOG_PRINT(INFO,"[handleRmBichAipReq]CurrentCardState: [%d]", gCurrentCardState) ; 
                      LOG_PRINT(INFO,"[handleRmBichAipReq]NewCardState: [%d]", gNewCardState) ;
                      RELEASE_MUTEX;
                      return; 
                   }
                   else
                   {  
                     LOG_PRINT(DEBUG, "xInEnv : NEW INSTANCE ALLOCATED FOR BICHM  \
                            LCLPID: 0x%0x, INSTANCE-ID: %d, BIC-ID: %u",
                                lclPidPtr, instId, retRefId);
                   }
                }	
                else
                {
                  LOG_PRINT(DEBUG, "xInEnv : ALLOCATED INSTANCE SEARCHED FOR BICHM  \
                            LCLPID: 0x%0x, INSTANCE-ID: %d, BIC-ID: %u",
                                lclPidPtr, instId, retRefId);
                }
                
                if (0 == lclPidPtr)
                {
                   LOG_PRINT(CRITICAL,"(ENV:xInEnv)Invalid Instance Found...\n");
                   return ;
                }
                /* R2.9 changes ends */ 
                 
                
                rcvr.LocalPId = (xLocalPIdNode)lclPidPtr;
                  
                    retResult = prepareAddBicRequestRcvPtr(retRefId,bicTempPtr->e1Id,bicTempPtr->btsType,bicTempPtr->adminState);	
                    if(retResult == I_FALSE )
                    {
                      LOG_PRINT(CRITICAL," Msg could not be sent for bicId=%d",retRefId );	
                    }
                    else
                    {
                        if ( !addTsNodeInAbisChain((I_PVoid)retMsgPtr) ) {              
                        LOG_PRINT(CRITICAL, "[%s] : addTsNodeInAbisChain() Failed for BICHM",__func__);
                        gCurrentCardState = gNewCardState; 
                        gNewCardState = CARDSTATE_INVALID;
                        gBpmAipRcvd = I_FALSE;
                        gRmAipRcvd = I_FALSE;
                        sendBichRmAipResp();
                        LOG_PRINT(INFO,"CurrentCardState: [%d]", gCurrentCardState) ; 
                        LOG_PRINT(INFO,"NewCardState: [%d]", gNewCardState) ;
                        RELEASE_MUTEX;
                        return ;
                    } 
                  
                        S = xGetSignal( sig_OAMS_CFG_BICH_ADD_BIC_REQ, rcvr, xEnv);
                        (((yPDP_sig_OAMS_CFG_BICH_ADD_BIC_REQ)S)->Param1) = (I_PVoid)retMsgPtr;
                        SDL_Output( S xSigPrioPar(xDefaultPrioSignal), (xIdNode *)0 );
                    }
                 } /* end of for loop */
                free(bicTablePtr);
               }
                 gCurrentCardState = gNewCardState; 
                 gNewCardState = CARDSTATE_INVALID;
                 gBpmAipRcvd = I_FALSE;
                 gRmAipRcvd = I_FALSE;
                 sendBichRmAipResp();
                 gHandleMsgAllowed = I_TRUE;
                 LOG_PRINT(INFO,"CurrentCardState: [%d]", gCurrentCardState) ; 
                 LOG_PRINT(INFO,"NewCardState: [%d]", gNewCardState) ;
                 RELEASE_MUTEX;
                 LOG_PRINT(INFO,"Moving to STANDBY->AIP");
  }
  /****************************************************************************************************************/
  /* Added for HA ABIS BSC-R2.5.5  End*/
  /****************************************************************************************************************/
  /* CS4.0: Changes for HA Start */
  I_Void cardStateChangeHandler(struct sAisParam *param)
  {
     xSignalNode     S;
     SDL_Pid         rcvr;
     I_U32           lclPidPtr = INVALID_LCL_PID_PTR ;
     I_S32           result = ZERO;
     I_U32           instId = ZERO;
     I_S8            instCountResult = ZERO;
     I_U16           instCount = ZERO;
     I_U32           signalSentToModel = I_FALSE;

     rcvr.GlobalNodeNr = (I_S32)selfEntIdG
  ;
     rcvr.LocalPId = (xLocalPIdNode)0;
     LOG_PRINT(INFO,"BPM_SELFCARD_STATE_CHANGE recd with CARD_STATE = %d", param->cardState) ;

     /* Init -> InService */
     if ( (param->cardState == CARDSTATE_IN_SERVICE) && (gCurrentCardState == CARDSTATE_INIT) )
     {
        gNewCardState = CARDSTATE_IN_SERVICE;
        LOG_PRINT(DEBUG,"Registering with DB Server...");
        result = dbConnect();
        if ( result != DBLIB_SUCCESS )
        {
           LOG_PRINT(CRITICAL,"BICHandler: Unable to Register itself with DBServer:Exiting");
           return;
        }
        LOG_PRINT(DEBUG,"Successfully Registered with DB Server.");
        
        /* R2.9 changes starts */
        activeInProgressStateHandler();           
        gIsStandbyCard = I_FALSE;
        /* R2.9 changes ends */ 
        
        gHandleMsgAllowed = I_FALSE;
        initializeChain(); /*AbisChainHandler initialization*/
     // gCurrentCardState = CARDSTATE_IN_SERVICE; 
     // gNewCardState = CARDSTATE_INVALID;
        RELEASE_MUTEX;
     }  

     /* Active -> InService*/ 
     else if ( (param->cardState == CARDSTATE_IN_SERVICE) && ( gCurrentCardState == CARDSTATE_ACTIVE) )
     {
        gHandleMsgAllowed = I_FALSE;
        gNewCardState = CARDSTATE_IN_SERVICE;
        

        instCountResult = GetInstCount(ENT_OAMS_BICH, BIC_HANDLER , &instCount);
        if ( instCountResult != INST_SUCCESS )
        {
           LOG_PRINT(MAJOR,"[ENV] GetInstCount Db call failed.. ");
           return;
        }
        gSignalSent = getCountAllocatedInst ( instCount ); /* To track No. of Signal sent to Model */
        LOG_PRINT(INFO, "gSignalSent: %d", gSignalSent);

        for ( instId = 1; instId <= instCount; instId++ )
        {
           findLclPidPtr ( instId, BIC_HANDLER, &lclPidPtr, (I_U8)ENT_OAMS_BICH );
           LOG_PRINT(DEBUG,"findLclPidPtr Success lclPid = " \
                            "0x%x",(I_U32)lclPidPtr);
           if ( lclPidPtr != INVALID_LCL_PID_PTR ) 
           {
              rcvr.LocalPId = (xLocalPIdNode)lclPidPtr;
              LOG_PRINT(INFO,"Sending signaBICH_INT_SELFCARD_STATE_CHANGE to Model");
              S = xGetSignal( sig_BICH_INT_SELFCARD_STATE_CHANGE, rcvr, xEnv);

              (((yPDP_sig_BICH_INT_SELFCARD_STATE_CHANGE)S)->Param1) = gCurrentCardState;
              (((yPDP_sig_BICH_INT_SELFCARD_STATE_CHANGE)S)->Param2) = gNewCardState;
              SDL_Output( S xSigPrioPar(xDefaultPrioSignal), (xIdNode *)0 );
              signalSentToModel = I_TRUE;
           }
        }


        if ( signalSentToModel == I_FALSE)
        {
           freeAllE1AndTimeSlotNode();
           activeStateHandler();
        }
      }

     /* InService -> StandBy*/
     else if ( (param->cardState == CARDSTATE_STANDBY) && (gCurrentCardState == CARDSTATE_IN_SERVICE) )
     {
        /* Start Changes for HA ABIS BSC-R2.5.5 */
     #if 0	 
         I_U32                     lclPidPtr = INVALID_LCL_PID_PTR ;
         I_U32                     instId = INVALID_INST_ID ;
         I_S8                      instCountResult = ZERO;
         I_U16                     instCount = ZERO;
         SDL_Pid                   rcvr;
         xSignalNode               S;
         I_S32                     retVal = ZERO;

         selfEntIdG = (int)ENT_OAMS_BICH;
         rcvr.GlobalNodeNr = (I_S32)selfEntIdG;

        instCountResult = GetInstCount(ENT_OAMS_BICH, BIC_HANDLER , &instCount);
        if ( instCountResult != INST_SUCCESS )
        {
           LOG_PRINT(MAJOR,"[ENV] GetInstCount Db call failed.. ");
           return;
        }

        if ( gInstancesCreated == I_FALSE )
        {
           InitInstMap(ENT_OAMS_BICH,BIC_HANDLER);
           /* Sending internal signal to system class for creating tau instances */
           freeAllE1AndTimeSlotNode();
           LOG_PRINT(INFO,"InProgressToStandbyStateHandler: Sending internal signal BICH_INT_ADD_TAU_INSTANCE to model"); 
           gSignalSent = instCount;
           rcvr.LocalPId = (xLocalPIdNode)gLclPidActiveClass;
           S = xGetSignal( sig_BICH_INT_ADD_TAU_INSTANCE, rcvr, xEnv);
           SDL_Output( S xSigPrioPar(xDefaultPrioSignal), (xIdNode *)0 );
           LOG_PRINT(INFO, "gSignalSent: %d", gSignalSent);
           gIsStandbyCard = I_TRUE;
           gNewCardState = CARDSTATE_STANDBY;
        }
        else
        {
           for ( instId = 1; instId <= instCount; instId++ )
           {
              findLclPidPtr ( instId, BIC_HANDLER, &lclPidPtr, (I_U8)ENT_OAMS_BICH );
              LOG_PRINT(DEBUG,"findLclPidPtr Success lclPid = " \
                            "0x%x",(I_U32)lclPidPtr);
              if ( lclPidPtr != INVALID_LCL_PID_PTR ) 
              {
                 if ((retVal = FreInstId(lclPidPtr, ENT_OAMS_BICH, BIC_HANDLER)) != INST_SUCCESS)
                 {
                    LOG_PRINT(CRITICAL, "InProgressToStandByStateHandler: FreeInstId() Failed lclPidPtr = 0x%x [Act Cls Id = %d], [errCode =%d]",lclPidPtr, BIC_HANDLER,retVal);
                   return;
                 }
                 else
                 {
                   LOG_PRINT(DEBUG,"InProgressToStandByStateHandler: FreeInstId() Success lclPidPtr = 0x%x [Act Cls Id = %d]",lclPidPtr, BIC_HANDLER);
                 }
              }
              else
              {
                 LOG_PRINT(INFO,"InProgressToStandByStateHandler: Invalid Instance Found...");
              }
           }
    #endif 
           freeAllE1AndTimeSlotNode();
           LOG_PRINT(INFO,"CurrentCardState: [%d]", gCurrentCardState) ; 
           LOG_PRINT(INFO,"NewCardState: [%d]", gNewCardState) ;
           LOG_PRINT(INFO,"Moving to STANDBY ");
           gIsStandbyCard = I_TRUE;
           gHandleMsgAllowed = I_FALSE;
           gCurrentCardState = CARDSTATE_STANDBY; 
           gNewCardState = CARDSTATE_INVALID;
           RELEASE_MUTEX;
       }
        /* End Changes for HA ABIS BSC-R2.5.5 */
       

     /* InService -> ActiveInProgress*/ 
     else if ( (param->cardState == CARDSTATE_ACTIVE_IN_PROGRESS) && ( gCurrentCardState == CARDSTATE_IN_SERVICE)  )  
     {	
        gNewCardState = CARDSTATE_ACTIVE_IN_PROGRESS;
        gCurrentCardState = CARDSTATE_ACTIVE_IN_PROGRESS; 
        gNewCardState = CARDSTATE_INVALID;
        if(gRmAipRcvd == I_TRUE)
        {
          sendBichRmAipResp();
          gBpmAipRcvd = I_FALSE;
          gRmAipRcvd = I_FALSE;
        }
        gHandleMsgAllowed = I_TRUE;
        RELEASE_MUTEX;
     }
      /* StandBy -> ActiveInProgress*/ 
      /* Start Changes for HA ABIS BSC-R2.5.5 */
     else if ( (param->cardState == CARDSTATE_ACTIVE_IN_PROGRESS) &&  (gCurrentCardState == CARDSTATE_STANDBY)  )  
     {
     I_U32                     outCount = ZERO;
     I_U16                     outSize = ZERO;
     I_S32                     retCode = ZERO;
     I_U32                     lclPidPtr = INVALID_LCL_PID_PTR ;
     I_U32                     instId = INVALID_INST_ID ;
     I_U32                     index = ZERO;
     I_S8                      instCountResult = ZERO;
     I_U16                     instCount = ZERO;
     SDL_Pid                   rcvr;
     xSignalNode               S;
     BicTableApi        			 *bicTablePtr = NULL; 
     BicTableApi         			 *bicTempPtr = NULL; 
     I_U32										 	retResult;
     I_U32										 	retRefId = INVALID_REF_ID;
     I_U32										 	*e1Num = NULL;
     I_U32										 	e1RecCount;
     I_U32										 	i = ZERO;
     OamsCfgBichInitAbisE1 		 oamsCfgBichInitAbisE1 ;

              selfEntIdG = (int)ENT_OAMS_BICH;
              rcvr.GlobalNodeNr = (I_S32)selfEntIdG;
              rcvr.LocalPId = (xLocalPIdNode)0;
              
              gHandleMsgAllowed = I_TRUE;
              gNewCardState = CARDSTATE_ACTIVE_IN_PROGRESS;
              gBpmAipRcvd = I_TRUE;
              LOG_PRINT(DEBUG,"Moving from StandBy -> AIP");
					if(gRmAipRcvd == I_TRUE)
					{
							/* Initialize Abis E1 */
						 if(getE1NumTrunkTable(SYS_E1_USAGE_ABISIF, &e1Num, &e1RecCount) == DBLIB_SUCCESS)
   					 {
      				 	for(i = 0; i < e1RecCount; i++)
      				  	{
     								oamsCfgBichInitAbisE1.e1Id = e1Num[i];
            				initAbisChain(&oamsCfgBichInitAbisE1); 
      						}
      					free(e1Num);
   				   }

      			retCode = getallBicTable( &bicTablePtr, &outCount, &outSize);
      			if ( retCode != CLIB_SUCCESS )
      			{
         			LOG_PRINT(LOG_INFO,"activeInProgressStateHandler: No BIC configured");
      			}
      			else
						{
		
							for (index = 0; index < outCount ; index ++)
							{
								/* Initialize */
								lclPidPtr = INVALID_LCL_PID_PTR;
								retRefId = INVALID_REF_ID;
								instId = INVALID_INST_ID ;
			
            		bicTempPtr = (BicTableApi*)((I_U8*)(bicTablePtr) + index*outSize);
            		retRefId = bicTempPtr->bicId;
            		if (AlocNewInst(&lclPidPtr, &instId, SELF_ENTITY_ID,
                            BICHM_ACT_CLID,retRefId,
                            ZERO, ZERO, ZERO, ZERO)  != INST_SUCCESS)
            		{
              		 LOG_PRINT(CRITICAL, "xInEnv : AlocNewInst() Failed for BICHM");
         			 		 gCurrentCardState = gNewCardState; 
         			 		 gNewCardState = CARDSTATE_INVALID;
									 gBpmAipRcvd = I_FALSE;
									 gRmAipRcvd = I_FALSE;
									 sendBichRmAipResp();
			         		 LOG_PRINT(INFO,"CurrentCardState: [%d]", gCurrentCardState) ; 
      			   		 LOG_PRINT(INFO,"NewCardState: [%d]", gNewCardState) ;
			         		 RELEASE_MUTEX;
               	 	 return; 
            		}
            			LOG_PRINT(DEBUG, "xInEnv : NEW INSTANCE ALLOCATED FOR BICHM  \
                          LCLPID: 0x%0x, INSTANCE-ID: %d, BIC-ID: %u",
                              lclPidPtr, instId, retRefId);
            			rcvr.LocalPId = (xLocalPIdNode)lclPidPtr;
            		 
 									retResult = prepareAddBicRequestRcvPtr(retRefId,bicTempPtr->e1Id,bicTempPtr->btsType,bicTempPtr->adminState);	
									if(retResult == I_FALSE )
									{
										LOG_PRINT(CRITICAL," Msg could not be sent for bicId=%d",retRefId );	
									}
									else
									{
											if ( !addTsNodeInAbisChain((I_PVoid)retMsgPtr) ) {              
               				LOG_PRINT(CRITICAL, "[%s] : addTsNodeInAbisChain() Failed for BICHM",__func__);
         			 				gCurrentCardState = gNewCardState; 
         			 				gNewCardState = CARDSTATE_INVALID;
									 		gBpmAipRcvd = I_FALSE;
									 		gRmAipRcvd = I_FALSE;
									 		sendBichRmAipResp();
			         				LOG_PRINT(INFO,"CurrentCardState: [%d]", gCurrentCardState) ; 
      			   				LOG_PRINT(INFO,"NewCardState: [%d]", gNewCardState) ;
			         				RELEASE_MUTEX;
               				return ;
            						} 
								
            					S = xGetSignal( sig_OAMS_CFG_BICH_ADD_BIC_REQ, rcvr, xEnv);
		            			(((yPDP_sig_OAMS_CFG_BICH_ADD_BIC_REQ)S)->Param1) = (I_PVoid)retMsgPtr;
   										SDL_Output( S xSigPrioPar(xDefaultPrioSignal), (xIdNode *)0 );
									}
							 } /* end of for loop */
							free(bicTablePtr);
						 }
         			 gCurrentCardState = gNewCardState; 
         			 gNewCardState = CARDSTATE_INVALID;
							 gBpmAipRcvd = I_FALSE;
							 gRmAipRcvd = I_FALSE;
							 sendBichRmAipResp();
							 gHandleMsgAllowed = I_TRUE;
			         LOG_PRINT(INFO,"CurrentCardState: [%d]", gCurrentCardState) ; 
      			   LOG_PRINT(INFO,"NewCardState: [%d]", gNewCardState) ;
			         RELEASE_MUTEX;
      			   LOG_PRINT(INFO,"Moving to STANDBY->AIP");
						}
						else /* else of gRmAipRcvd */
						{
							LOG_PRINT(INFO,"Waiting for OAMS_RM_BICHM_AIP_REQ Message, BPM AIP Notification Received ");
						}
	}
		/* End Changes for HA ABIS BSC-R2.5.5 */
   /* ActiveInProgress -> Active */ 
   else if ( (param->cardState == CARDSTATE_ACTIVE) && (gCurrentCardState == CARDSTATE_ACTIVE_IN_PROGRESS) )
   {
     // gNewCardState = CARDSTATE_ACTIVE;
     // gCurrentCardState = CARDSTATE_INVALID;
      activeInProgressStateHandler();  
	    gIsStandbyCard = I_FALSE;
      resetLapdDiscCntxt(); /*changes for issue 19948 */
   }

   /* StandBy -> Recovery */ 
   else if ( (param->cardState == CARDSTATE_RECOVERY) && (gCurrentCardState == CARDSTATE_STANDBY) )
   {
		  gIsStandbyCard = I_FALSE;
			gHandleMsgAllowed = I_FALSE;
      gNewCardState = CARDSTATE_RECOVERY;
      freeAllE1AndTimeSlotNode();
      gCurrentCardState = CARDSTATE_RECOVERY;
      gNewCardState = CARDSTATE_INVALID;
      RELEASE_MUTEX;
   }

   /* Active -> Recovery */
   else if ( (param->cardState == CARDSTATE_RECOVERY) && (gCurrentCardState == CARDSTATE_ACTIVE) )
   {
      gNewCardState = CARDSTATE_RECOVERY;
			gHandleMsgAllowed = I_FALSE;
      instCountResult = GetInstCount(ENT_OAMS_BICH, BIC_HANDLER , &instCount);
      if ( instCountResult != INST_SUCCESS )
      {
         LOG_PRINT(MAJOR,"[ENV] GetInstCount Db call failed.. ");
         return;
      }
      gSignalSent = getCountAllocatedInst ( instCount ); /* To track No. of Signal sent to Model */

      for ( instId = 1; instId <= instCount; instId++ )
      {
         findLclPidPtr ( instId, BIC_HANDLER, &lclPidPtr, (I_U8)ENT_OAMS_BICH );
         LOG_PRINT(DEBUG,"findLclPidPtr Success lclPid = " \
                          "0x%x",(I_U32)lclPidPtr);
         if ( lclPidPtr != INVALID_LCL_PID_PTR ) 
         {
            rcvr.LocalPId = (xLocalPIdNode)lclPidPtr;
            S = xGetSignal( sig_BICH_INT_SELFCARD_STATE_CHANGE, rcvr, xEnv);
            (((yPDP_sig_BICH_INT_SELFCARD_STATE_CHANGE)S)->Param1) = gCurrentCardState;
            (((yPDP_sig_BICH_INT_SELFCARD_STATE_CHANGE)S)->Param2) = gNewCardState;
            SDL_Output( S xSigPrioPar(xDefaultPrioSignal), (xIdNode *)0 );
            signalSentToModel = I_TRUE;
         }
      }
      LOG_PRINT(INFO, "gSignalSent: %d", gSignalSent);
      gInvocation = param->invocation;
      if (  signalSentToModel == I_FALSE )
      {
         freeAllE1AndTimeSlotNode();
         activeStateHandler();
      }
   }
   /* Recovery -> InService */
   else if ( (param->cardState == CARDSTATE_IN_SERVICE) && (gCurrentCardState == CARDSTATE_RECOVERY) )
   {
      gNewCardState = CARDSTATE_IN_SERVICE;
			gHandleMsgAllowed = I_FALSE;
      /* DeRegister with DB */
      if ((result = dbDestroy()) != DBLIB_SUCCESS)
      {
         LOG_PRINT(CRITICAL,"clib_destroy failed for BICH (Error = %d)",result);
         return;
      }

      LOG_PRINT(DEBUG,"Registering with DB Server...");
      result = dbConnect();
      if ( result != DBLIB_SUCCESS )
      {
         LOG_PRINT(CRITICAL,"BICHandler: Unable to Register itself with DBServer:Exiting");
          return;
      }
      LOG_PRINT(DEBUG,"Successfully Registered with DB Server.");
      gCurrentCardState = CARDSTATE_IN_SERVICE;
      gNewCardState = CARDSTATE_INVALID;
      RELEASE_MUTEX;
      LOG_PRINT(INFO,"Moving to INSERVICE.. ");
   }

   else if ((param->cardState == CARDSTATE_DIAGNOSTIC) && (gCurrentCardState == CARDSTATE_STANDBY))
   {
      LOG_PRINT(INFO,"Moving from STDBY -> DIAG");
      gCurrentCardState = CARDSTATE_DIAGNOSTIC;
      gNewCardState = CARDSTATE_INVALID;
      RELEASE_MUTEX;
   }
   else if ((param->cardState == CARDSTATE_IN_SERVICE) && (gCurrentCardState == CARDSTATE_DIAGNOSTIC))
   {
      LOG_PRINT(INFO,"Moving from DIAG -> INSERVICE");
      gCurrentCardState = CARDSTATE_IN_SERVICE;
      gNewCardState = CARDSTATE_INVALID;
			gCardStateDiagnostic = I_TRUE;
      RELEASE_MUTEX;
   }
   else if ( (param->cardState == CARDSTATE_UPGRADE) ||  (param->cardState == CARDSTATE_OUT_OF_SERVICE ) ||  (param->cardState == CARDSTATE_PLATFORM_INS ))
   {
      RELEASE_MUTEX;
   }
   else
   {
      LOG_PRINT(INFO,"cardStateChangeHandler: Unexpected state received  = %d",param->cardState) ;
   }
   LOG_PRINT(INFO,"CurrentCardState: [%d]", gCurrentCardState) ; 
   LOG_PRINT(INFO,"NewCardState: [%d]", gNewCardState) ; 

}

I_Void activeInProgressStateHandler()
{
   BicStatusTableApi         *bicStatusTablePtr = NULL; 
   BicStatusTableApi         *bicStatusTempPtr = NULL; 
   BicStatusTableIndices     bicStatusIndex;
   I_U32                     outCount = ZERO;
   I_U16                     outSize = ZERO;
   I_S32                     retCode = ZERO;
   I_S32                     retVal = ZERO;
   I_U32                     lclPidPtr = INVALID_LCL_PID_PTR ;
   I_U32                     instId = INVALID_INST_ID ;
   I_U32                     index = ZERO;
   I_S8                      instCountResult = ZERO;
   I_U16                     instCount = ZERO;
   SDL_Pid                   rcvr;
   xSignalNode               S;

   selfEntIdG = (int)ENT_OAMS_BICH;
   rcvr.GlobalNodeNr = (I_S32)selfEntIdG;

   if ( (gCurrentCardState == CARDSTATE_INIT) &&  (gNewCardState = CARDSTATE_IN_SERVICE) && (gIsStandbyCard == I_FALSE ) )
   {
#if 0 
      retCode = getallBicStatusTable( &bicStatusTablePtr, &outCount, &outSize);
      if ( retCode != CLIB_SUCCESS )
      {
         LOG_PRINT(LOG_INFO,"activeInProgressStateHandler: No BIC configured");
      }
     /* Cleaning Transient table */
      else
      {
         for ( index=0; index<outCount; index++ )
         {
            bicStatusTempPtr = (BicStatusTableApi*)((I_U8*)(bicStatusTablePtr) + index*outSize);
            bicStatusIndex.bicId = bicStatusTempPtr->bicId;
            if ((deleteBicStatusTable(&bicStatusIndex)) != CLIB_SUCCESS)
            {
               LOG_PRINT(CRITICAL,"deleteBicStatusTable failed for BicId: %d",bicStatusIndex.bicId); 
            }
         }
         free(bicStatusTablePtr);
      }
#endif
   
      instCountResult = GetInstCount(ENT_OAMS_BICH, BIC_HANDLER , &instCount);
      if ( instCountResult != INST_SUCCESS )
      {
         LOG_PRINT(MAJOR,"[ENV] GetInstCount Db call failed.. ");
         return;
      }

      if ( gInstancesCreated == I_FALSE )
      {
         InitInstMap(ENT_OAMS_BICH,BIC_HANDLER);
         /* Sending internal signal to system class for creating tau instances */
         //freeAllE1AndTimeSlotNode();
         LOG_PRINT(INFO,"activeInProgressStateHandler: Sending internal signal BICH_INT_ADD_TAU_INSTANCE to model"); 
         gSignalSent = instCount;
         rcvr.LocalPId = (xLocalPIdNode)gLclPidActiveClass;
         S = xGetSignal( sig_BICH_INT_ADD_TAU_INSTANCE, rcvr, xEnv);
         SDL_Output( S xSigPrioPar(xDefaultPrioSignal), (xIdNode *)0 );
         LOG_PRINT(INFO, "gSignalSent: %d", gSignalSent);
      }
      else
      {
         for ( instId = 1; instId <= instCount; instId++ )
         {
            findLclPidPtr ( instId, BIC_HANDLER, &lclPidPtr, (I_U8)ENT_OAMS_BICH );
            LOG_PRINT(DEBUG,"findLclPidPtr Success lclPid = " \
                          "0x%x",(I_U32)lclPidPtr);
            if ( lclPidPtr != INVALID_LCL_PID_PTR ) 
            {
               if ((retVal = FreInstId(lclPidPtr, ENT_OAMS_BICH, BIC_HANDLER)) != INST_SUCCESS)
               {
                  LOG_PRINT(CRITICAL, "activeInProgressStateHandler: FreeInstId() Failed lclPidPtr = 0x%x [Act Cls Id = %d], [errCode =%d]",lclPidPtr, BIC_HANDLER,retVal);
                 return;
               }
               else
               {
                 LOG_PRINT(DEBUG,"activeInProgressStateHandler: FreeInstId() Success lclPidPtr = 0x%x [Act Cls Id = %d]",lclPidPtr, BIC_HANDLER);
               }
            }
            else
            {
               LOG_PRINT(INFO,"activeInProgressStateHandler: Invalid Instance Found...");
            }
         }
         gCurrentCardState = gNewCardState; 
         gNewCardState = CARDSTATE_INVALID;
         LOG_PRINT(INFO,"CurrentCardState: [%d]", gCurrentCardState) ; 
         LOG_PRINT(INFO,"NewCardState: [%d]", gNewCardState) ;
         RELEASE_MUTEX;
         LOG_PRINT(INFO,"Moving to Inservice ");
     }
  }
   else if ( (gCurrentCardState == CARDSTATE_ACTIVE_IN_PROGRESS) &&  (gNewCardState = CARDSTATE_ACTIVE) && (gIsStandbyCard == I_TRUE ) )
		{ 
            LOG_PRINT(DEBUG,"Moving from AIP -> Active (previously StandbyCard)");
            if (gCardStateDiagnostic == I_FALSE)
            {
						  gBpmAipRcvd = I_TRUE;
              if(gRmAipRcvd == I_TRUE)
              {
                LOG_PRINT(INFO,"CurrentCardState: [%d]", gCurrentCardState) ; 
                LOG_PRINT(INFO,"NewCardState: [%d]", gNewCardState) ;
                gCurrentCardState = gNewCardState; 
                gNewCardState = CARDSTATE_INVALID;
                sendBichRmActiveResp();
                gBpmAipRcvd = I_FALSE;
                gRmAipRcvd = I_FALSE;
                RELEASE_MUTEX;
              }
              else
              {
                LOG_PRINT(INFO,"Waiting for OAMS_RM_BICHM_ACTIVE_REQ Message, BPM Notification Received");
              }
            }
            else  /* Card is coming through DIAGNOSTIC state */
            {
                LOG_PRINT(INFO,"Diag Case: CurrentCardState: [%d]", gCurrentCardState) ; 
                LOG_PRINT(INFO,"Diag Case: NewCardState: [%d]", gNewCardState) ;
                gCurrentCardState = gNewCardState; 
                gNewCardState = CARDSTATE_INVALID;
                gCardStateDiagnostic = I_FALSE;
                RELEASE_MUTEX;
            }
		 }
   else
   {  /* R2.9 changes starts */ 
      LOG_PRINT(MAJOR,"AIP->ACTIVE State change notification received");
      activeStateHandler();
      freeAllE1AndTimeSlotNode(); 
      /* R2.9 changes ends */
   } 
}  


I_Void  activeStateHandler()
{
   gCurrentCardState = gNewCardState;
   gNewCardState = CARDSTATE_INVALID;
   RELEASE_MUTEX;
}

I_Void freeAllE1AndTimeSlotNode()
{
   I_U32               *e1Num = NULL;
   I_U32               e1RecCount = ZERO;
   I_U32               index = ZERO;

   LOG_PRINT(INFO,"[ENV]Entering function freeAllE1AndTimeSlotNode");
   if ( getE1NumTrunkTable(SYS_E1_USAGE_ABISIF, &e1Num, &e1RecCount) == CLIB_SUCCESS )
   {
      for ( index = 0; index < e1RecCount; index++ )
      {
         freeE1TsNode(e1Num[index]);
         freeE1Node(e1Num[index]);
      }
      free(e1Num);
   }
#if 0
   if ( getE1NumE1PerTable(SYS_E1_USAGE_ABISIF_STANDALONE_BIC_TS_MAX_BIC_1, &e1Num, &e1RecCount) == CLIB_SUCCESS )
   {
      for ( index = 0; index < e1RecCount; index++ )
      {
         freeE1TsNode(e1Num[index]);
         freeE1Node(e1Num[index]);
      }
      free(e1Num);
   }
   if ( getE1NumE1PerTable(SYS_E1_USAGE_ABISIF_STANDALONE_BIC_TS_MAX_BIC_4, &e1Num, &e1RecCount) == CLIB_SUCCESS )
   {
      for ( index = 0; index < e1RecCount; index++ )
      {
         freeE1TsNode(e1Num[index]);
         freeE1Node(e1Num[index]);
      }
      free(e1Num);
   }
   if ( getE1NumE1PerTable(SYS_E1_USAGE_ABISIF_STANDALONE_BIC_TS_MAX_BIC_7, &e1Num, &e1RecCount) == CLIB_SUCCESS )
   {
      for ( index = 0; index < e1RecCount; index++ )
      {
         freeE1TsNode(e1Num[index]);
         freeE1Node(e1Num[index]);
      }
      free(e1Num);
   }
#endif
   initializeChain();
}

I_Void findLclPidPtr ( I_U32 instId, I_U8 classId, I_U32 *lclPidPtr, I_U8 entId)
{
   I_S32 retCode       = ZERO;
   I_S32 localInstId   = ZERO;
   InstMapTbl          instMapTblPtr;

   LOG_PRINT(INFO,"Finding LocalPidPtr for class: %d", classId);
   retCode = GetRowFrmInstId ( &instMapTblPtr, (I_S32)instId, entId, classId);
   if ( retCode != INST_SUCCESS )
   {
      LOG_PRINT(MAJOR,"[ENV] GetRowFrmInstId Db call failed.. ");
      *lclPidPtr = INVALID_LCL_PID_PTR;
      return;
   } 
   if (  instMapTblPtr.status  == INST_FREE )
   {
       LOG_PRINT(INFO,"[ENV] Instance is not allocated.. ");
      *lclPidPtr = INVALID_LCL_PID_PTR;
      return;
   }
   retCode = SearchAlocatedInst( lclPidPtr, &localInstId,  entId, classId, instMapTblPtr.refId1, instMapTblPtr.refId2,                                   instMapTblPtr.refId3, instMapTblPtr.refId4, instMapTblPtr.refId5);
   if ( ( retCode != INST_SUCCESS ) )
   {
     *lclPidPtr = INVALID_LCL_PID_PTR;
   } 
}

I_U32 getCountAllocatedInst ( I_U32 instCount )
{
   I_U32 instId = ZERO;
   I_U32 count = ZERO;
   I_U32 lclPidPtr  = INVALID_LCL_PID_PTR ;

   LOG_PRINT(INFO," Entering getCountAllocatedInst");
   for ( instId = 1; instId <= instCount; instId++ )
   {
      findLclPidPtr ( instId, BIC_HANDLER, &lclPidPtr, (I_U8)ENT_OAMS_BICH );
      if ( lclPidPtr != INVALID_LCL_PID_PTR )
      {
         count++;
      }
   }
   LOG_PRINT(INFO,"Total Allocated Instance [%d]",count);
   LOG_PRINT(INFO," Exiting getCountAllocatedInst");
   return count;
}
      
/* CS4.0: Changes for HA End */
/********************************************************************/

void sendBicParentNotAvail(I_U32 bicId)
{
   I_U32 lclPidPtr    = INVALID_LCL_PID_PTR ;
   I_S32 instId       = INVALID_INST_ID ;
   SDL_Pid            rcvr;
   xSignalNode        S;
   selfEntIdG = (int)ENT_OAMS_BICH;

   rcvr.GlobalNodeNr = (I_S32)selfEntIdG;
   rcvr.LocalPId = (xLocalPIdNode)0;

   if (SearchAlocatedInst(&lclPidPtr,&instId,ENT_OAMS_BICH,BIC_HANDLER,bicId,ZERO,ZERO,ZERO,ZERO) != INST_SUCCESS)
   {
      LOG_PRINT(CRITICAL,"[ENV]No BICHandler Ins found for BIC ID = [%u]",bicId);
      return;
   }
   if ((rcvr.LocalPId = (xLocalPIdNode)lclPidPtr) == INVALID_INST_ID)
   {
      LOG_PRINT(CRITICAL,"[ENV]Invalid Instance Found...");
      return;
   }
   S = xGetSignal( sig_BICH_INT_BIC_PARENT_NOT_AVAIL, rcvr, xEnv);
   SDL_Output( S xSigPrioPar(xDefaultPrioSignal), (xIdNode *)0 );
   /*LOG_PRINT(DEBUG,"[ENV]Send INTERNAL SIGNAL BICH_INT_BIC_PARENT_NOT_AVAIL");*/
   return;
}

I_Bool sendMsgBichIntStoptWaitForParentConTimer(bicId)
{
   I_U32 lclPidPtr    = INVALID_LCL_PID_PTR ;
   I_S32 instId       = INVALID_INST_ID ;
   SDL_Pid            rcvr;
   xSignalNode        S;
   selfEntIdG = (int)ENT_OAMS_BICH;

   rcvr.GlobalNodeNr = (I_S32)selfEntIdG;
   rcvr.LocalPId = (xLocalPIdNode)0;

   if (SearchAlocatedInst(&lclPidPtr,&instId,ENT_OAMS_BICH,BIC_HANDLER,bicId,ZERO,ZERO,ZERO,ZERO) != INST_SUCCESS)
   {
      LOG_PRINT(CRITICAL,"[ENV]No BICHandler Ins found for BIC ID = [%u]",bicId);
      return FAILURE;
   }
   if ((rcvr.LocalPId = (xLocalPIdNode)lclPidPtr) == INVALID_INST_ID)
   {
      LOG_PRINT(CRITICAL,"[ENV]Invalid Instance Found...");
      return FAILURE;
   }
   S = xGetSignal( sig_BICH_INT_STOP_tWAIT_FOR_PARENT_CON_TIMER, rcvr, xEnv);
   SDL_Output( S xSigPrioPar(xDefaultPrioSignal), (xIdNode *)0 );
   /*LOG_PRINT(DEBUG,"[ENV]Send INTERNAL SIGNAL BICH_INT_STOP_tWAIT_FOR_PARENT_CON_TIMER");*/
   return SUCCESS ;

}


I_Bool CreateMsgBichCfgAlarmInd(I_U32 bicId, I_U32 fromBicId, I_U8 dsPort ,I_U8 bicTei)
{
   I_U32                               sndSize = ZERO;
   OamsBichCfgAlarmInd                 *sndPtr = NULL;
   BicE1TeiMapTableIndices             bicE1TeiMapTableIndices;
   BicE1TeiMapTableApi                 *bicE1TeiMapTableApi = NULL;
   I_U32                               e1Id = ZERO ;
   I_S32                               errCode ;
   LOG_PRINT(DEBUG, "[ENV: ]In function CreateMsgBichCfgAlarmInd");

   sndSize = sizeof(OamsBichCfgAlarmInd);
   sndPtr  = (OamsBichCfgAlarmInd*) AlocMsgBuf(sndSize);

   if (sndPtr == NULL)
   {
      LOG_PRINT(CRITICAL,"[ENV: ]Memory could not be allocated");
      return FAILURE; 
   }
   memset(sndPtr,0,sndSize); 
   FILL_SYS_HDR(sndPtr,OAMS_BICH_CFG_ALARM_IND,MSG_SUB_TYPE,PRCR_CP,ENT_OAMS_BICH ,ZERO , PRCR_CP,ENT_OAMS_CFG, ZERO);

   LOG_PRINT(DEBUG,"[ENV: ]Preparing CreateMsgBichCfgAlarmInd [bicId: %u]",bicId);
   sndPtr->sysAlarm.sysalarmId = EVENT_BIC_UNKNOWN;
   sndPtr->sysAlarm.alarmLevel = MAJOR;
   sndPtr->sysAlarm.key1       = bicId;
   sndPtr->sysAlarm.info3      = OAMS_OBJTYPE_BSSNODE;
   bicE1TeiMapTableIndices.bicTei = (I_U32)bicTei ;
   errCode=getBicE1TeiMapTable(&bicE1TeiMapTableIndices,&bicE1TeiMapTableApi);
   if (errCode != CLIB_SUCCESS)
   {
      LOG_PRINT(MAJOR,"[ENV: ]getBicE1TeiMapTable Api failed errCode=%s ",clib_strerror(errCode));
      DalocMsgBuf((I_Void *)sndPtr);
      return FAILURE;
   }
   e1Id = bicE1TeiMapTableApi->e1Id ;
   free(bicE1TeiMapTableApi);
   if(fromBicId == ZERO)
   {
      sprintf(sndPtr->sysAlarm.infoString,"BIC[ %u] Connected to BSC via BSC E1[ %d] not configured",bicId,e1Id);
   }
   else
   {
      sprintf(sndPtr->sysAlarm.infoString,"BIC[%u] Connected to[ParentBic:%u]via Port[%d]BSC E1[%d] not configured",bicId,fromBicId,dsPort,e1Id);
   }
   strcat(sndPtr->sysAlarm.infoString,"\0"); 
   sndPtr->sysAlarm.infoStrLen = strlen(sndPtr->sysAlarm.infoString);
   LOG_PRINT(DEBUG,"[ENV: ]Alarm: %s",sndPtr->sysAlarm.infoString);
   if (SendMsg((I_PVoid)sndPtr,MSG_ORD_PRIO,sndSize) == SND_FAIL)
   {
      LOG_PRINT(CRITICAL,"[ENV: ]Sending failed of OAMS_BICH_CFG_ALARM_IND");
      return FAILURE;
   }
   else
      LOG_PRINT(DEBUG,"[ENV: ]Sending Success with msgSize=%d ",sndSize);

   LOG_PRINT(DEBUG, "[ENV: ]Exiting function CreatMsgBichCfgAlarmInd");
   return SUCCESS;
}


     /* Logic for getting the BICID from the Incoming Message is writen here.*/

I_U32 GetRefId(I_Void *rcvPtr)
{
   SysHdr          *sysHdr = NULL;
   I_U16           msgType = ZERO;
   I_U32           refId   = INVALID_REF_ID;
   I_U8            bicTei  = ZERO ;
   LOG_PRINT(DEBUG,"[ENV]In Function GetRefId To Find RefId...");
   sysHdr = (SysHdr *)rcvPtr ;
   msgType = sysHdr->msgType ;
   switch(msgType)
   {
      case OAMS_CFG_BICH_ADD_BIC_REQ:
           refId = ((OamsCfgBichAddBicReq *)rcvPtr)->bicId;
           break;      
      case OAMS_CFG_BICH_DEL_BIC_REQ:
           refId = ((OamsCfgBichDelBicReq *)rcvPtr)->bicId;
           break;      
      case CSAPP_ABIHM_BICH_BIC_HELLO:
           refId = ((CsappAbihmBichBicHello *)rcvPtr)->bicId;
           break;      
      case CSAPP_ABIHM_BICH_LAPD_LINK_UP:
           bicTei = ((CsappAbihmBichLapdLinkUp *)rcvPtr)->bicTei;
           refId=getFirstBicFromTei(bicTei);
           break;      
      case CSAPP_ABIHM_BICH_LAPD_LINK_DOWN:
           bicTei = ((CsappAbihmBichLapdLinkUp *)rcvPtr)->bicTei;
           refId=getFirstBicFromTei(bicTei);
           break;      
      case CSAPP_ABIHM_BICH_BIC_DS_LINK_EST:
           refId = ((CsappAbihmBichDsLinkEst *)rcvPtr)->bicId;
           break;      
      case CSAPP_ABIHM_BICH_BIC_DS_LINK_FAIL:
           refId = getFirstDsBicFromBicList(rcvPtr);
           break;      
      case OAMS_CFG_BICH_BIC_CC_PWR_ORDER_REQ:
           refId = ((OamsCfgBichBicPowerOrderReq *)rcvPtr)->bicId;
           break;      
      case CSAPP_ABIHM_BICH_BIC_BSC_ALARM_IND:
           refId = ((CsappAbihmBichBicBscAlarmInd *)rcvPtr)->bicId;
           break;  
        /*R2.2 Changes Start*/
      case OAMS_CFG_BICH_UNLOCK_REQ:
           refId = ((OamsCfgBichUnlockReq *)rcvPtr)->bicId;
           break;      
      case OAMS_CFG_BICH_LOCK_REQ:
           refId = ((OamsCfgBichLockReq *)rcvPtr)->bicId;
           break;      
      case OAMS_CFG_BICH_ADD_TRX_INDICATION:
           refId = ((OamsCfgBichAddTrxInd *)rcvPtr)->bicId;
           break;      
      case OAMS_CFG_BICH_DEL_TRX_INDICATION:
           refId = ((OamsCfgBichDelTrxInd *)rcvPtr)->bicId;
           break;      
      case OAMS_CFG_BICH_BTS_RESET:
           refId = ((OamsCfgBichBtsReset *)rcvPtr)->bicId;
           break;      
      case CSAPP_ABIHM_BICH_BM_HELLO:
           refId = ((CsappAbihmBichBmHello *)rcvPtr)->btsId;
					 LOG_PRINT(INFO,"refId is =%d",refId);
           break;      
      case OAMS_TRXH_BICH_OPER_STATE_CHANGE_IND:
           refId = ((OamsTrxhBichOperStateChangeInd *)rcvPtr)->bicId;
           break;      
      case CSAPP_ABIHM_BICH_FAILURE_EVENT_REPORT:
           bicTei = ((CsappAbihmBichFailureEventReport *)rcvPtr)->tei;
           refId=getFirstBicFromTei(bicTei);
           break;      
       /*PCU Rel 2.5 Changes Start */
      case CSAPP_ABIHM_BICH_IP_LINK_DOWN:
           bicTei = ((CsappAbihmBichIpLinkDown *)rcvPtr)->bicTei;
           refId=getFirstBicFromTei(bicTei);
           break;
      case PSAPP_TB_BICH_IP_LINK_DOWN:
           refId = ((PsappTbBichIpLinkDown *)rcvPtr)->btsId;
           break;
      case PSAPP_TB_BICH_IP_LINK_UP:
           refId = ((PsappTbBichIpLinkUp *)rcvPtr)->btsId;
           break;
     /*PCU Rel 2.5 Changes End */
      default:
           refId = 0;
   }
   LOG_PRINT(DEBUG,"[ENV: ]Returning From Function GetRefId...");
   return refId ;
}


I_U32 FindBichLocalPidPtr(I_Void *rcvPtr)
{
   I_U32 lclPidPtr = INVALID_LCL_PID_PTR ;
   I_S32 instId    = INVALID_INST_ID ;
   I_U32 refId     = INVALID_REF_ID ;
   refId = GetRefId(rcvPtr) ;
   if(refId == ZERO)
   {
      LOG_PRINT(MAJOR,"[ENV]Invalid Instance Found...");
      return 0;
   }
   LOG_PRINT(INFO,"[ENV]OutOf RefId BIC = [%d]",refId);
   if (SearchAlocatedInst(&lclPidPtr,&instId,ENT_OAMS_BICH,BIC_HANDLER,refId,ZERO,ZERO,ZERO,ZERO) != INST_SUCCESS)
   {
      LOG_PRINT(CRITICAL,"[ENV]No BICHandler Ins found for BIC = [%d]",refId);
      return 0;
   }
   if (lclPidPtr == INVALID_LCL_PID_PTR)
   {
      LOG_PRINT(CRITICAL,"[ENV]Invalid Instance Found...");
      return 0;
   }
   LOG_PRINT(INFO,"[ENV] lclPidPtr = [%d]",lclPidPtr);
   return lclPidPtr ;
}

#ifndef XNOINITENV
/*---+---------------------------------------------------------------
     xInitEnv  extern
-------------------------------------------------------------------*/
#ifndef XENV_INIT
#define XENV_INIT
#endif

extern void xInitEnv(void)
{
  /* Code to initialize your SDL-system environment may be inserted here */
/*
   I_S32          result = ZERO;
*/
   selfEntIdG     = (int)ENT_OAMS_BICH;

#ifdef XTRACE
   xPrintString("xInitEnv called\n");
#endif
   //RegisterBichWithBpm();CLOUD
   if (RegisterWithIpcFrmwrk(selfEntIdG, (I_S8 *)"BICHM") < 0)
   {
      LOG_PRINT(CRITICAL,"[ENV]Unable to Register itself with IPC FrameWork : Exiting");
      exit(0) ;
   }
   RegisterBichWithBpm();
   reg_sig_hndlr();
   LOG_PRINT(DEBUG,"Initializing the mutex");
   INIT_MUTEX;
   LOG_PRINT(DEBUG,"After Initializing the mutex");
   LOG_PRINT(DEBUG,"** SystemName=%s, ModuleName=%s, Version=%s **",SYSTEM_NAME,SELF_ENTITY_NAME,VERSION);
   LOG_PRINT(DEBUG,"Registering with IPC FramWork Complete...");
   LOG_PRINT(INFO,"BICH Process Initialized Successfully") ; 
   LOG_PRINT(INFO,"CurrentCardState at initialization: [%d]", gCurrentCardState) ; 
   LOG_PRINT(INFO,"NewCardState at initialization: [%d]", gNewCardState) ; 
}

/* R2.9 changes starts */
/*REGISTER_SIGNAL_HANDLER();
LOG_PRINT(INFO,"xInitEnv: registered signal handler");*/
/* R2.9 changes ends */
#endif


#ifndef XNOCLOSEENV
/*---+---------------------------------------------------------------
     xCloseEnv  extern
-------------------------------------------------------------------*/
#ifndef XENV_CLOSE
#define XENV_CLOSE
#endif

extern void xCloseEnv(void)
{
   I_S32 retVal=ZERO;


  /* Need to delete the instance maps as well. Should use CleanInstMap () for this */
  /* DeRegister with DB */
   if ((retVal = dbDestroy()) != 0)
   {
      LOG_PRINT(CRITICAL,"clib_destroy failed for BICH (Error = %d)",retVal);
      exit(0);
   }/*if retVal */
#ifdef XTRACE
   xPrintString("xCloseEnv called\n");
#endif

}
#endif


/*---+---------------------------------------------------------------
     Macros for xOutEnv
-------------------------------------------------------------------*/
#ifndef OUT_LOCAL_VARIABLES
#define OUT_LOCAL_VARIABLES
#endif

#ifndef IF_OUT_SIGNAL
#define IF_OUT_SIGNAL(SIGNAL_NAME, SIGNAL_NAME_STRING) \
  if (((*SignalOut)->NameNode) == SIGNAL_NAME) {
#define END_IF_OUT_SIGNAL(SIGNAL_NAME, SIGNAL_NAME_STRING) \
  }
#endif

#ifndef OUT_SIGNAL1
#define OUT_SIGNAL1(SIGNAL_NAME, SIGNAL_NAME_STRING)
#endif

#ifndef OUT_SIGNAL2
#define OUT_SIGNAL2(SIGNAL_NAME, SIGNAL_NAME_STRING)
#endif

#ifndef XENV_ENC
#define XENV_ENC(stmt) stmt
#endif

#ifndef XENV_OUT_START
#define XENV_OUT_START
#endif

#ifndef RELEASE_SIGNAL
#define RELEASE_SIGNAL   xReleaseSignal(SignalOut); return;
#endif


/*---+---------------------------------------------------------------
     xOutEnv  extern
-------------------------------------------------------------------*/
extern void xOutEnv( xSignalNode *SignalOut
#ifdef XPATH_DEBUG_IN_ENV_FUNC
  , xChannelIdNode Port
#endif
 )
{

   I_Void  *sndPtr    =NULL;
   I_S32   msgSize    =ZERO;
   I_U32   lclPidPtr  =INVALID_LCL_PID_PTR ;
   I_S32   retVal     =ZERO;
   I_U8    actClsId   =INVALID_ACT_CLASS_ID ;
   I_U8    bicTei     =ZERO;  
   I_U8    conStatus  =ZERO;
#ifdef XTRACE
   #ifdef XIDNAMES
      char  Temp[100];
      sprintf(Temp, "xOutEnv:  %s has been received by env\n",(*SignalOut)->NameNode->Name );
      xPrintString(Temp);
      LOG_PRINT(DEBUG," Signal Number Received :::: [[%d]] : xOutEnv ", (*SignalOut)->NameNode->SignalNumber);
   #else
      xPrintString("xOutEnv:  One signal has been received by env\n");
   #endif
#endif

   switch((*SignalOut)->NameNode->SignalNumber)
   {
      
           /* Interface with CFG */
      case SN_OAMS_BICH_CFG_ALARM_IND:
           sndPtr = ((yPDP_sig_OAMS_BICH_CFG_ALARM_IND)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_OAMS_BICH_CFG_ALARM_IND)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
              LOG_PRINT(DEBUG,"[ENV:]Received NULL Pointer from module,Returning without sending to FRM..") ;
              xReleaseSignal(SignalOut);
              return;
           }
           LOG_PRINT(DEBUG,"[ENV]Send OAMS_BICH_CFG_ALARM_IND :: msgSize = %d  msgType = 0x%x",msgSize , ((SysHdr *)sndPtr)->msgType);
           break;

      case SN_OAMS_BICH_CFG_ADD_BIC_RESP:
           sndPtr = ((yPDP_sig_OAMS_BICH_CFG_ADD_BIC_RESP)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_OAMS_BICH_CFG_ADD_BIC_RESP)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
              LOG_PRINT(DEBUG,"[ENV]Received NULL Pointer from module,Returning without sending to FRM..") ;
              xReleaseSignal(SignalOut);
              return;
           }
           LOG_PRINT(DEBUG,"[ENV]Send OAMS_BICH_CFG_ADD_BIC_RESP :: msgSize = %d  msgType = 0x%x",msgSize , ((SysHdr *)sndPtr)->msgType);
           break;

      case SN_OAMS_BICH_CFG_DEL_BIC_RESP:
           sndPtr = ((yPDP_sig_OAMS_BICH_CFG_DEL_BIC_RESP)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_OAMS_BICH_CFG_DEL_BIC_RESP)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
              LOG_PRINT(DEBUG,"[ENV]Received NULL Pointer from module,Returning without sending to FRM..") ;
              xReleaseSignal(SignalOut);
              return;
           }
           LOG_PRINT(DEBUG,"[ENV]Send OAMS_BICH_CFG_DEL_BIC_RESP :: msgSize = %d  msgType = 0x%x",msgSize , ((SysHdr *)sndPtr)->msgType);
           break;

      /* PCU REL 2.5 changes starts */
      case SN_OAMS_BICH_TB_IP_LINK_DOWN:
           sndPtr = ((yPDP_sig_OAMS_BICH_TB_IP_LINK_DOWN)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_OAMS_BICH_TB_IP_LINK_DOWN)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
              LOG_PRINT(DEBUG,"[ENV]Received NULL Pointer from module,Returning without sending to FRM..") ;
              xReleaseSignal(SignalOut);
              return;
           }
           LOG_PRINT(DEBUG,"[ENV]Send OAMS_BICH_TB_IP_LINK_DOWN :: msgSize = %d  msgType = 0x%x",msgSize , ((SysHdr *)sndPtr)->msgType);
           break;

      case SN_OAMS_BICH_TRXH_IP_LINK_DOWN:
           sndPtr = ((yPDP_sig_OAMS_BICH_TRXH_IP_LINK_DOWN)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_OAMS_BICH_TRXH_IP_LINK_DOWN)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
              LOG_PRINT(DEBUG,"[ENV]Received NULL Pointer from module,Returning without sending to FRM..") ;
              xReleaseSignal(SignalOut);
              return;
           }
           LOG_PRINT(DEBUG,"[ENV]Send OAMS_BICH_TRXH_IP_LINK_DOWN :: msgSize = %d  msgType = 0x%x",msgSize , ((SysHdr *)sndPtr)->msgType);

           break;

     case SN_OAMS_BICH_TRXH_IP_LINK_UP:
           sndPtr = ((yPDP_sig_OAMS_BICH_TRXH_IP_LINK_UP)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_OAMS_BICH_TRXH_IP_LINK_UP)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
              LOG_PRINT(DEBUG,"[ENV]Received NULL Pointer from module,Returning without sending to FRM..") ;
              xReleaseSignal(SignalOut);
              return;
           }
           LOG_PRINT(DEBUG,"[ENV]Send OAMS_BICH_TRXH_IP_LINK_UP :: msgSize = %d  msgType = 0x%x",msgSize , ((SysHdr *)sndPtr)->msgType);

           break;

     case SN_OAMS_BICH_ABIHM_IP_LINK_DOWN:
           sndPtr = ((yPDP_sig_OAMS_BICH_ABIHM_IP_LINK_DOWN)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_OAMS_BICH_ABIHM_IP_LINK_DOWN)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
              LOG_PRINT(DEBUG,"[ENV]Received NULL Pointer from module,Returning without sending to FRM..") ;
              xReleaseSignal(SignalOut);
              return;
           }
           LOG_PRINT(DEBUG,"[ENV]Send OAMS_BICH_ABIHM_IP_LINK_DOWN :: msgSize = %d  msgType = 0x%x",msgSize , ((SysHdr *)sndPtr)->msgType);

          break;

     case SN_OAMS_BICH_TB_ADD_BTS_IP:
           sndPtr = ((yPDP_sig_OAMS_BICH_TB_ADD_BTS_IP)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_OAMS_BICH_TB_ADD_BTS_IP)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
              LOG_PRINT(DEBUG,"[ENV]Received NULL Pointer from module,Returning without sending to FRM..") ;
              xReleaseSignal(SignalOut);
              return;
           }
           LOG_PRINT(DEBUG,"[ENV]Send OAMS_BICH_TB_ADD_BTS_IP :: msgSize = %d  msgType = 0x%x",msgSize , ((SysHdr *)sndPtr)->msgType);

          break;

     case SN_OAMS_BICH_TB_DEL_BTS_IP:
           sndPtr = ((yPDP_sig_OAMS_BICH_TB_DEL_BTS_IP)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_OAMS_BICH_TB_DEL_BTS_IP)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
              LOG_PRINT(DEBUG,"[ENV]Received NULL Pointer from module,Returning without sending to FRM..") ;
              xReleaseSignal(SignalOut);
              return;
           }
           LOG_PRINT(DEBUG,"[ENV]Send OAMS_BICH_TB_DEL_BTS_IP :: msgSize = %d  msgType = 0x%x",msgSize , ((SysHdr *)sndPtr)->msgType);

          break;

     /* PCU REL 2.5 changes end*/
     /* Internal Interface between BICH Instance and AbisChainHandler*/
     
     case SN_BICH_INT_ADD_BIC_IN_ABIS_CHAIN:
           sndPtr = ((yPDP_sig_BICH_INT_ADD_BIC_IN_ABIS_CHAIN)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_BICH_INT_ADD_BIC_IN_ABIS_CHAIN)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
              LOG_PRINT(DEBUG,"[ENV]Received NULL Pointer from module in BICH_INT_ADD_BIC_IN_ABIS_CHAIN,Returning without sending to AbisChainHandler") ;
              xReleaseSignal(SignalOut);
              return;
           }
           addBicInAbisChain(sndPtr);
           xReleaseSignal(SignalOut);
           return;


      case SN_BICH_INT_DEL_BIC_FROM_ABIS_CHAIN:
           sndPtr = ((yPDP_sig_BICH_INT_DEL_BIC_FROM_ABIS_CHAIN)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_BICH_INT_DEL_BIC_FROM_ABIS_CHAIN)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
              LOG_PRINT(DEBUG,"[ENV]Received NULL Pointer from module in BICH_INT_DEL_BIC_FROM_ABIS_CHAIN,Returning without sending to AbisChainHandler") ;
              xReleaseSignal(SignalOut);
              return;
           }
           deleteBicFromAbisChain(sndPtr);
           xReleaseSignal(SignalOut);
           return;

      case SN_BICH_INT_UPDATE_ABIS_CHAIN_STATUS:
           bicTei = ((yPDP_sig_BICH_INT_UPDATE_ABIS_CHAIN_STATUS)(*SignalOut))->Param1;
           conStatus = ((yPDP_sig_BICH_INT_UPDATE_ABIS_CHAIN_STATUS)(*SignalOut))->Param2;
           updateAbisChainStatus(bicTei,conStatus);
           xReleaseSignal(SignalOut);
           return;
	 
      case SN_BICH_INT_SLOT_CONNECT:
           sndPtr = ((yPDP_sig_BICH_INT_SLOT_CONNECT)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_BICH_INT_SLOT_CONNECT)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
              LOG_PRINT(DEBUG,"[ENV]Received NULL Pointer from module in BICH_INT_SLOT_CONNECT,Returning without sending to AbisChainHandler") ;
              xReleaseSignal(SignalOut);
              return;
           }
           LOG_PRINT(DEBUG,"[ENV]Received BICH_INT_SLOT_CONNECT :: msgSize = %d",msgSize);
	   prepareSlotConnect(sndPtr); /*invoke abisChainHandler*/
           xReleaseSignal(SignalOut);
           return;

      case SN_BICH_INT_SLOT_DISCONNECT:
           sndPtr = ((yPDP_sig_BICH_INT_SLOT_DISCONNECT)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_BICH_INT_SLOT_DISCONNECT)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
              LOG_PRINT(DEBUG,"[ENV]Received NULL Pointer from module in BICH_INT_SLOT_DISCONNECT,Returning without sending to AbisChainHandler") ;
              xReleaseSignal(SignalOut);
              return;
           }
           LOG_PRINT(DEBUG,"[ENV]Received BICH_INT_SLOT_DISCONNECT :: msgSize = %d",msgSize);
           prepareSlotDisConnect(sndPtr,&sendBicParentNotAvail);
	   xReleaseSignal(SignalOut);
           return;


          /* Interface with ABIHM */
      case SN_OAMS_BICH_ABIHM_LINK_ESTAB_REQ:
           sndPtr = ((yPDP_sig_OAMS_BICH_ABIHM_LINK_ESTAB_REQ)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_OAMS_BICH_ABIHM_LINK_ESTAB_REQ)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
              LOG_PRINT(DEBUG,"[ENV]Received NULL Pointer from module,Returning without sending to FRM..") ;
              xReleaseSignal(SignalOut);
              return;
           }
           LOG_PRINT(DEBUG,"[ENV]Send OAMS_BICH_ABIHM_LINK_ESTAB_REQ :: msgSize = %d  msgType = 0x%x",msgSize , ((SysHdr *)sndPtr)->msgType);
           break;

      case SN_OAMS_BICH_ABIHM_BIC_SLOT_CONNECT:
           sndPtr = ((yPDP_sig_OAMS_BICH_ABIHM_BIC_SLOT_CONNECT)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_OAMS_BICH_ABIHM_BIC_SLOT_CONNECT)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
              LOG_PRINT(DEBUG,"[ENV]Received NULL Pointer from module,Returning without sending to FRM..") ;
              xReleaseSignal(SignalOut);
              return;
           }
           LOG_PRINT(DEBUG," [ENV]Send OAMS_BICH_ABIHM_BIC_SLOT_CONNECT :: msgSize = %d  msgType = 0x%x",msgSize , ((SysHdr *)sndPtr)->msgType);
           break;

      case SN_OAMS_BICH_ABIHM_BIC_SLOT_DISCONNECT:
           sndPtr = ((yPDP_sig_OAMS_BICH_ABIHM_BIC_SLOT_DISCONNECT)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_OAMS_BICH_ABIHM_BIC_SLOT_DISCONNECT)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
              LOG_PRINT(DEBUG,"[ENV]Received NULL Pointer from module,Returning without sending to FRM..") ;
              xReleaseSignal(SignalOut);
              return;
           }
           LOG_PRINT(DEBUG,"[ENV]Send OAMS_BICH_ABIHM_BIC_SLOT_DISCONNECT :: msgSize = %d  msgType = 0x%x",msgSize , ((SysHdr *)sndPtr)->msgType);
           break;
      
      case SN_BICH_INT_ADD_TAU_INST_IN_INSTMAP :
           actClsId = ((yPDP_sig_BICH_INT_ADD_TAU_INST_IN_INSTMAP)(*SignalOut))->Param1;
           lclPidPtr = (I_U32)((*SignalOut)->Sender.LocalPId);
           if ((retVal = AddTauInst(lclPidPtr, SELF_ENTITY_ID, actClsId)) != INST_SUCCESS)
           {
              LOG_PRINT(CRITICAL,"xOutEnv: AddTauInstId Failed lclPid = " \
                          "0x%x, [Act Cls Id = %d], [errCode = %d]",(I_U32)lclPidPtr, actClsId ,retVal);
           }
           else
           {
               LOG_PRINT(DEBUG,"xOutEnv :AddTauInstId Success lclPid = " \
                          "0x%x, [Act Cls Id = %d]",(I_U32)lclPidPtr, actClsId);
               /* CS4.0: HA changes start */
               gSignalSent--;
               LOG_PRINT(INFO, "gSignalSent: %d", gSignalSent);
               if ( gSignalSent == 0 && gInstancesCreated == I_FALSE )
               {
                  gCurrentCardState = gNewCardState; 
                  gNewCardState = CARDSTATE_INVALID;
                  gInstancesCreated = I_TRUE;
                  LOG_PRINT(INFO,"CurrentCardState: [%d]", gCurrentCardState) ; 
                  LOG_PRINT(INFO,"NewCardState:  [%d]", gNewCardState) ;
                  RELEASE_MUTEX;
									
                 // LOG_PRINT(INFO,"Moving to ACTIVE.. ");
               }
               /* CS4.0: HA changes End */
           }
           xReleaseSignal(SignalOut);
           return;

      case SN_BICH_INT_FREE_INST :
           actClsId = ((yPDP_sig_BICH_INT_FREE_INST)(*SignalOut))->Param1;
           lclPidPtr = (I_U32)((*SignalOut)->Sender.LocalPId);
           if ((retVal = FreInstId(lclPidPtr, SELF_ENTITY_ID,actClsId)) != INST_SUCCESS)
           {
              LOG_PRINT(CRITICAL, "xOutEnv : FreeInstId() Failed lclPidPtr = 0x%x [Act Cls Id = %d], [errCode =%d]",lclPidPtr, actClsId,retVal);
           }
           else
           {
              LOG_PRINT(DEBUG, "xOutEnv : FreeInstId() Success lclPidPtr = 0x%x [Act Cls Id = %d]",lclPidPtr, actClsId);
           }
           xReleaseSignal(SignalOut);
           return;

           /* Interface with SWMH */

      case SN_OAMS_BICH_SWMH_BIC_HELLO:
           sndPtr = ((yPDP_sig_OAMS_BICH_SWMH_BIC_HELLO)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_OAMS_BICH_SWMH_BIC_HELLO)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
              LOG_PRINT(DEBUG,"[ENV]Received NULL Pointer from module,Returning without sending to FRM..") ;
              xReleaseSignal(SignalOut);
              return;
           }
           LOG_PRINT(DEBUG," [ENV]Send OAMS_BICH_SWMH_BIC_HELLO :: msgSize = %d  msgType = 0x%x",msgSize , ((SysHdr *)sndPtr)->msgType);
           break;

      case SN_OAMS_BICH_SWMH_LAPD_LINK_DOWN:
           sndPtr = ((yPDP_sig_OAMS_BICH_SWMH_LAPD_LINK_DOWN)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_OAMS_BICH_SWMH_LAPD_LINK_DOWN)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
              LOG_PRINT(DEBUG,"[ENV]Received NULL Pointer from module,Returning without sending to FRM..") ;
              xReleaseSignal(SignalOut);
              return;
           }
           LOG_PRINT(DEBUG," [ENV]Send OAMS_BICH_SWMH_LAPD_LINK_DOWN :: msgSize = %d  msgType = 0x%x",msgSize , ((SysHdr *)sndPtr)->msgType);
           break;
      /* CS4.0: HA changes start */
      case SN_BICH_INT_ACTIVE_CLASS_PID :
           gLclPidActiveClass = (I_U32)((*SignalOut)->Sender.LocalPId);
           LOG_PRINT(DEBUG, "xOutEnv : System class LCLPID: 0x%0x", \
                              gLclPidActiveClass);
           LOG_PRINT(DEBUG," [ENV]LocalPid for active class is %d",gLclPidActiveClass);
           xReleaseSignal(SignalOut);
           return;
        case SN_BICH_INT_SELFCARD_STATE_CHANGE_RESP :
           LOG_PRINT(DEBUG, "xOutEnv : Received signal SN_BICH_INT_SELFCARD_STATE_CHANGE_RESP");
           gSignalSent--;
           LOG_PRINT(INFO, "gSignalSent: %d", gSignalSent);
           if ( gSignalSent == 0 )
           {
              freeAllE1AndTimeSlotNode();
              LOG_PRINT(INFO," Timers stopped for all the instances while going ACTIVE to INSERVICE/RECOVERY state ");
              activeStateHandler();
               
           }
           xReleaseSignal(SignalOut);
           return;

      /* CS4.0: HA changes End */
       /* CCUH chages start */
      case SN_OAMS_BICH_CCUH_LAPD_LINK_UP:
           sndPtr = ((yPDP_sig_OAMS_BICH_CCUH_LAPD_LINK_UP)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_OAMS_BICH_CCUH_LAPD_LINK_UP)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
              LOG_PRINT(DEBUG,"[ENV]Received NULL Pointer from module,Returning without sending to FRM..") ;
              xReleaseSignal(SignalOut);
              return;
           }
           LOG_PRINT(DEBUG," [ENV]Send OAMS_BICH_CCUH_LAPD_LINK_UP :: msgSize = %d  msgType = 0x%x",msgSize , ((SysHdr *)sndPtr)->msgType);
           break;
      case SN_OAMS_BICH_CCUH_LAPD_LINK_DOWN:
           sndPtr = ((yPDP_sig_OAMS_BICH_CCUH_LAPD_LINK_DOWN)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_OAMS_BICH_CCUH_LAPD_LINK_DOWN)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
              LOG_PRINT(DEBUG,"[ENV]Received NULL Pointer from module,Returning without sending to FRM..") ;
              xReleaseSignal(SignalOut);
              return;
           }
           LOG_PRINT(DEBUG," [ENV]Send OAMS_BICH_CCUH_LAPD_LINK_DOWN :: msgSize = %d  msgType = 0x%x",msgSize , ((SysHdr *)sndPtr)->msgType);
           break;
       case SN_OAMS_BICH_ABIHM_BSC_BIC_CFG_REQ:
           sndPtr = ((yPDP_sig_OAMS_BICH_ABIHM_BSC_BIC_CFG_REQ)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_OAMS_BICH_ABIHM_BSC_BIC_CFG_REQ)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
              LOG_PRINT(DEBUG,"[ENV]Received NULL Pointer from module,Returning without sending to FRM..") ;
              xReleaseSignal(SignalOut);
              return;
           }
           LOG_PRINT(DEBUG," [ENV]Send OAMS_BICH_ABIHM_BSC_BIC_CFG_REQ :: msgSize = %d  msgType = 0x%x",msgSize , ((SysHdr *)sndPtr)->msgType);
           break;
        case SN_OAMS_BICH_ABIHM_BIC_CC_PWR_ORDER_REQ:
           sndPtr = ((yPDP_sig_OAMS_BICH_ABIHM_BIC_CC_PWR_ORDER_REQ)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_OAMS_BICH_ABIHM_BIC_CC_PWR_ORDER_REQ)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
              LOG_PRINT(DEBUG,"[ENV]Received NULL Pointer from module,Returning without sending to FRM..") ;
              xReleaseSignal(SignalOut);
              return;
           }
           LOG_PRINT(DEBUG," [ENV]Send  OAMS_BICH_ABIHM_BIC_CC_PWR_ORDER_REQ :: msgSize = %d  msgType = 0x%x",msgSize , ((SysHdr *)sndPtr)->msgType);
           break;

      /* CCUH chages End */
        case SN_OAMS_BICH_ABIHM_LINK_DISC_REQ:
           sndPtr = ((yPDP_sig_OAMS_BICH_ABIHM_LINK_DISC_REQ)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_OAMS_BICH_ABIHM_LINK_DISC_REQ)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
              LOG_PRINT(DEBUG,"[ENV]Received NULL Pointer from module,Returning without sending to FRM..") ;
              xReleaseSignal(SignalOut);
              return;
           }
           LOG_PRINT(DEBUG," [ENV]Send  OAMS_BICH_ABIHM_LINK_DISC_REQ:: msgSize = %d  msgType = 0x%x",msgSize , ((SysHdr *)sndPtr)->msgType);
           break;

           /* Default */
      default:
           LOG_PRINT(DEBUG," Entered Default Case : xOutEnv \n");
           sndPtr = ((yPDP_sig_OAMS_BICH_CFG_ALARM_IND)(*SignalOut))->Param1;
           if (sndPtr!=NULL)
           {
              DalocMsgBuf((I_Void *)sndPtr);
           }
           xReleaseSignal(SignalOut);
           return;
  
   }/*switch */
   
   LOG_PRINT(DEBUG,"OUT OF SWITCH XOUT::ENV");
   if (sndPtr != NULL)
   {
      if (SendMsg(sndPtr, MSG_ORD_PRIO, msgSize) == SND_FAIL)
      {
         LOG_PRINT(MAJOR,"[ENV]SENDING FAILED");
         DalocMsgBuf((I_Void *)sndPtr);
         xReleaseSignal(SignalOut);
         return;
      }
      else
      {
         LOG_PRINT(DEBUG,"[ENV]Successfully sent message out");
         xReleaseSignal(SignalOut);
         return;
      }
   }
   else
   {
      LOG_PRINT(CRITICAL,"[ENV]BICH: UNABLE TO ALLOCATE MEMORY FOR THE MESSAGE, sndPtr is NULL");
   }
   /* Signals going to the env via the port ToEnv  */

}/*xOutEnv*/


/*---+---------------------------------------------------------------
     Macros for xInEnv
-------------------------------------------------------------------*/
#ifndef IN_LOCAL_VARIABLES
#define IN_LOCAL_VARIABLES \
  xSignalNode SignalIn;
#endif

#ifndef IN_SIGNAL1
#define IN_SIGNAL1(SIGNAL_NAME, SIGNAL_NAME_STRING) \
  SignalIn = xGetSignal(SIGNAL_NAME, xNotDefPId, xEnv);
#endif

#ifndef IN_SIGNAL2
#define IN_SIGNAL2(SIGNAL_NAME, SIGNAL_NAME_STRING) \
  SDL_Output(SignalIn xSigPrioPar(xDefaultPrioSignal), (xIdNode *)0);
#endif

#ifndef IF_IN_SIGNAL
#define IF_IN_SIGNAL(SIGNAL_NAME, SIGNAL_NAME_STRING) \
  if (TEST_IF_IN_SIGNAL(SIGNAL_NAME)) {
#define END_IF_IN_SIGNAL(SIGNAL_NAME, SIGNAL_NAME_STRING) \
  }
#endif

#ifndef TEST_IF_IN_SIGNAL
#define TEST_IF_IN_SIGNAL(SIGNAL_NAME)  0
#endif

#ifndef XENV_DEC
#define XENV_DEC(stmt) stmt
#endif

#ifndef XENV_IN_START
#define XENV_IN_START
#endif

#ifndef XENV_IN_END
#define XENV_IN_END
#endif


/*---+---------------------------------------------------------------
     xInEnv  extern
-------------------------------------------------------------------*/
#ifndef XTENV
extern void xInEnv ( SDL_Time Time_for_next_event )
#else
extern SDL_Duration xInEnv ( SDL_Time Time_for_next_event )
#endif
{
   xSignalNode S;


#ifdef XTRACE
#ifndef XNOXINENVTRACE
   xPrintString( "xInEnv: Called!\n");
#endif
#endif

   I_Void         *rcvPtr     =NULL;
   I_S32          msgSize     =ZERO;
   I_S32          instId      =INVALID_INST_ID;
   I_U16          msgType     =ZERO;
   I_U8           subType     =ZERO;
   SDL_Pid        rcvr;
   I_U32          lclPidPtr   =INVALID_LCL_PID_PTR; 
   I_U32          refId       =INVALID_REF_ID;
   I_U8           bicTei      =ZERO;
   I_U32          bicId       =ZERO;
   I_U32          fromBicId   =ZERO;
   I_U8           dsPort      =ZERO;
   I_U8           conStatus   =ZERO;
   I_U8           numBic      =ZERO;
   I_U8           count;       
   I_U8           srcEntId;  
   struct sAisParam *param;     
   if (((rcvPtr = (I_Void *)RecvMsg(selfEntIdG, &msgSize)) != NULL) )
   {
      msgType = ((SysHdr *)rcvPtr)->msgType;
      subType = ((SysHdr *)rcvPtr)->subType;
      instId = ((SysHdr *)rcvPtr)->dest.inst;
      srcEntId = ((SysHdr *)rcvPtr)->src.entity;
      LOG_PRINT(DEBUG,"[ENV]Messgae Received for BICHM msgTyp = 0x%x and \
                      subType = %d SrcEntityId = %d",msgType,subType,srcEntId);
      rcvr.GlobalNodeNr = (I_S32)selfEntIdG;
      rcvr.LocalPId = (xLocalPIdNode)0;
      lclPidPtr = INVALID_LCL_PID_PTR;
      /* CS4.0: Changes for HA Start */
      if ( gHandleMsgAllowed == I_TRUE )
      {
      /* CS4.0: Changes for HA End */
      switch(msgType)
      {
         /* Send this Message into TAU model */

         /* Interface to CFG */
         case OAMS_CFG_BICH_INIT_ABIS_E1:
	       {
            LOG_PRINT(DEBUG,"[ENV]OAMS_CFG_BICH_INIT_ABIS_E1: signal received from CFG");
            initAbisChain(rcvPtr); 
            DalocMsgBuf((I_Void *)rcvPtr) ;
            return ;
	       }
         case OAMS_CFG_BICH_UPDATE_ABIS_E1:
         {
            LOG_PRINT(DEBUG,"[ENV]OAMS_CFG_BICH_UPDATE_ABIS_E1: signal received from CFG");
            initAbisChain(rcvPtr); /*delete the existing TS and update the E1 Ts */ 
            DalocMsgBuf((I_Void *)rcvPtr) ;
            return ;
	       }
         /* Start , BB , CS30 E1 Usage Type Changes 19-05-09::17:22 */ 
         case OAMS_CFG_BICH_DELETE_ABIS_E1: 
         { 
            LOG_PRINT(DEBUG,"[ENV]OAMS_CFG_BICH_DELETE_ABIS_E1: signal received from CFG"); 
            deleteAbisChain(rcvPtr);  /*delete the existing TS for the Given E1 */  
            DalocMsgBuf((I_Void *)rcvPtr) ; 
            return ; 
         }          
         /* End , BB , CS30 E1 Usage Type Changes 19-05-09::17:22 */           
         case OAMS_CFG_BICH_ADD_BIC_REQ:
         {
            LOG_PRINT(DEBUG,"xInEnv : OAMS_CFG_BICH_ADD_BIC_REQ \
                             received");
            if ( !addTsNodeInAbisChain(rcvPtr) ) {              
               LOG_PRINT(CRITICAL, "[%s] : addTsNodeInAbisChain() Failed for BICHM",__func__);
               return ;
            }
            refId = GetRefId(rcvPtr) ;
            if (AlocNewInst(&lclPidPtr, &instId, SELF_ENTITY_ID,
                            BICHM_ACT_CLID,refId,
                            ZERO, ZERO, ZERO, ZERO)  != INST_SUCCESS)
            {
               LOG_PRINT(CRITICAL, "xInEnv : AlocNewInst() Failed for BICHM");
               DalocMsgBuf((I_Void *)rcvPtr) ;
               return; 
            }
            LOG_PRINT(DEBUG, "xInEnv : NEW INSTANCE ALLOCATED FOR BICHM  \
                              LCLPID: 0x%0x, INSTANCE-ID: %d, BIC-ID: %u",
                              lclPidPtr, instId, refId);
            rcvr.LocalPId = (xLocalPIdNode)lclPidPtr;
            S = xGetSignal( sig_OAMS_CFG_BICH_ADD_BIC_REQ, rcvr, xEnv);
            (((yPDP_sig_OAMS_CFG_BICH_ADD_BIC_REQ)S)->Param1) = rcvPtr;
            break;
         }

         case OAMS_CFG_BICH_DEL_BIC_REQ:
         {
            LOG_PRINT(DEBUG,"[ENV]OAMS_CFG_BICH_DEL_BIC_REQ: signal received from CFG");
            if ((rcvr.LocalPId = (xLocalPIdNode)FindBichLocalPidPtr(rcvPtr)) == INVALID_LCL_PID_PTR)
            {
               LOG_PRINT(DEBUG,"[ENV]Failed to find Instance for Incoming request");
               DalocMsgBuf((I_Void *)rcvPtr) ;
               return ;
            }
            S = xGetSignal( sig_OAMS_CFG_BICH_DEL_BIC_REQ, rcvr, xEnv);
            (((yPDP_sig_OAMS_CFG_BICH_DEL_BIC_REQ)S)->Param1) = rcvPtr;
            break;
         }
         /*R2.2 Changes Start*/
         case OAMS_CFG_BICH_UNLOCK_REQ:
         {
            LOG_PRINT(DEBUG,"[ENV]OAMS_CFG_BICH_UNLOCK_REQ: signal received from CFG");
            if ((rcvr.LocalPId = (xLocalPIdNode)FindBichLocalPidPtr(rcvPtr)) == INVALID_LCL_PID_PTR)
            {
               LOG_PRINT(DEBUG,"[ENV]Failed to find Instance for Incoming request");
               DalocMsgBuf((I_Void *)rcvPtr) ;
               return ;
            }
            S = xGetSignal( sig_OAMS_CFG_BICH_UNLOCK_REQ, rcvr, xEnv);
            (((yPDP_sig_OAMS_CFG_BICH_UNLOCK_REQ)S)->Param1) = rcvPtr;
            break;
         }
         
        case OAMS_CFG_BICH_LOCK_REQ:
         {
            LOG_PRINT(DEBUG,"[ENV]OAMS_CFG_BICH_LOCK_REQ: signal received from CFG");
            if ((rcvr.LocalPId = (xLocalPIdNode)FindBichLocalPidPtr(rcvPtr)) == INVALID_LCL_PID_PTR)
            {
               LOG_PRINT(DEBUG,"[ENV]Failed to find Instance for Incoming request");
               DalocMsgBuf((I_Void *)rcvPtr) ;
               return ;
            }
            S = xGetSignal( sig_OAMS_CFG_BICH_LOCK_REQ, rcvr, xEnv);
            (((yPDP_sig_OAMS_CFG_BICH_LOCK_REQ)S)->Param1) = rcvPtr;
            break;
         }
        
       case OAMS_CFG_BICH_ADD_TRX_INDICATION:
         {
            LOG_PRINT(DEBUG,"[ENV]OAMS_CFG_BICH_ADD_TRX_INDICATION: signal received from CFG");
            if ((rcvr.LocalPId = (xLocalPIdNode)FindBichLocalPidPtr(rcvPtr)) == INVALID_LCL_PID_PTR)
            {
               LOG_PRINT(DEBUG,"[ENV]Failed to find Instance for Incoming request");
               DalocMsgBuf((I_Void *)rcvPtr) ;
               return ;
            }
            S = xGetSignal( sig_OAMS_CFG_BICH_ADD_TRX_INDICATION, rcvr, xEnv);
            (((yPDP_sig_OAMS_CFG_BICH_ADD_TRX_INDICATION)S)->Param1) = rcvPtr;
            break;
         }
       case OAMS_CFG_BICH_DEL_TRX_INDICATION:
         {
            LOG_PRINT(DEBUG,"[ENV]OAMS_CFG_BICH_DEL_TRX_INDICATION: signal received from CFG");
            if ((rcvr.LocalPId = (xLocalPIdNode)FindBichLocalPidPtr(rcvPtr)) == INVALID_LCL_PID_PTR)
            {
               LOG_PRINT(DEBUG,"[ENV]Failed to find Instance for Incoming request");
               DalocMsgBuf((I_Void *)rcvPtr) ;
               return ;
            }
            S = xGetSignal( sig_OAMS_CFG_BICH_DEL_TRX_INDICATION, rcvr, xEnv);
            (((yPDP_sig_OAMS_CFG_BICH_DEL_TRX_INDICATION)S)->Param1) = rcvPtr;
            break;
         }
       case OAMS_CFG_BICH_BTS_RESET:
         {
            LOG_PRINT(DEBUG,"[ENV]OAMS_CFG_BICH_BTS_RESET: signal received from CFG");
            if ((rcvr.LocalPId = (xLocalPIdNode)FindBichLocalPidPtr(rcvPtr)) == INVALID_LCL_PID_PTR)
            {
               LOG_PRINT(DEBUG,"[ENV]Failed to find Instance for Incoming request");
               DalocMsgBuf((I_Void *)rcvPtr) ;
               return ;
            }
            S = xGetSignal( sig_OAMS_CFG_BICH_BTS_RESET, rcvr, xEnv);
            (((yPDP_sig_OAMS_CFG_BICH_BTS_RESET)S)->Param1) = rcvPtr;
            break;
         }
      /* case OAMS_CFG_BICH_TRX_RESET:
         {
            LOG_PRINT(DEBUG,"[ENV]OAMS_CFG_BICH_TRX_RESET: signal received from CFG");
            if ((rcvr.LocalPId = (xLocalPIdNode)FindBichLocalPidPtr(rcvPtr)) == INVALID_LCL_PID_PTR)
            {
               LOG_PRINT(DEBUG,"[ENV]Failed to find Instance for Incoming request");
               DalocMsgBuf((I_Void *)rcvPtr) ;
               return ;
            }
            S = xGetSignal( sig_OAMS_CFG_BICH_TRX_RESET, rcvr, xEnv);
            (((yPDP_sig_OAMS_CFG_BICH_TRX_RESET)S)->Param1) = rcvPtr;
            break;
         }*/

         /*R2.2 Changes End*/
         /* Interface to ABIHM */
         case CSAPP_ABIHM_BICH_BIC_HELLO:
         {
            LOG_PRINT(DEBUG,"[ENV]CSAPP_ABIHM_BICH_BIC_HELLO: signal received from ABIHM");
            if ((rcvr.LocalPId = (xLocalPIdNode)FindBichLocalPidPtr(rcvPtr)) == INVALID_LCL_PID_PTR)
            {
               LOG_PRINT(DEBUG,"[ENV]Failed to find Instance for Incoming request");  
               bicId = ((CsappAbihmBichBicHello *)rcvPtr)->bicId;
               bicTei = ((CsappAbihmBichBicHello *)rcvPtr)->bicTei;
	             CreateMsgBichCfgAlarmInd(bicId,ZERO,ZERO,bicTei);/*If BIC_HELLO received for Not Configured BIC raise alarm BIC_UNKNOWN*/
               DalocMsgBuf((I_Void *)rcvPtr) ;
               return ;
            }
            bicTei = ((CsappAbihmBichBicHello *)rcvPtr)->bicTei;
            conStatus=getAbisChainStatus(bicTei);
            if (ABIS_E1_STATUS_NO_BIC != conStatus)
            {
               DalocMsgBuf((I_Void *)rcvPtr) ;/*discard the signal*/
               LOG_PRINT(INFO,"[ENV:]BIC_HELLO:signal discarded,it is received for connected bic or connection in progress bic");
	       return;
	    }
            S = xGetSignal( sig_CSAPP_ABIHM_BICH_BIC_HELLO, rcvr, xEnv);
            (((yPDP_sig_CSAPP_ABIHM_BICH_BIC_HELLO)S)->Param1) = rcvPtr;
            break;
         }

         case CSAPP_ABIHM_BICH_BM_HELLO:
         {
            LOG_PRINT(DEBUG,"[ENV]CSAPP_ABIHM_BICH_BM_HELLO: signal received from ABIHM");
            if ((rcvr.LocalPId = (xLocalPIdNode)FindBichLocalPidPtr(rcvPtr)) == INVALID_LCL_PID_PTR)
            {
               LOG_PRINT(DEBUG,"[ENV]Failed to find Instance for Incoming request");  
               bicId = ((CsappAbihmBichBmHello *)rcvPtr)->btsId;
               bicTei = ((CsappAbihmBichBmHello *)rcvPtr)->bicTei;
	             CreateMsgBichCfgAlarmInd(bicId,ZERO,ZERO,bicTei);
               DalocMsgBuf((I_Void *)rcvPtr) ;
               return ;
            }
            bicTei = ((CsappAbihmBichBmHello *)rcvPtr)->bicTei;
            conStatus=getAbisChainStatus(bicTei);
            if (ABIS_E1_STATUS_NO_BIC != conStatus)
             {/*Changes starts for #19948*/ 
               if((ABIS_E1_STATUS_BIC_CONNECTED== conStatus) ||(ABIS_E1_STATUS_BIC_CON_IN_PROGRESS == 
                     conStatus))/*Changes for Mantis 23210 */
               {  
               I_U16 instanceId=ZERO;
               LOG_PRINT(INFO,"[ENV:],rcvr.LocalPId %d, for bicTei %d",rcvr.LocalPId,bicTei);
               if(GetInstId(rcvr.LocalPId,ENT_OAMS_BICH,BIC_HANDLER,&instanceId) !=  INST_FAIL_INVALID_KEY)
               {
                LOG_PRINT(INFO,"[ENV:],rcvr.LocalPId %d, instId %d",rcvr.LocalPId,instanceId);
                if (lapdDiscCntxt[(instanceId-ONE)].bmHelloCnt >= MAX_BM_HELLO_CNT_CNCTD_OR_CIP_STATE)
                   {
                   LOG_PRINT(INFO,"[ENV:]BM_HELLO:is received for connected or conn in Prog State(AppTei %d),Max bmHelloCnt Reached, Sending BTS LAPD DISC to Lapd Stack",bicTei);
                   
                   fillAndSendLapdDiscIndForBts(bicTei);
                   lapdDiscCntxt[(instanceId-ONE)].bicTei=ZERO;
                   lapdDiscCntxt[(instanceId-ONE)].bmHelloCnt=ZERO;
                   DalocMsgBuf((I_Void *)rcvPtr) ;/*discard the signal*/
                   return;
                   }
                   else
                   {
                   lapdDiscCntxt[(instanceId-ONE)].bicTei=bicTei ;
                   lapdDiscCntxt[(instanceId-ONE)].bmHelloCnt++ ;
                   LOG_PRINT(INFO,"[ENV:]BM_HELLO: discarded for connected or conn in Prog State Bic (AppTei %d) ,bmHelloCnt %d ",lapdDiscCntxt[(instanceId-ONE)].bicTei,lapdDiscCntxt[(instanceId-ONE)].bmHelloCnt);
                   
                   }  
               }/*Changes Ends for #19948*/
              }
               DalocMsgBuf((I_Void *)rcvPtr) ;/*discard the signal*/
               LOG_PRINT(INFO,"[ENV:]BM_HELLO:signal discarded,it is received for connected bic or connection in progress bic");
               return;
	          }
            else
            {
               I_U16 instanceId=ZERO;/*Changes for Mantis 23210 */
               LOG_PRINT(INFO,"[ENV:],rcvr.LocalPId %d, for bicTei %d",rcvr.LocalPId,bicTei);
               if(GetInstId(rcvr.LocalPId,ENT_OAMS_BICH,BIC_HANDLER,&instanceId) !=  INST_FAIL_INVALID_KEY)
               {
                   lapdDiscCntxt[(instanceId-ONE)].bicTei=ZERO;
                   lapdDiscCntxt[(instanceId-ONE)].bmHelloCnt=ZERO;
               }
            } 
            
            S = xGetSignal( sig_CSAPP_ABIHM_BICH_BM_HELLO, rcvr, xEnv);
            (((yPDP_sig_CSAPP_ABIHM_BICH_BM_HELLO)S)->Param1) = rcvPtr;
            break;
         }
         case CSAPP_ABIHM_BICH_LAPD_LINK_UP:
         {
            LOG_PRINT(DEBUG,"[ENV]CSAPP_ABIHM_BICH_LAPD_LINK_UP: signal received from ABIHM");
            if ((rcvr.LocalPId = (xLocalPIdNode)FindBichLocalPidPtr(rcvPtr)) == INVALID_LCL_PID_PTR)
            {
               LOG_PRINT(DEBUG,"[ENV]Failed to find Instance for Incoming request"); 
               DalocMsgBuf((I_Void *)rcvPtr) ;
               return ;
            }
            S = xGetSignal( sig_CSAPP_ABIHM_BICH_LAPD_LINK_UP, rcvr, xEnv);
            (((yPDP_sig_CSAPP_ABIHM_BICH_LAPD_LINK_UP)S)->Param1) = rcvPtr;
            break;
         }
    
         case CSAPP_ABIHM_BICH_LAPD_LINK_DOWN:
         {
            LOG_PRINT(DEBUG,"[ENV]CSAPP_ABIHM_BICH_LAPD_LINK_DOWN: signal received from ABIHM");
            if ((rcvr.LocalPId = (xLocalPIdNode)FindBichLocalPidPtr(rcvPtr)) == INVALID_LCL_PID_PTR)
            {
               LOG_PRINT(DEBUG,"[ENV]Failed to find Instance for Incoming request");   
               DalocMsgBuf((I_Void *)rcvPtr) ;
               return ;
            }
            S = xGetSignal( sig_CSAPP_ABIHM_BICH_LAPD_LINK_DOWN, rcvr, xEnv);
            (((yPDP_sig_CSAPP_ABIHM_BICH_LAPD_LINK_DOWN)S)->Param1) = rcvPtr;
            break;
         }

         /*PCU Rel 2.5 Changes Start */
         case CSAPP_ABIHM_BICH_IP_LINK_DOWN:
         {
            LOG_PRINT(DEBUG,"[ENV]CSAPP_ABIHM_BICH_IP_LINK_DOWN: signal received from ABIHM");
            if ((rcvr.LocalPId = (xLocalPIdNode)FindBichLocalPidPtr(rcvPtr)) == INVALID_LCL_PID_PTR)
            {
               LOG_PRINT(DEBUG,"[ENV]Failed to find Instance for Incoming request");
               DalocMsgBuf((I_Void *)rcvPtr) ;
               return ;
            }
            S = xGetSignal( sig_CSAPP_ABIHM_BICH_IP_LINK_DOWN, rcvr, xEnv);
            (((yPDP_sig_CSAPP_ABIHM_BICH_IP_LINK_DOWN)S)->Param1) = rcvPtr;
            break;
         }

         case PSAPP_TB_BICH_IP_LINK_DOWN:
         {
            LOG_PRINT(DEBUG,"[ENV]PSAPP_TB_BICH_IP_LINK_DOWN: signal received from TB");
            if ((rcvr.LocalPId = (xLocalPIdNode)FindBichLocalPidPtr(rcvPtr)) == INVALID_LCL_PID_PTR)
            {
               LOG_PRINT(DEBUG,"[ENV]Failed to find Instance for Incoming request");
               DalocMsgBuf((I_Void *)rcvPtr) ;
               return ;
            }
            S = xGetSignal( sig_PSAPP_TB_BICH_IP_LINK_DOWN, rcvr, xEnv);
            (((yPDP_sig_PSAPP_TB_BICH_IP_LINK_DOWN)S)->Param1) = rcvPtr;
            break;
         }

         case PSAPP_TB_BICH_IP_LINK_UP:
         {
            LOG_PRINT(DEBUG,"[ENV]PSAPP_TB_BICH_IP_LINK_UP: signal received from TB");
            if ((rcvr.LocalPId = (xLocalPIdNode)FindBichLocalPidPtr(rcvPtr)) == INVALID_LCL_PID_PTR)
            {
               LOG_PRINT(DEBUG,"[ENV]Failed to find Instance for Incoming request");
               DalocMsgBuf((I_Void *)rcvPtr) ;
               return ;
            }
            S = xGetSignal( sig_PSAPP_TB_BICH_IP_LINK_UP, rcvr, xEnv);
            (((yPDP_sig_PSAPP_TB_BICH_IP_LINK_UP)S)->Param1) = rcvPtr;
            break;
         }

        /*PCU Rel 2.5 Changes End */

         case CSAPP_ABIHM_BICH_BIC_DS_LINK_EST:
         {
            LOG_PRINT(DEBUG,"[ENV]CSAPP_ABIHM_BICH_BIC_DS_LINK_EST: signal received from ABIHM");
            if ((rcvr.LocalPId = (xLocalPIdNode)FindBichLocalPidPtr(rcvPtr)) == INVALID_LCL_PID_PTR)
            {
               LOG_PRINT(DEBUG,"[ENV]Failed to find Instance for Incoming request");
               bicId = ((CsappAbihmBichDsLinkEst *)rcvPtr)->bicId;
               fromBicId = ((CsappAbihmBichDsLinkEst *)rcvPtr)->fromBicId;
               dsPort = ((CsappAbihmBichDsLinkEst *)rcvPtr)->physicalIf;
               bicTei = ((CsappAbihmBichBicHello *)rcvPtr)->bicTei;
	             CreateMsgBichCfgAlarmInd(bicId,fromBicId,dsPort,bicTei);   /*If DS_LINK_EST received for Not Configured BIC raise alarm BIC_UNKNOWN*/
               DalocMsgBuf((I_Void *)rcvPtr) ;
               return ;
            }
            S = xGetSignal( sig_CSAPP_ABIHM_BICH_BIC_DS_LINK_EST, rcvr, xEnv);
            (((yPDP_sig_CSAPP_ABIHM_BICH_BIC_DS_LINK_EST)S)->Param1) = rcvPtr;
            break;
         }

         case CSAPP_ABIHM_BICH_BIC_DS_LINK_FAIL:
         {
            LOG_PRINT(DEBUG,"[ENV]CSAPP_ABIHM_BICH_BIC_DS_LINK_FAIL: signal received from ABIHM");
            numBic = ((CsappAbihmBichDsLinkFail *)rcvPtr)->numBic;
	    for(count=0; count<numBic ; count++)
	    {
               bicId = ((CsappAbihmBichDsLinkFail *)rcvPtr)->bicIdList[count];
      	       sendMsgBichIntStoptWaitForParentConTimer(bicId);
	    }            
            if ((rcvr.LocalPId = (xLocalPIdNode)FindBichLocalPidPtr(rcvPtr)) == INVALID_LCL_PID_PTR)
            {
               LOG_PRINT(DEBUG,"[ENV]Failed to find Instance for Incoming request");
               DalocMsgBuf((I_Void *)rcvPtr) ;
               return ;
            }
            S = xGetSignal( sig_CSAPP_ABIHM_BICH_BIC_DS_LINK_FAIL, rcvr, xEnv);
            (((yPDP_sig_CSAPP_ABIHM_BICH_BIC_DS_LINK_FAIL)S)->Param1) = rcvPtr;
            break;
         }
         /* CCU changes start */
         case CSAPP_ABIHM_BICH_BSC_BIC_CFG_RESP:
         {
            CsappAbihmBichBscBicCfgResp *bscBicResp;
            LOG_PRINT(DEBUG,"[ENV]CSAPP_ABIHM_BICH_BSC_BIC_CFG_RESP: signal received from ABIHM");
            bscBicResp = ((CsappAbihmBichBscBicCfgResp *)rcvPtr);
            if ( bscBicResp -> nackCause == BSC_BIC_NACK_PARAMETER_OUT_OF_RANGE)
               LOG_PRINT(MAJOR,"[ENV]CSAPP_ABIHM_BICH_BSC_BIC_CFG_REQ failed as parameter out of range ");
            DalocMsgBuf((I_Void *)rcvPtr) ;
            return;
         }

         case OAMS_CFG_BICH_BIC_CC_PWR_ORDER_REQ:
         {
            LOG_PRINT(DEBUG,"[ENV]OAMS_CFG_BICH_BIC_CC_PWR_ORDER_REQ: signal received from CFG");
            if ((rcvr.LocalPId = (xLocalPIdNode)FindBichLocalPidPtr(rcvPtr)) == INVALID_LCL_PID_PTR)
            {
               LOG_PRINT(DEBUG,"[ENV]Failed to find Instance for Incoming request");
               DalocMsgBuf((I_Void *)rcvPtr) ;
               return ;
            }
            S = xGetSignal( sig_OAMS_CFG_BICH_BIC_CC_PWR_ORDER_REQ, rcvr, xEnv);
            (((yPDP_sig_CSAPP_ABIHM_BICH_BIC_DS_LINK_FAIL)S)->Param1) = rcvPtr;
            break;
         }
         /* CCU changes End */
         /* R1.1 Changes start */
         case CSAPP_ABIHM_BICH_BIC_BSC_ALARM_IND:
         {
            LOG_PRINT(DEBUG,"[ENV]CSAPP_ABIHM_BICH_BIC_BSC_ALARM_IND: signal received from ABIHM");
            if ((rcvr.LocalPId = (xLocalPIdNode)FindBichLocalPidPtr(rcvPtr)) == INVALID_LCL_PID_PTR)
            {
               LOG_PRINT(DEBUG,"[ENV]Failed to find Instance for Incoming request");
               DalocMsgBuf((I_Void *)rcvPtr) ;
               return ;
            }
            S = xGetSignal( sig_CSAPP_ABIHM_BICH_BIC_BSC_ALARM_IND, rcvr, xEnv);
            (((yPDP_sig_CSAPP_ABIHM_BICH_BIC_BSC_ALARM_IND)S)->Param1) = rcvPtr;
            break;
         }
         /*interface with TRXH R2.2 Changes Start*/
       case OAMS_TRXH_BICH_OPER_STATE_CHANGE_IND:
         {
            LOG_PRINT(DEBUG,"[ENV]OAMS_TRXH_BICH_OPER_STATE_CHANGE_IND: signal received from TRXH");
            if ((rcvr.LocalPId = (xLocalPIdNode)FindBichLocalPidPtr(rcvPtr)) == INVALID_LCL_PID_PTR)
            {
               LOG_PRINT(DEBUG,"[ENV]Failed to find Instance for Incoming request");
               DalocMsgBuf((I_Void *)rcvPtr) ;
               return ;
            }
            S = xGetSignal( sig_OAMS_TRXH_BICH_OPER_STATE_CHANGE_IND, rcvr, xEnv);
            (((yPDP_sig_OAMS_TRXH_BICH_OPER_STATE_CHANGE_IND)S)->Param1) = rcvPtr;
            break;
         }
         case CSAPP_ABIHM_BICH_FAILURE_EVENT_REPORT:
         {
            LOG_PRINT(DEBUG,"[ENV]CSAPP_ABIHM_BICH_FAILURE_EVENT_REPORT: signal received from ABIHM");
            if ((rcvr.LocalPId = (xLocalPIdNode)FindBichLocalPidPtr(rcvPtr)) == INVALID_LCL_PID_PTR)
            {
               LOG_PRINT(DEBUG,"[ENV]Failed to find Instance for Incoming request"); 
               DalocMsgBuf((I_Void *)rcvPtr) ;
               return ;
            }
            S = xGetSignal( sig_CSAPP_ABIHM_BICH_FAILURE_EVENT_REPORT, rcvr, xEnv);
            (((yPDP_sig_CSAPP_ABIHM_BICH_FAILURE_EVENT_REPORT)S)->Param1) = rcvPtr;
            break;
         }
         case OAMS_RM_BICHM_AIP_REQ:
         {
            LOG_PRINT(DEBUG,"[ENV]OAMS_RM_BICHM_AIP_REQ: signal received from RM");
						gRmAipRcvd = I_TRUE;
            DalocMsgBuf((I_Void *)rcvPtr) ;
						if(gBpmAipRcvd == I_TRUE)
						{
							handleRmBichAipReq();	
						}
						else
						{
							LOG_PRINT(INFO,"Waiting for BPM AIP Notification, OAMS_RM_BICHM_AIP_REQ Message Received ");
						}
            return ;
         }
         case OAMS_RM_BICHM_ACTIVE_REQ:
         {
            LOG_PRINT(DEBUG,"[ENV]OAMS_RM_BICHM_ACTIVE_REQ: signal received from RM");
						gRmAipRcvd = I_TRUE;
            DalocMsgBuf((I_Void *)rcvPtr) ;
						if(gBpmAipRcvd == I_TRUE)
						{
         	  	gCurrentCardState = gNewCardState; 
         	  	gNewCardState = CARDSTATE_INVALID;
							sendBichRmActiveResp();
							gBpmAipRcvd = I_FALSE;
							gRmAipRcvd = I_FALSE;
			      	LOG_PRINT(INFO,"CurrentCardState: [%d]", gCurrentCardState) ; 
      		  	LOG_PRINT(INFO,"NewCardState: [%d]", gNewCardState) ;
			      	RELEASE_MUTEX;
						}
						else
						{
							LOG_PRINT(INFO,"Waiting for BPM Active Notification, OAMS_RM_BICHM_ACTIVE_REQ Message Received ");
						}
            return ;
         }
         /*interface with TRXH R2.2 Changes End*/
         /* R1.1 Changes End */
         #if BPM_PRESENT != 1
         case BPM_SELFCARD_STATE_CHANGE:
         {
            LOG_PRINT(DEBUG,"[ENV]BPM_SELFCARD_STATE_CHANGE: signal received from BPM");
            param = (struct sAisParam *)(rcvPtr+sizeof(SysHdr));
            cardStateChangeHandler(param); 
            DalocMsgBuf((I_Void *)rcvPtr) ;
            return;
         }
         #endif 
         /* Default */
         default:
            LOG_PRINT(DEBUG," Entered Default Case : xInEnv");
            /* CS4.0: Changes for HA Start */
            LOG_PRINT(INFO,"CurrentCardState: [%d]", gCurrentCardState) ; 
            LOG_PRINT(INFO,"NewCardState: [%d]", gNewCardState) ; 
            /* CS4.0: Changes for HA End */
            DalocMsgBuf((I_Void *)rcvPtr) ;
            return ;

      }
      SDL_Output( S xSigPrioPar(xDefaultPrioSignal), (xIdNode *)0 );
     }
     else
     {
         #if BPM_PRESENT != 1
         if ( msgType == BPM_SELFCARD_STATE_CHANGE )
         {
            LOG_PRINT(DEBUG,"[ENV]BPM_SELFCARD_STATE_CHANGE: signal received from BPM");
            param = (struct sAisParam *)(rcvPtr+sizeof(SysHdr));
            cardStateChangeHandler(param); 
            DalocMsgBuf((I_Void *)rcvPtr) ;
            return;
         }
         #endif  
         LOG_PRINT(DEBUG," Card is not in Active..... Dalocating message ");
         DalocMsgBuf((I_Void *)rcvPtr) ;
         return ;
     }
}

#ifdef XTENV
#endif
}
