/* SKELETON for env functions */
/* Program generated by Cadvanced 3.0.0.0.2032 */
#define XSCT_CADVANCED
#define C_TRANSLATOR_2_6
#include "scttypes.h"
#ifdef XUSE_SIGNAL_NUMBERS
#include "SwMHandler.hs"
#endif
#ifdef XENV_INC
#include XENV_INC
#endif
#include "SwMHandler.ifc"
#define SELF_ENTITY_NAME "SWMH"

/* CS4.0: Changes for HA Start */
#include "bpmxxx_commonDef.h"
#include "bpmxxx_platformLib.h"
#include "ipcfrm_syslog.h"
#include "oamsswmh_swmh.h"
#include "oamsxxx_mutex.h"


I_S32 gCurrentCardState = CARDSTATE_INIT;
I_S32 gNewCardState = CARDSTATE_INVALID;
I_U32 gInstancesCreated  = I_FALSE ;
I_U32 gSignalSent = ZERO;
/* Defining Mutex */
DEFINE_MUTEX;

/* CS4.0: Changes for HA End */

#ifndef XNOGLOBALNODENUMBER
/*---+---------------------------------------------------------------
     xGlobalNodeNumber  extern
-------------------------------------------------------------------*/
#ifndef XENV_NODENUMBER
#define XENV_NODENUMBER return 1;
#endif

I_S32  selfEntIdG;
I_U32  sysClassLclPid;
#define STRING_LENGTH          100
extern int xGlobalNodeNumber(void)
{
  /* Assign a unique global system Id to each SDL system in a cluster of systems. */
   return ENT_OAMS_SWMH;
   XENV_NODENUMBER
}
#endif

 /**
  * Interface with Base Platform Module (BPM)
  * Note1: BPM is an optional feature in the system.
  * All code pertaining to BPM interface should be under a compile time
  * flag
         return;.
  */

#if BPM_PRESENT != 1

#define RegisterSwmhWithBpm() bpmGetComponentReg(ENT_OAMS_SWMH_STUB,&SwmhBpmCallbackFunc);
/* CS4.0: Changes for HA Start */
#define bpmRespondToAis(a,b)
/* CS4.0: Changes for HA End */
#warning "BPM support not compiled"

#else
void SwmhBpmCallbackFunc (struct sAisParam *param);
void RegisterSwmhWithBpm(void) 
{
   bpmGetComponentRegister (SwmhBpmCallbackFunc, APPID_OAMS_SWMH);
   bpmComponentConfigure ();
}
#endif

void SwmhBpmCallbackFunc (struct sAisParam *param)
{

   switch (param->messageId)
   {
      case BPM_HEALTHCHECK_MESSAGE:
           bpmRespondToAis (param->invocation, OK);
           break;

      case BPM_SELFCARD_STATE_CHANGE:
           /* CS4.0: Changes for HA Start*/
           LOCK_MUTEX;
           LOG_PRINT(DEBUG, "SwmhBpmCallbackFunc: MUTEX is Locked");
           cardStateChangeHandler(param);
           if ( LOCK_MUTEX_AND_WAIT != MUTEX_WAIT_COMPLETE )
	   {
              LOG_PRINT(INFO,"calling bpmRespondToAis.. ");
              bpmRespondToAis (param->invocation, OK);
              LOG_PRINT(INFO,"Moving to CARD_STATE: [%d]",param->cardState);
           }
           else
           {
              LOG_PRINT(CRITICAL,"MUTEX Wait Timed Out.. Not sending OK notification");
           }
           RELEASE_MUTEX;
           /* CS4.0: Changes for HA End*/
           break;

      case BPM_PEERCARD_STATE_CHANGE:
           LOG_PRINT(INFO, "BPM_PEERCARD_STATE_CHANGE recd, No Action Taken");
           bpmRespondToAis (param->invocation, OK);
           break;

      case BPM_MSG_ACK_PEER_HEALTH_BAD:
           LOG_PRINT(INFO, "BPM_MSG_ACK_PEER_HEALTH_BAD recd, Not Expected");
           break;

      case BPM_MSG_ACK_CONFIGURE:
           LOG_PRINT(INFO, "BPM_MSG_ACK_CONFIGURE recd");
           break;

      case BPM_MSG_ACK_CONFIGURE_RESET:
           LOG_PRINT(INFO, "BPM_MSG_ACK_CONFIGURE_RESET recd, No Action Taken");
           break;

      case BPM_SHUTDOWN:
           LOG_PRINT(INFO, "BPM_SHUTDOWN recd, Exiting");
           exit (1);
           break;

      default:
           LOG_PRINT(MAJOR, "Unexpected msg from BPM: %d", param->messageId);
           break;
   }
}

/********************************************************************/
/* CS4.0: Changes for HA Start */

I_Void cardStateChangeHandler(struct sAisParam *param)
{
   I_S32               retCode = ZERO;
   xSignalNode         S;
   SDL_Pid             rcvr;

   rcvr.GlobalNodeNr = (I_S32)selfEntIdG;
   rcvr.LocalPId = (xLocalPIdNode)0;

   LOG_PRINT(INFO,"CardStateChangeRecieved with CARD_STATE = %d", param->cardState) ;

   /* Init -> InService */
   if ( (param->cardState == CARDSTATE_IN_SERVICE) && (gCurrentCardState == CARDSTATE_INIT) )
   {
      gNewCardState = CARDSTATE_IN_SERVICE;
      LOG_PRINT(DEBUG,"Registering with DB Server...");
      retCode = dbConnect();
      if ( retCode != DBLIB_SUCCESS )
      {
         LOG_PRINT(CRITICAL,"SwMHandler: Unable to Register itself with DBServer:Exiting");
         return;
      }
      LOG_PRINT(DEBUG,"Successfully Registered with DB Server.");

      rcvr.LocalPId = (xLocalPIdNode)sysClassLclPid;

      LOG_PRINT(INFO,"Sending signal SWMH_INT_SELFCARD_STATE_CHANGE to ACTIVE class");
      gSignalSent++; /* To track No. of Signal sent to Model */
      S = xGetSignal( sig_SWMH_INT_SELFCARD_STATE_CHANGE, rcvr, xEnv);
      (((yPDP_sig_SWMH_INT_SELFCARD_STATE_CHANGE)S)->Param1) = gCurrentCardState;
      (((yPDP_sig_SWMH_INT_SELFCARD_STATE_CHANGE)S)->Param2) = gNewCardState;
      SDL_Output( S xSigPrioPar(xDefaultPrioSignal), (xIdNode *)0 );
      LOG_PRINT(INFO, "gSignalSent: %d", gSignalSent);

   } 

   /* Active -> InService*/ 
   else if ( (param->cardState == CARDSTATE_IN_SERVICE) && ( gCurrentCardState == CARDSTATE_ACTIVE)) 
   {
      gNewCardState = CARDSTATE_IN_SERVICE;
      activeStateTransitionHandler();
   }

   /* InService -> StandBy*/ 
   else if ( (param->cardState == CARDSTATE_STANDBY) && (gCurrentCardState == CARDSTATE_IN_SERVICE) )
   {
      gNewCardState = CARDSTATE_STANDBY;
      gCurrentCardState = CARDSTATE_STANDBY; 
      gNewCardState = CARDSTATE_INVALID;
      RELEASE_MUTEX;
   }  

   /* InService,StandBy -> ActiveInProgress*/ 
   else if ( (param->cardState == CARDSTATE_ACTIVE_IN_PROGRESS) &&  ( (gCurrentCardState == CARDSTATE_IN_SERVICE) || (gCurrentCardState == CARDSTATE_STANDBY) ) )
   {
      gNewCardState = CARDSTATE_ACTIVE_IN_PROGRESS;
      gCurrentCardState = CARDSTATE_ACTIVE_IN_PROGRESS; 
      gNewCardState = CARDSTATE_INVALID;
      RELEASE_MUTEX;
   }

   /* ActiveInProgress -> Active */ 
   else if ( (param->cardState == CARDSTATE_ACTIVE) && (gCurrentCardState == CARDSTATE_ACTIVE_IN_PROGRESS) )
   {
      gNewCardState = CARDSTATE_ACTIVE;
      activeInProgressStateHandler();
   }

   /* StandBy -> Recovery */ 
   else if ( (param->cardState == CARDSTATE_RECOVERY) && (gCurrentCardState == CARDSTATE_STANDBY) )
   {
      gNewCardState = CARDSTATE_RECOVERY;
      gCurrentCardState = CARDSTATE_RECOVERY;
      gNewCardState = CARDSTATE_INVALID;
      RELEASE_MUTEX;
   }

   /* Active -> Recovery */
   else if ( (param->cardState == CARDSTATE_RECOVERY) && (gCurrentCardState == CARDSTATE_ACTIVE) )
   {
      gNewCardState = CARDSTATE_RECOVERY;
      activeStateTransitionHandler();
   }

   /* Recovery -> InService */
   else if (  (param->cardState == CARDSTATE_IN_SERVICE) && 
            (gCurrentCardState == CARDSTATE_RECOVERY)  )
   {
      gNewCardState = CARDSTATE_IN_SERVICE;

      /* DeRegister with DB */
      if ((retCode = dbDestroy()) != DBLIB_SUCCESS)
      {
         LOG_PRINT(CRITICAL,"clib_destroy failed for SWMH (Error = %d)",retCode);
         return;
      }

      LOG_PRINT(DEBUG,"Registering with DB Server...");
      retCode = dbConnect();
      if ( retCode != DBLIB_SUCCESS )
      {
         LOG_PRINT(CRITICAL,"SWMHandler: Unable to Register itself with DBServer:Exiting");
         return;
      }
      LOG_PRINT(DEBUG,"Successfully Registered with DB Server.");
      gCurrentCardState = CARDSTATE_IN_SERVICE;
      gNewCardState = CARDSTATE_INVALID;
      RELEASE_MUTEX;
   }
   else if((param->cardState == CARDSTATE_IN_SERVICE) && (gCurrentCardState == CARDSTATE_DIAGNOSTIC))
   {
      gCurrentCardState = param->cardState;
      RELEASE_MUTEX;
   }
   else if ( (param->cardState == CARDSTATE_DIAGNOSTIC) || (param->cardState == CARDSTATE_UPGRADE) || (param->cardState == CARDSTATE_OUT_OF_SERVICE ) || (param->cardState == CARDSTATE_PLATFORM_INS ))
   {
      gCurrentCardState = param->cardState;
      RELEASE_MUTEX;
   }
   else
   {
      LOG_PRINT(INFO,"cardStateChangeHandler: Unexpected state received  = %d",param->cardState) ; 
   }
   LOG_PRINT(INFO,"CurrentCardState: [%d]", gCurrentCardState) ; 
   LOG_PRINT(INFO,"NewCardState: [%d]", gNewCardState) ; 
}

I_Void activeStateTransitionHandler()
{
   I_U16               instCountDwnld = ZERO;
   I_U16               instCountActivate = ZERO;
   I_S8                instCountResult = ZERO;
   I_U32               instId = ZERO;
   I_U32               lclPidPtr = INVALID_LCL_PID_PTR ;
   xSignalNode         S;
   SDL_Pid             rcvr;
   I_U32               signalSentToModel = I_FALSE;

   rcvr.GlobalNodeNr = (I_S32)selfEntIdG;
   rcvr.LocalPId = (xLocalPIdNode)0;
   instCountResult = GetInstCount(ENT_OAMS_SWMH, SWMH_DOWNLOAD , &instCountDwnld);
   if ( instCountResult == INST_SUCCESS )
   {
      instCountResult = GetInstCount(ENT_OAMS_SWMH, SWMH_ACTIVATE , &instCountActivate);
      if ( instCountResult != INST_SUCCESS )
      {
         LOG_PRINT(MAJOR,"[ENV] GetInstCount Db call failed.. ");
         return;
      }
   } 
   else
   {
      LOG_PRINT(MAJOR,"[ENV] GetInstCount Db call failed.. ");
      return;
   }

   gSignalSent = getCountAllocatedInst ( instCountDwnld, SWMH_DOWNLOAD ); /* To track No. of Signal sent to Model */
   LOG_PRINT(INFO, "gSignalSent for SWMH_DOWNLOAD : %d", gSignalSent);
   gSignalSent = gSignalSent + getCountAllocatedInst ( instCountActivate, SWMH_ACTIVATE ); /* To track No. of Signal sent to Model */
   LOG_PRINT(INFO, "gSignalSent for SWMH_ACTIVATE : %d", gSignalSent);
   for ( instId = 1; instId <= instCountDwnld; instId++ )
   {
      findLclPidPtr ( instId, SWMH_DOWNLOAD, &lclPidPtr, (I_U8)ENT_OAMS_SWMH );
      if ( lclPidPtr != INVALID_LCL_PID_PTR ) 
      {
         rcvr.LocalPId = (xLocalPIdNode)lclPidPtr;
         LOG_PRINT(INFO,"Sending signal SWMH_INT_SELFCARD_STATE_CHANGE to SWMH_DOWNLOAD class");
         S = xGetSignal( sig_SWMH_INT_SELFCARD_STATE_CHANGE, rcvr, xEnv);
         (((yPDP_sig_SWMH_INT_SELFCARD_STATE_CHANGE)S)->Param1) = gCurrentCardState;
         (((yPDP_sig_SWMH_INT_SELFCARD_STATE_CHANGE)S)->Param2) = gNewCardState;
         SDL_Output( S xSigPrioPar(xDefaultPrioSignal), (xIdNode *)0 );
         signalSentToModel = I_TRUE;
      }  
   }
   for ( instId = 1; instId <= instCountActivate; instId++ )
   {
      findLclPidPtr ( instId, SWMH_ACTIVATE, &lclPidPtr, (I_U8)ENT_OAMS_SWMH);
      if ( lclPidPtr != INVALID_LCL_PID_PTR ) 
      {
         rcvr.LocalPId = (xLocalPIdNode)lclPidPtr;
         LOG_PRINT(INFO,"Sending signal SWMH_INT_SELFCARD_STATE_CHANGE to SWMH_ACTIVATE class");
         S = xGetSignal( sig_SWMH_INT_SELFCARD_STATE_CHANGE, rcvr, xEnv);
         (((yPDP_sig_SWMH_INT_SELFCARD_STATE_CHANGE)S)->Param1) = gCurrentCardState;
         (((yPDP_sig_SWMH_INT_SELFCARD_STATE_CHANGE)S)->Param2) = gNewCardState;
         SDL_Output( S xSigPrioPar(xDefaultPrioSignal), (xIdNode *)0 );
         signalSentToModel = I_TRUE;
      }  
   }

   if ( signalSentToModel == I_FALSE)
   {
      activeStateHandler();
   }
}

I_Void activeInProgressStateHandler()
{
   I_U16                     instCountDwnld = ZERO;
   I_U16                     instCountActivate = ZERO;
   I_S8                      instCountResult = ZERO;
   I_U32                     instId = ZERO;
   I_S32 retVal              = ZERO;
   I_U32 lclPidPtr           = INVALID_LCL_PID_PTR ;
   SDL_Pid                   rcvr;
   xSignalNode               S;

   selfEntIdG = (int)ENT_OAMS_SWMH;
   rcvr.GlobalNodeNr = (I_S32)selfEntIdG;

   if ( (gCurrentCardState == CARDSTATE_ACTIVE_IN_PROGRESS) && (gNewCardState = CARDSTATE_ACTIVE) )
   {
      instCountResult = GetInstCount(ENT_OAMS_SWMH, SWMH_DOWNLOAD , &instCountDwnld);
      if ( instCountResult == INST_SUCCESS )
      {
         instCountResult = GetInstCount(ENT_OAMS_SWMH, SWMH_ACTIVATE , &instCountActivate);
         if ( instCountResult != INST_SUCCESS )
         {
            LOG_PRINT(MAJOR,"[ENV] GetInstCount Db call failed.. ");
            return;
         }
      } 
      else
      {
         LOG_PRINT(MAJOR,"[ENV] GetInstCount Db call failed.. ");
         return;
      }
      if ( gInstancesCreated == I_FALSE )
      {
         LOG_PRINT(INFO,"Initializing Inst Map Table...\n");
         InitInstMap(ENT_OAMS_SWMH, SWMH_DOWNLOAD);
         LOG_PRINT(INFO, "Called initInstMap for SWHM_DOWNLOAD : %d\n", SWMH_DOWNLOAD) ;
         InitInstMap(ENT_OAMS_SWMH, SWMH_ACTIVATE);
         LOG_PRINT(INFO, "Called initInstMap for SWHM_ACTIVATE : %d\n", SWMH_ACTIVATE) ;
         LOG_PRINT(INFO,"activeInProgressStateHandler: Sending internal signal SWMH_INT_ADD_TAU_INSTANCE to model"); 
         rcvr.LocalPId = (xLocalPIdNode)sysClassLclPid;
         gSignalSent = instCountDwnld + instCountActivate;
         S = xGetSignal( sig_SWMH_INT_ADD_TAU_INSTANCE, rcvr, xEnv);
         SDL_Output( S xSigPrioPar(xDefaultPrioSignal), (xIdNode *)0 );
         LOG_PRINT(INFO, "gSignalSent: %d", gSignalSent);

      }
      else
      {
         for ( instId = 1; instId <= instCountDwnld; instId++ )
         {
            findLclPidPtr ( instId, SWMH_DOWNLOAD, &lclPidPtr, (I_U8)ENT_OAMS_SWMH );
            if ( lclPidPtr != INVALID_LCL_PID_PTR ) 
            {
               if ((retVal = FreInstId(lclPidPtr, ENT_OAMS_SWMH, SWMH_DOWNLOAD)) != INST_SUCCESS)
               {
                  LOG_PRINT(CRITICAL, "activeInProgressStateHandler: FreeInstId() Failed lclPidPtr = 0x%x [Act Cls Id = %d], [errCode =%d]",lclPidPtr, SWMH_DOWNLOAD,retVal);
                 return;
               }
               else
               {
                  LOG_PRINT(DEBUG,"activeInProgressStateHandler: FreeInstId() Success lclPidPtr = 0x%x [Act Cls Id = %d]",lclPidPtr, SWMH_DOWNLOAD);
               }
            }
            else
            {
               LOG_PRINT(INFO,"activeInProgressStateHandler: Invalid Instance Found...");
            }
         }

         for ( instId = 1; instId <= instCountActivate; instId++ )
         {
            findLclPidPtr ( instId, SWMH_ACTIVATE, &lclPidPtr, (I_U8)ENT_OAMS_SWMH);
            if ( lclPidPtr != INVALID_LCL_PID_PTR ) 
            {
               if ((retVal = FreInstId(lclPidPtr, ENT_OAMS_SWMH, SWMH_ACTIVATE)) != INST_SUCCESS)
               {
                  LOG_PRINT(CRITICAL, "activeInProgressStateHandler: FreeInstId() Failed lclPidPtr = 0x%x [Act Cls Id = %d], [errCode =%d]",lclPidPtr, SWMH_ACTIVATE,retVal);
                 return;
               }
               else
               {
                  LOG_PRINT(DEBUG,"activeInProgressStateHandler: FreeInstId() Success lclPidPtr = 0x%x [Act Cls Id = %d]",lclPidPtr, SWMH_ACTIVATE);
               }
            }
            else
            {
               LOG_PRINT(INFO,"activeInProgressStateHandler: Invalid Instance Found...");
            }
         }
         gCurrentCardState = gNewCardState; 
         gNewCardState = CARDSTATE_INVALID;
         LOG_PRINT(INFO,"CurrentCardState: [%d]", gCurrentCardState) ; 
         LOG_PRINT(INFO,"NewCardState: [%d]", gNewCardState) ;
         RELEASE_MUTEX;
         LOG_PRINT(INFO,"Moving to ACTIVE state.. ");
      }
   }
   else
      LOG_PRINT(MAJOR,"Unexepcted State change notification received");
}  

I_Void findLclPidPtr ( I_U32 instId, I_U8 classId, I_U32 *lclPidPtr, I_U8 entId)
{
   I_S32 retCode       = ZERO;
   I_S32 localInstId   = ZERO;
   InstMapTbl          instMapTblPtr;

   LOG_PRINT(INFO,"Finding LocalPidPtr for class: %d", classId);
   retCode = GetRowFrmInstId ( &instMapTblPtr, (I_S32)instId, entId, classId);
   if ( retCode != INST_SUCCESS )
   {
      LOG_PRINT(MAJOR,"[ENV] GetRowFrmInstId Db call failed.. ");
      *lclPidPtr = INVALID_LCL_PID_PTR;
      return;
   } 
   if (  instMapTblPtr.status  == INST_FREE )
   {
       LOG_PRINT(INFO,"[ENV] Instance is not allocated.. ");
      *lclPidPtr = INVALID_LCL_PID_PTR;
      return;
   }
   retCode = SearchAlocatedInst( lclPidPtr, &localInstId,  entId, classId, instMapTblPtr.refId1, instMapTblPtr.refId2,                                   instMapTblPtr.refId3, instMapTblPtr.refId4, instMapTblPtr.refId5);
   if ( ( retCode != INST_SUCCESS ) )
   {
     *lclPidPtr = INVALID_LCL_PID_PTR;
   } 
}

I_U32 getCountAllocatedInst ( I_U32 instCount, I_U8 classId )
{
   I_U32 instId = ZERO;
   I_U32 count = ZERO;
   I_U32 lclPidPtr  = INVALID_LCL_PID_PTR ;

   LOG_PRINT(INFO," Entering getCountAllocatedInst");
   for ( instId = 1; instId <= instCount; instId++ )
   {
      findLclPidPtr ( instId, classId, &lclPidPtr, (I_U8)ENT_OAMS_SWMH );
      if ( lclPidPtr != INVALID_LCL_PID_PTR )
      {
         count++;
      }
   }
   LOG_PRINT(INFO,"Total Allocated Instance [%d]",count);
   LOG_PRINT(INFO," Exiting getCountAllocatedInst");
   return count;
}


I_Void  activeStateHandler()
{
   gCurrentCardState = gNewCardState;
   gNewCardState = CARDSTATE_INVALID;
   RELEASE_MUTEX;
}


/* CS4.0: Changes for HA End */
/********************************************************************/

#ifndef XNOINITENV
/*---+---------------------------------------------------------------
     xInitEnv  extern
-------------------------------------------------------------------*/
#ifndef XENV_INIT
#define XENV_INIT
#endif

extern void xInitEnv(void)
{
  /* Code to initialize your SDL-system environment may be inserted here */
   XENV_INIT
   selfEntIdG = (int)ENT_OAMS_SWMH;

#ifdef XTRACE
   xPrintString("xInitEnv called\n");
#endif

   //RegisterSwmhWithBpm();CLOUD

   if (RegisterWithIpcFrmwrk(selfEntIdG, (I_S8 *)"SWMH") < 0)
   {
      LOG_PRINT(CRITICAL,"Unable to Register itself with IPC FrameWork : Exiting");
      exit(0) ;
   }
   RegisterSwmhWithBpm();  

   LOG_PRINT(DEBUG,"Initializing the mutex");
   INIT_MUTEX;
//   LOG_PRINT(INFO,"** SystemName=%s, ModuleName=%s, Version=%s **",SYSTEM_NAME,SELF_ENTITY_NAME,VERSION);
   LOG_PRINT(INFO,"Registering with IPC FramWork Complete...\n");
   LOG_PRINT(INFO,"SWMH Process Initialized Successfully") ; 
   LOG_PRINT(INFO,"CurrentCardState at initialization: [%d]", gCurrentCardState) ; 
   LOG_PRINT(INFO,"NewCardState at initialization: [%d]", gNewCardState) ; 
}
#endif


#ifndef XNOCLOSEENV
/*---+---------------------------------------------------------------
     xCloseEnv  extern
-------------------------------------------------------------------*/
#ifndef XENV_CLOSE
#define XENV_CLOSE
#endif

extern void xCloseEnv(void)
{
   I_S32 retVal;


   /* Need to delete the instance maps as well. Should use CleanInstMap () for this */
   /* DeRegister with DB */
   if ((retVal = dbDestroy()) != 0)
   {
      LOG_PRINT(CRITICAL,"clib_destroy failed for SWMH (Error = %d)",retVal);
      exit(0);
   } 
/*if retVal */


#ifdef XTRACE
   xPrintString("xCloseEnv called\n");
#endif
}
#endif


/*---+---------------------------------------------------------------
     Macros for xOutEnv
-------------------------------------------------------------------*/
#ifndef OUT_LOCAL_VARIABLES
#define OUT_LOCAL_VARIABLES
#endif

#ifndef IF_OUT_SIGNAL
#define IF_OUT_SIGNAL(SIGNAL_NAME, SIGNAL_NAME_STRING) \
  if (((*SignalOut)->NameNode) == SIGNAL_NAME) {
#define END_IF_OUT_SIGNAL(SIGNAL_NAME, SIGNAL_NAME_STRING) \
  }
#endif

#ifndef OUT_SIGNAL1
#define OUT_SIGNAL1(SIGNAL_NAME, SIGNAL_NAME_STRING)
#endif

#ifndef OUT_SIGNAL2
#define OUT_SIGNAL2(SIGNAL_NAME, SIGNAL_NAME_STRING)
#endif

#ifndef XENV_ENC
#define XENV_ENC(stmt) stmt
#endif

#ifndef XENV_OUT_START
#define XENV_OUT_START
#endif

#ifndef RELEASE_SIGNAL
#define RELEASE_SIGNAL   xReleaseSignal(SignalOut); return;
#endif


/*---+---------------------------------------------------------------
     xOutEnv  extern
-------------------------------------------------------------------*/
extern void xOutEnv( xSignalNode *SignalOut
#ifdef XPATH_INFO_IN_ENV_FUNC
  , xChannelIdNode Port
#endif
 )
{
   I_PVoid sndPtr;
   I_S32   msgSize;
   I_U32   lclPidPtr;
   I_S32   retVal;
   I_U8    actClsId = 0;
  
#ifdef XTRACE
   #ifdef XIDNAMES
   char  str[STRING_LENGTH];
   sprintf(str, "xOutEnv:  %s has been received by env\n",
          (*SignalOut)->NameNode->Name );
   xPrintString(str);
   LOG_PRINT(INFO," Signal Number Received :::: [[%d]] : xOutEnv \n", (*SignalOut)->NameNode->SignalNumber);
   #else
   xPrintString("xOutEnv:  One signal has been received by env\n");
   #endif
#endif

  switch((*SignalOut)->NameNode->SignalNumber)
   {
      /* Interfaces with ABIHM */
      case SN_OAMS_SWMH_ABIHM_LOAD_DATA_INIT:
           sndPtr = ((yPDP_sig_OAMS_SWMH_ABIHM_LOAD_DATA_INIT)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_OAMS_SWMH_ABIHM_LOAD_DATA_INIT)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
              LOG_PRINT(CRITICAL,"Received NULL Pointer from module,Returning without sending to FRM..\n") ;
              xReleaseSignal(SignalOut);
              return;
           }
           LOG_PRINT(INFO," Send OAMS_SWMH_ABIHM_LOAD_DATA_INIT :: msgSize = %d  msgType = 0x%x \n",msgSize , ((SysHdr *)sndPtr)->msgType);
           break;
  
      case SN_OAMS_SWMH_ABIHM_LOAD_DATA_END:
           sndPtr = ((yPDP_sig_OAMS_SWMH_ABIHM_LOAD_DATA_END)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_OAMS_SWMH_ABIHM_LOAD_DATA_END)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
              LOG_PRINT(CRITICAL,"Received NULL Pointer from module,Returning without sending to FRM..\n") ;
              xReleaseSignal(SignalOut);
              return;
           }
           LOG_PRINT(INFO," Send OAMS_SWMH_ABIHM_LOAD_DATA_END :: msgSize = %d  msgType = 0x%x \n",
           msgSize , ((SysHdr *)sndPtr)->msgType);
           break;

      case SN_OAMS_SWMH_ABIHM_LOAD_DATA_SEG:
           sndPtr = ((yPDP_sig_OAMS_SWMH_ABIHM_LOAD_DATA_SEG)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_OAMS_SWMH_ABIHM_LOAD_DATA_SEG)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
              LOG_PRINT(CRITICAL,"Received NULL Pointer from module,Returning without sending to FRM..\n") ;
              xReleaseSignal(SignalOut);
              return;
           }
           LOG_PRINT(INFO," Send OAMS_SWMH_ABIHM_LOAD_DATA_SEG :: msgSize = %d  msgType = 0x%x \n",
           msgSize , ((SysHdr *)sndPtr)->msgType);
           break;

      case SN_OAMS_SWMH_ABIHM_ACT_SW:
           sndPtr = ((yPDP_sig_OAMS_SWMH_ABIHM_ACT_SW)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_OAMS_SWMH_ABIHM_ACT_SW)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
              LOG_PRINT(CRITICAL,"Received NULL Pointer from module,Returning without sending to FRM..\n") ;
              xReleaseSignal(SignalOut);
              return;
           }
           LOG_PRINT(INFO," Send OAMS_SWMH_ABIHM_ACT_SW :: msgSize = %d  msgType = 0x%x \n",
           msgSize , ((SysHdr *)sndPtr)->msgType);
           break;

      case SN_OAMS_SWMH_ABIHM_LOAD_DATA_ABORT:
           sndPtr = ((yPDP_sig_OAMS_SWMH_ABIHM_LOAD_DATA_ABORT)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_OAMS_SWMH_ABIHM_LOAD_DATA_ABORT)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
              LOG_PRINT(CRITICAL,"Received NULL Pointer from module,Returning without sending to FRM..\n") ;
              xReleaseSignal(SignalOut);
              return;
           }
           LOG_PRINT(INFO," Send OAMS_SWMH_ABIHM_LOAD_DATA_ABORT :: msgSize = %d  msgType = 0x%x \n",
           msgSize , ((SysHdr *)sndPtr)->msgType);
           break;

        /* Interface with CFG */

      case SN_OAMS_SWMH_CFG_SW_DNLD_ACK:
           sndPtr = ((yPDP_sig_OAMS_SWMH_CFG_SW_DNLD_ACK)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_OAMS_SWMH_CFG_SW_DNLD_ACK)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
              LOG_PRINT(CRITICAL,"Received NULL Pointer from module,Returning without sending to FRM..\n") ;
              xReleaseSignal(SignalOut);
              return;
           }
           LOG_PRINT(INFO," Send OAMS_SWMH_CFG_SW_DNLD_ACK :: msgSize = %d  msgType = 0x%x \n",
           msgSize , ((SysHdr *)sndPtr)->msgType);
           break;

      case SN_OAMS_SWMH_CFG_SW_ACT_ACK:
           sndPtr = ((yPDP_sig_OAMS_SWMH_CFG_SW_ACT_ACK)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_OAMS_SWMH_CFG_SW_ACT_ACK)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
              LOG_PRINT(CRITICAL,"Received NULL Pointer from module,Returning without sending to FRM..\n") ;
              xReleaseSignal(SignalOut);
              return;
           }
           LOG_PRINT(INFO," Send OAMS_SWMH_CFG_SW_ACT_ACK :: msgSize = %d  msgType = 0x%x \n",
           msgSize , ((SysHdr *)sndPtr)->msgType);
           break;

      case SN_OAMS_SWMH_CFG_SW_DNLD_NACK:
           sndPtr = ((yPDP_sig_OAMS_SWMH_CFG_SW_DNLD_NACK)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_OAMS_SWMH_CFG_SW_DNLD_NACK)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
              LOG_PRINT(CRITICAL,"Received NULL Pointer from module,Returning without sending to FRM..\n") ;
              xReleaseSignal(SignalOut);
              return;
           }
           LOG_PRINT(INFO," Send OAMS_SWMH_CFG_SW_DNLD_NACK :: msgSize = %d  msgType = 0x%x \n",
           msgSize , ((SysHdr *)sndPtr)->msgType);
           break;

      case SN_OAMS_SWMH_CFG_SW_ACT_NACK:
           sndPtr = ((yPDP_sig_OAMS_SWMH_CFG_SW_ACT_NACK)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_OAMS_SWMH_CFG_SW_ACT_NACK)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
              LOG_PRINT(CRITICAL,"Received NULL Pointer from module,Returning without sending to FRM..\n") ;
              xReleaseSignal(SignalOut);
              return;
           }
           LOG_PRINT(INFO," Send OAMS_SWMH_CFG_SW_ACT_NACK :: msgSize = %d  msgType = 0x%x \n",
           msgSize , ((SysHdr *)sndPtr)->msgType);
           break;
       /* IP BTS */
      case SN_OAMS_SWMH_CFG_INSTALL_ACK:
           sndPtr = ((yPDP_sig_OAMS_SWMH_CFG_INSTALL_ACK)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_OAMS_SWMH_CFG_INSTALL_ACK)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
              LOG_PRINT(CRITICAL,"Received NULL Pointer from module,Returning without sending to FRM..\n") ;
              xReleaseSignal(SignalOut);
              return;
           }
           LOG_PRINT(INFO," Send OAMS_SWMH_CFG_INSTALL_ACK :: msgSize = %d  msgType = 0x%x \n",
           msgSize , ((SysHdr *)sndPtr)->msgType);
           break;
      case SN_OAMS_SWMH_CFG_INSTALL_NACK:
           sndPtr = ((yPDP_sig_OAMS_SWMH_CFG_INSTALL_NACK)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_OAMS_SWMH_CFG_INSTALL_NACK)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
              LOG_PRINT(CRITICAL,"Received NULL Pointer from module,Returning without sending to FRM..\n") ;
              xReleaseSignal(SignalOut);
              return;
           }
           LOG_PRINT(INFO," Send OAMS_SWMH_CFG_INSTALL_NACK :: msgSize = %d  msgType = 0x%x \n",
           msgSize , ((SysHdr *)sndPtr)->msgType);
           break;
      case SN_OAMS_SWMH_CFG_INSTALL_FAILURE:
           sndPtr = ((yPDP_sig_OAMS_SWMH_CFG_INSTALL_FAILURE)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_OAMS_SWMH_CFG_INSTALL_FAILURE)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
              LOG_PRINT(CRITICAL,"Received NULL Pointer from module,Returning without sending to FRM..\n") ;
              xReleaseSignal(SignalOut);
              return;
           }
           LOG_PRINT(INFO," Send OAMS_SWMH_CFG_INSTALL_FAILURE :: msgSize = %d  msgType = 0x%x \n",
           msgSize , ((SysHdr *)sndPtr)->msgType);
           break;
      case SN_OAMS_SWMH_CFG_INSTALL_SUCCESS:
           sndPtr = ((yPDP_sig_OAMS_SWMH_CFG_INSTALL_SUCCESS)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_OAMS_SWMH_CFG_INSTALL_SUCCESS)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
              LOG_PRINT(CRITICAL,"Received NULL Pointer from module,Returning without sending to FRM..\n") ;
              xReleaseSignal(SignalOut);
              return;
           }
           LOG_PRINT(INFO," Send OAMS_SWMH_CFG_INSTALL_SUCCESS :: msgSize = %d  msgType = 0x%x \n",
           msgSize , ((SysHdr *)sndPtr)->msgType);
           break;
      case SN_OAMS_SWMH_CFG_CV_ACT_NACK:
           sndPtr = ((yPDP_sig_OAMS_SWMH_CFG_CV_ACT_NACK)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_OAMS_SWMH_CFG_CV_ACT_NACK)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
              LOG_PRINT(CRITICAL,"Received NULL Pointer from module,Returning without sending to FRM..\n") ;
              xReleaseSignal(SignalOut);
              return;
           }
           LOG_PRINT(INFO," Send OAMS_SWMH_CFG_CV_ACT_NACK :: msgSize = %d  msgType = 0x%x \n",
           msgSize , ((SysHdr *)sndPtr)->msgType);
           break;
      case SN_OAMS_SWMH_CFG_CV_ACT_REPORT:
           sndPtr = ((yPDP_sig_OAMS_SWMH_CFG_CV_ACT_REPORT)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_OAMS_SWMH_CFG_CV_ACT_REPORT)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
              LOG_PRINT(CRITICAL,"Received NULL Pointer from module,Returning without sending to FRM..\n") ;
              xReleaseSignal(SignalOut);
              return;
           }
           LOG_PRINT(INFO," Send OAMS_SWMH_CFG_CV_ACT_REPORT :: msgSize = %d  msgType = 0x%x \n",
           msgSize , ((SysHdr *)sndPtr)->msgType);
           break;
      case SN_OAMS_SWMH_CFG_SW_ACT_SUCCESS:
           sndPtr = ((yPDP_sig_OAMS_SWMH_CFG_SW_ACT_SUCCESS)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_OAMS_SWMH_CFG_SW_ACT_SUCCESS)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
              LOG_PRINT(CRITICAL,"Received NULL Pointer from module,Returning without sending to FRM..\n") ;
              xReleaseSignal(SignalOut);
              return;
           }
           LOG_PRINT(INFO," Send OAMS_SWMH_CFG_SW_ACT_SUCCESS :: msgSize = %d  msgType = 0x%x \n",
           msgSize , ((SysHdr *)sndPtr)->msgType);
           break;
      case SN_OAMS_SWMH_ABIHM_INSTALL_REQ:
           sndPtr = ((yPDP_sig_OAMS_SWMH_ABIHM_INSTALL_REQ)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_OAMS_SWMH_ABIHM_INSTALL_REQ)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
              LOG_PRINT(CRITICAL,"Received NULL Pointer from module,Returning without sending to FRM..\n") ;
              xReleaseSignal(SignalOut);
              return;
           }
           LOG_PRINT(INFO," Send OAMS_SWMH_ABIHM_INSTALL_REQ :: msgSize = %d  msgType = 0x%x \n",msgSize , ((SysHdr *)sndPtr)->msgType);
           break;
      case SN_OAMS_SWMH_ABIHM_CV_ACT_REQ:
           sndPtr = ((yPDP_sig_OAMS_SWMH_ABIHM_CV_ACT_REQ)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_OAMS_SWMH_ABIHM_CV_ACT_REQ)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
              LOG_PRINT(CRITICAL,"Received NULL Pointer from module,Returning without sending to FRM..\n") ;
              xReleaseSignal(SignalOut);
              return;
           }
           LOG_PRINT(INFO," Send OAMS_SWMH_ABIHM_CV_ACT_REQ :: msgSize = %d  msgType = 0x%x \n",msgSize , ((SysHdr *)sndPtr)->msgType);
           break;
      case SN_OAMS_SWMH_ABIHM_CV_STATUS_INQ:
           sndPtr = ((yPDP_sig_OAMS_SWMH_ABIHM_CV_STATUS_INQ)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_OAMS_SWMH_ABIHM_CV_STATUS_INQ)(*SignalOut))->Param2;
           if (sndPtr == NULL)
           {
              LOG_PRINT(CRITICAL,"Received NULL Pointer from module,Returning without sending to FRM..\n") ;
              xReleaseSignal(SignalOut);
              return;
           }
           LOG_PRINT(INFO," Send  SN_OAMS_SWMH_ABIHM_CV_STATUS_INQ:: msgSize = %d  msgType = 0x%x \n",msgSize , ((SysHdr *)sndPtr)->msgType);
           break;
     /* IP BTS */

      case SN_OAMS_SWMH_CFG_ALARM_IND:
           sndPtr = ((yPDP_sig_OAMS_SWMH_CFG_ALARM_IND)(*SignalOut))->Param1;
           msgSize = ((yPDP_sig_OAMS_SWMH_CFG_ALARM_IND)(*SignalOut))->Param2;
           LOG_PRINT(INFO," Send OAMS_SWMH_CFG_ALARM_IND :: msgSize = %d  msgType = 0x%x \n",
           msgSize , ((SysHdr *)sndPtr)->msgType);
           if (sndPtr == NULL)
           {
              LOG_PRINT(CRITICAL,"Received NULL Pointer from module,Returning without sending to FRM..\n") ;
              xReleaseSignal(SignalOut);
              return;
           }
           LOG_PRINT(INFO," Send OAMS_SWMH_CFG_ALARM_IND :: msgSize = %d  msgType = 0x%x \n",
           msgSize , ((SysHdr *)sndPtr)->msgType);
           break;

      case SN_OAMS_GET_SWMH_LOCAL_PID :
           sysClassLclPid = (I_U32)((*SignalOut)->Sender.LocalPId);
           LOG_PRINT(INFO, "Received OAMS_GET_SWMH_LOCAL_PID from SwMHandler Class.\n");
           LOG_PRINT(INFO, "sysClassLclPid = %d\n", sysClassLclPid);
           xReleaseSignal(SignalOut);
           return ;

      case SN_OAMS_ADD_TAU_INST_IN_INSTMAP :
           actClsId = ((yPDP_sig_OAMS_ADD_TAU_INST_IN_INSTMAP)(*SignalOut))->Param1;
           lclPidPtr = (I_U32)((*SignalOut)->Sender.LocalPId);
           if ((retVal = AddTauInst(lclPidPtr,ENT_OAMS_SWMH, actClsId)) < 0)
           {
              LOG_PRINT(CRITICAL, "xOutEnv : AddTauInstId() Failed lclPidPtr = 0x%x [Act Cls Id = %d]",(I_S32)lclPidPtr, actClsId);
           }
           else
           {
              LOG_PRINT(INFO, "xOutEnv : AddTauInstId() Success lclPidPtr = 0x%x [Act Cls Id = %d]",(I_S32)lclPidPtr, actClsId);
              /* CS4.0: HA changes start */
              gSignalSent--;
              LOG_PRINT(INFO, "gSignalSent: %d", gSignalSent);
              if ( gSignalSent == 0 && gInstancesCreated == I_FALSE )
              {
                 gCurrentCardState = gNewCardState; 
                 gNewCardState = CARDSTATE_INVALID;
                 gInstancesCreated = I_TRUE;
                 LOG_PRINT(INFO,"CurrentCardState: [%d]", gCurrentCardState) ; 
                 LOG_PRINT(INFO,"NewCardState: [%d]", gNewCardState) ;
                 RELEASE_MUTEX;
                 LOG_PRINT(INFO,"Moving to ACTIVE state.. ");
              }
           /* CS4.0: HA changes End */
           }
           xReleaseSignal(SignalOut);
           return;

      case SN_OAMS_FREE_INST :
           actClsId = ((yPDP_sig_OAMS_FREE_INST)(*SignalOut))->Param1; 
           lclPidPtr = (I_U32)((*SignalOut)->Sender.LocalPId);
           if ((retVal = FreInstId(lclPidPtr, ENT_OAMS_SWMH,actClsId)) < 0)
           {
              LOG_PRINT(CRITICAL, "xOutEnv : FreeInstId() Failed lclPidPtr = 0x%x [Act Cls Id = %d]",lclPidPtr, actClsId);
           }
           else
           {
              LOG_PRINT(INFO, "xOutEnv : FreeInstId() Success lclPidPtr = 0x%x [Act Cls Id = %d]",lclPidPtr, actClsId);
           }
           xReleaseSignal(SignalOut);
           return;

           /* CS4.0: Changes for HA Start */
      case SN_SWMH_INT_SELFCARD_STATE_CHANGE_RESP :
           LOG_PRINT(DEBUG, "xOutEnv : Received signal SN_SWMH_INT_SELFCARD_STATE_CHANGE_RESP");
           gSignalSent--;
           LOG_PRINT(INFO, "gSignalSent: %d", gSignalSent);
           if ( gSignalSent == 0 )
           {
              activeStateHandler();
           }
           xReleaseSignal(SignalOut);
           return;
           /* CS4.0: Changes for HA End */
            /* Default */
      default:
           LOG_PRINT(INFO," Entered Default Case : xOutEnv \n");
           xReleaseSignal(SignalOut);
           return;
  
   }/*switch */
   
   LOG_PRINT(INFO,"\n OUT OF SWITCH XOUT::ENV  msgSize = %d\n ",msgSize);

   if (SendMsg(sndPtr, MSG_ORD_PRIO, msgSize) == SND_FAIL)
   {
      LOG_PRINT(CRITICAL,"\n SENDING FAILED \n");
      xReleaseSignal(SignalOut);
      return;
   }
   else
   {
      LOG_PRINT(INFO,"Successfully sent message out \n");
      xReleaseSignal(SignalOut);
      return;
   }

  /* Signals going to the env via the port unnamed_port_0 */
   
}


/*---+---------------------------------------------------------------
     Macros for xInEnv
-------------------------------------------------------------------*/
#ifndef IN_LOCAL_VARIABLES
#define IN_LOCAL_VARIABLES \
  xSignalNode SignalIn;
#endif

#ifndef IN_SIGNAL1
#define IN_SIGNAL1(SIGNAL_NAME, SIGNAL_NAME_STRING) \
  SignalIn = xGetSignal(SIGNAL_NAME, xNotDefPId, xEnv);
#endif

#ifndef IN_SIGNAL2
#define IN_SIGNAL2(SIGNAL_NAME, SIGNAL_NAME_STRING) \
  SDL_Output(SignalIn xSigPrioPar(xDefaultPrioSignal), (xIdNode *)0);
#endif

#ifndef IF_IN_SIGNAL
#define IF_IN_SIGNAL(SIGNAL_NAME, SIGNAL_NAME_STRING) \
  if (TEST_IF_IN_SIGNAL(SIGNAL_NAME)) {
#define END_IF_IN_SIGNAL(SIGNAL_NAME, SIGNAL_NAME_STRING) \
  }
#endif

#ifndef TEST_IF_IN_SIGNAL
#define TEST_IF_IN_SIGNAL(SIGNAL_NAME)  0
#endif

#ifndef XENV_DEC
#define XENV_DEC(stmt) stmt
#endif

#ifndef XENV_IN_START
#define XENV_IN_START
#endif

#ifndef XENV_IN_END
#define XENV_IN_END
#endif


/*---+---------------------------------------------------------------
     xInEnv  extern
-------------------------------------------------------------------*/
#ifndef XTENV
extern void xInEnv ( SDL_Time Time_for_next_event )
#else
extern SDL_Duration xInEnv ( SDL_Time Time_for_next_event )
#endif
{
   xSignalNode S;  

#ifdef XTRACE
#ifndef XNOXINENVTRACE
  xPrintString( "xInEnv: Called!\n");
#endif
#endif
  xSignalNode *SignalOut; 
  I_U16 sndMsgSize;
   I_PVoid        rcvPtr;
   I_S32          msgSize;
   I_S32          instId;
   I_U16          msgType;
   I_U8           subType;
   SDL_Pid        rcvr;
   I_U32          lclPidPtr;
   I_U32          nodeType;
   I_U32          nodeId;
   I_U32          applTei;
   I_Void             *sndPtr     = NULL;
   struct sAisParam *param;   
   SysAddr slfAddr;
   TmrPayLoad tmrPayLoad;
   I_U32 timerId = ZERO;
        
   if ((rcvPtr = (I_PVoid)RecvMsg(selfEntIdG, &msgSize)) != NULL)
   {
      msgType = ((SysHdr *)rcvPtr)->msgType;
      subType = ((SysHdr *)rcvPtr)->subType;
      instId = ((SysHdr *)rcvPtr)->dest.inst;
      LOG_PRINT(INFO,"Messgae Received for SWMH msgTyp = 0x%x and subType = %d",msgType,subType);
      rcvr.GlobalNodeNr = (I_S32)selfEntIdG;
      rcvr.LocalPId = (xLocalPIdNode)0;

      if( ((SysHdr *)rcvPtr)->src.entity == ENT_IPC_TMR )
      {
        LOG_PRINT(INFO,"Timer Expired Messgae for SWMH ");
        processTimerMsg(rcvPtr);
        DalocMsgBuf((I_PVoid)rcvPtr) ;
        return ;
      }    
      /* CS4.0: Changes for HA Start */
      if ( gCurrentCardState == CARDSTATE_ACTIVE )
      {
      /* CS4.0: Changes for HA End */
      lclPidPtr = 0;
      switch(msgType)
      {
         /* Send this Message into TAU model */
         /* Interface to CFG */
         /*new messages added to for IP _ BTS */
         case OAMS_CFG_SWMH_SW_INSTALL_REQ:
         {
            nodeType = ((OamsCfgSwmhSwInstallReq *)rcvPtr)->nodeType;
            nodeId = ((OamsCfgSwmhSwInstallReq *)rcvPtr)->nodeIdentity;
            applTei = ((OamsCfgSwmhSwInstallReq *)rcvPtr)->applTei;
            if (nodeType == SYS_NODE_TYPE_R3_BTS || nodeType == SYS_NODE_TYPE_R2_BTS_IP || nodeType == SYS_NODE_TYPE_R2_BTS_IP_TRX || nodeType == SYS_NODE_TYPE_R3_BTS_TRX  )
            {
               LOG_PRINT(INFO,"OAMS_CFG_SWMH_SW_INSTALL_REQ Signal received from CFG with nodeType = %u, nodeIdentity = %u, applTei = %u\n", nodeType, nodeId, applTei );
               if (AlocNewInst(&lclPidPtr, &instId, ENT_OAMS_SWMH, SWMH_DOWNLOAD, nodeType, nodeId,  applTei, 0, 0) != INST_SUCCESS)
               {
                  LOG_PRINT(CRITICAL,"Unable to Allocate New Instance for nodeType = %u, nodeIdentity = %u, applTei = %u\n", nodeType, nodeId, applTei) ;
                  DalocMsgBuf((I_PVoid)rcvPtr) ;
                  return ;
               }
               LOG_PRINT(INFO,"Successfully Allocated New Instance for nodeType = %u, nodeIdentity = %u, applTei = %u\n", nodeType, nodeId, applTei) ;
               LOG_PRINT(INFO, "lclPidPtr = %x", lclPidPtr) ;
               rcvr.LocalPId =(xLocalPIdNode)lclPidPtr;
               S = xGetSignal( sig_OAMS_CFG_SWMH_SW_INSTALL_REQ, rcvr, xEnv);
               (((yPDP_sig_OAMS_CFG_SWMH_SW_INSTALL_REQ)S)->Param1) = rcvPtr;
               break;
            }
            else
            {
               LOG_PRINT(CRITICAL,"Install request with unknown nodeType received \n") ;
               DalocMsgBuf((I_PVoid)rcvPtr) ;
               return ;
            }
         }
         case OAMS_CFG_SWMH_CV_ACT_REQ:
         {
            nodeType = ((OamsCfgSwmhCvActReq *)rcvPtr)->nodeType;
            nodeId = ((OamsCfgSwmhCvActReq *)rcvPtr)->nodeIdentity;
            applTei = ((OamsCfgSwmhCvActReq *)rcvPtr)->applTei;
            if (nodeType == SYS_NODE_TYPE_R3_BTS || nodeType == SYS_NODE_TYPE_R2_BTS_IP || nodeType == SYS_NODE_TYPE_R2_BTS_IP_TRX || nodeType == SYS_NODE_TYPE_R3_BTS_TRX  )
            {
               LOG_PRINT(INFO,"OAMS_CFG_SWMH_CV_ACT_REQ Signal received from CFG with nodeType = %u, nodeIdentity = %u, applTei = %u\n", nodeType, nodeId, applTei );
               if (AlocNewInst(&lclPidPtr, &instId, ENT_OAMS_SWMH, SWMH_ACTIVATE, nodeType, nodeId, applTei, 0, 0) != INST_SUCCESS)
               {
                  LOG_PRINT(CRITICAL,"Unable to Allocate New Instance for nodeType = %u, nodeIdentity = %u, applTei = %u\n", nodeType, nodeId, applTei) ;           
                  DalocMsgBuf((I_PVoid)rcvPtr) ;
                  return ;
               }
               LOG_PRINT(INFO,"Successfully Allocated New Instance for nodeType = %u, nodeIdentity = %u, applTei = %u\n", nodeType, nodeId, applTei) ;
               LOG_PRINT(INFO, "lclPidPtr = %x", lclPidPtr) ;
               rcvr.LocalPId =(xLocalPIdNode)lclPidPtr;
               S = xGetSignal( sig_OAMS_CFG_SWMH_CV_ACT_REQ, rcvr, xEnv);
               (((yPDP_sig_OAMS_CFG_SWMH_CV_ACT_REQ)S)->Param1) = rcvPtr;
               break;
            }
            else
            {
               LOG_PRINT(CRITICAL,"CV Activation request with unknown nodeType received \n") ;
               DalocMsgBuf((I_PVoid)rcvPtr) ;
               return ;
            }
         }
         case CSAPP_ABIHM_SWMH_SW_INSTALL_ACK:
         {
           applTei = ((CsappAbihmSwmhSwInstallAck *)rcvPtr)->applTei;
           LOG_PRINT(INFO,"CSAPP_ABIHM_SWMH_SW_INSTALL_ACK Signal received from ABIHM with  applTei = %u\n", applTei) ;  
           if (SearchAlocatedInst(&lclPidPtr, &instId, ENT_OAMS_SWMH,SWMH_DOWNLOAD, 0, 0, applTei, 0, 0) != INST_SUCCESS)
           {
             LOG_PRINT(CRITICAL,"No SWMH_DOWNLOAD Instance found for applTei , case of switchover or bsc restart = %u\n", applTei) ;
             //send cfg the message from here 

             sndMsgSize = sizeof(OamsSwmhCfgSwInstallAck) ;
             if ((sndPtr = (OamsSwmhCfgSwInstallAck *)AlocMsgBuf(sndMsgSize)) == NULL)
             {
               LOG_PRINT(LOG_CRITICAL,"Message Allaocation failed");
               return; 
             }
            ((OamsSwmhCfgSwInstallAck *)sndPtr)->nodeType = ((CsappAbihmSwmhSwInstallAck *)rcvPtr)->nodeType;
            ((OamsSwmhCfgSwInstallAck *)sndPtr)->nodeIdentity = ((CsappAbihmSwmhSwInstallAck *)rcvPtr)->nodeIdentity;
            ((OamsSwmhCfgSwInstallAck *)sndPtr)->applTei = ((CsappAbihmSwmhSwInstallAck *)rcvPtr)->applTei;
            strcpy(((OamsSwmhCfgSwInstallAck *)sndPtr)->softPack,((CsappAbihmSwmhSwInstallAck *)rcvPtr)->softPack);
            
             FILL_SYS_HDR((sndPtr) , OAMS_SWMH_CFG_SW_INSTALL_ACK  , MSG_SUB_TYPE, PRCR_CP,ENT_OAMS_SWMH, ZERO , PRCR_CP, ENT_OAMS_CFG, ZERO); 
             
             if (SendMsg(sndPtr, MSG_ORD_PRIO, sndMsgSize) == SND_FAIL)
             {
               LOG_PRINT(CRITICAL,"\n SENDING FAILED \n");
               DalocMsgBuf((I_PVoid)rcvPtr) ;
               return;
             }
             else
             {
               LOG_PRINT(INFO,"Successfully sent message out \n");
               DalocMsgBuf((I_PVoid)rcvPtr) ;
               return;
             }
           }
           rcvr.LocalPId =(xLocalPIdNode)lclPidPtr;         
           S = xGetSignal( sig_CSAPP_ABIHM_SWMH_SW_INSTALL_ACK, rcvr, xEnv);
           (((yPDP_sig_CSAPP_ABIHM_SWMH_SW_INSTALL_ACK)S)->Param1) = rcvPtr;
           break ;
         }  
         case CSAPP_ABIHM_SWMH_SW_INSTALL_NACK:
         {
           applTei = ((CsappAbihmSwmhSwInstallNack *)rcvPtr)->applTei;
           LOG_PRINT(INFO,"CSAPP_ABIHM_SWMH_SW_INSTALL_NACK Signal received from ABIHM applTei = %u\n", applTei) ;  
           if (SearchAlocatedInst(&lclPidPtr, &instId, ENT_OAMS_SWMH,SWMH_DOWNLOAD, 0, 0, applTei, 0, 0) != INST_SUCCESS)
           {
             LOG_PRINT(CRITICAL,"No SWMH_DOWNLOAD Instance found for applTei case of switchover or bsc restart = %u\n", applTei) ;
             //send cfg the message from here 

             sndMsgSize = sizeof(OamsSwmhCfgSwInstallNack) ;
             if ((sndPtr = (OamsSwmhCfgSwInstallNack *)AlocMsgBuf(sndMsgSize)) == NULL)
             {
               LOG_PRINT(LOG_CRITICAL,"Message Allaocation failed");
               return; 
             }

             ((OamsSwmhCfgSwInstallNack *)sndPtr)->nodeType = ((CsappAbihmSwmhSwInstallNack *)rcvPtr)->nodeType;
             ((OamsSwmhCfgSwInstallNack *)sndPtr)->nodeIdentity = ((CsappAbihmSwmhSwInstallNack *)rcvPtr)->nodeIdentity;
             ((OamsSwmhCfgSwInstallNack *)sndPtr)->applTei = ((CsappAbihmSwmhSwInstallNack *)rcvPtr)->applTei;
             strcpy(((OamsSwmhCfgSwInstallNack *)sndPtr)->softPack,((CsappAbihmSwmhSwInstallNack *)rcvPtr)->softPack);
             ((OamsSwmhCfgSwInstallNack *)sndPtr)->nackCause = ((CsappAbihmSwmhSwInstallNack *)rcvPtr)->nackCause;
             FILL_SYS_HDR((sndPtr) , OAMS_SWMH_CFG_SW_INSTALL_NACK  , MSG_SUB_TYPE, PRCR_CP,ENT_OAMS_SWMH, ZERO , PRCR_CP, ENT_OAMS_CFG, ZERO); 

             if (SendMsg(sndPtr, MSG_ORD_PRIO, sndMsgSize) == SND_FAIL)
             {
               LOG_PRINT(CRITICAL,"\n SENDING FAILED \n");
               DalocMsgBuf((I_PVoid)rcvPtr) ;
               return;
             }
             else
             {
               LOG_PRINT(INFO,"Successfully sent message out \n");
               DalocMsgBuf((I_PVoid)rcvPtr) ;
               return;
             }
           }
           rcvr.LocalPId =(xLocalPIdNode)lclPidPtr;         
           S = xGetSignal( sig_CSAPP_ABIHM_SWMH_INSTALL_NACK, rcvr, xEnv);
           (((yPDP_sig_CSAPP_ABIHM_SWMH_INSTALL_NACK)S)->Param1) = rcvPtr;
           break ;
         }  
         case CSAPP_ABIHM_SWMH_SW_INSTALL_SUCCESS:
         {
           applTei = ((CsappAbihmSwmhSwInstallSuccess *)rcvPtr)->applTei;
           LOG_PRINT(INFO,"CSAPP_ABIHM_SWMH_SW_INSTALL_SUCCESS Signal received from ABIHM with applTei = %u\n",  applTei) ;  
           if (SearchAlocatedInst(&lclPidPtr, &instId, ENT_OAMS_SWMH,SWMH_DOWNLOAD, 0, 0, applTei, 0, 0) != INST_SUCCESS)
           {
             LOG_PRINT(CRITICAL,"No SWMH_DOWNLOAD Instance found for  applTei case of switchover or bsc restart = %u\n",  applTei) ;
             //send cfg the message from here 
             sndMsgSize = sizeof(OamsSwmhCfgSwInstallSuccess) ;
             if ((sndPtr = (OamsSwmhCfgSwInstallSuccess *)AlocMsgBuf(sndMsgSize)) == NULL)
             {
               LOG_PRINT(LOG_CRITICAL,"Message Allaocation failed");
               return; 
             }

             ((OamsSwmhCfgSwInstallSuccess *)sndPtr)->nodeType = ((CsappAbihmSwmhSwInstallSuccess *)rcvPtr)->nodeType;
             ((OamsSwmhCfgSwInstallSuccess *)sndPtr)->nodeIdentity = ((CsappAbihmSwmhSwInstallSuccess *)rcvPtr)->nodeIdentity;
             ((OamsSwmhCfgSwInstallSuccess *)sndPtr)->applTei = ((CsappAbihmSwmhSwInstallSuccess *)rcvPtr)->applTei;
             strcpy(((OamsSwmhCfgSwInstallSuccess *)sndPtr)->softPack,((CsappAbihmSwmhSwInstallSuccess *)rcvPtr)->softPack);
             FILL_SYS_HDR((sndPtr) , OAMS_SWMH_CFG_SW_INSTALL_SUCCESS  , MSG_SUB_TYPE, PRCR_CP,ENT_OAMS_SWMH, ZERO , PRCR_CP, ENT_OAMS_CFG, ZERO); 

             if (SendMsg(sndPtr, MSG_ORD_PRIO, sndMsgSize) == SND_FAIL)
             {
               LOG_PRINT(CRITICAL,"\n SENDING FAILED \n");
               DalocMsgBuf((I_PVoid)rcvPtr) ;
               return;
             }
             else
             {
               LOG_PRINT(INFO,"Successfully sent message out \n");
               DalocMsgBuf((I_PVoid)rcvPtr) ;
               return;
             }
           }
           rcvr.LocalPId =(xLocalPIdNode)lclPidPtr;         
           S = xGetSignal( sig_CSAPP_ABIHM_SWMH_INSTALL_SUCCESS, rcvr, xEnv);
           (((yPDP_sig_CSAPP_ABIHM_SWMH_INSTALL_SUCCESS)S)->Param1) = rcvPtr;
           break ;
         }  
         case CSAPP_ABIHM_SWMH_SW_INSTALL_FAILURE:
         {
           applTei = ((CsappAbihmSwmhSwInstallFailure *)rcvPtr)->applTei;
           LOG_PRINT(INFO,"CSAPP_ABIHM_SWMH_SW_INSTALL_FAILURE Signal received from ABIHM with applTei = %u\n", applTei) ;  
           if (SearchAlocatedInst(&lclPidPtr, &instId, ENT_OAMS_SWMH,SWMH_DOWNLOAD, 0, 0, applTei, 0, 0) != INST_SUCCESS)
           {
             LOG_PRINT(CRITICAL,"No SWMH_DOWNLOAD Instance found for  applTei case of switchover or bsc restart = %u\n",  applTei) ;
             //send cfg the message from here 
             sndMsgSize = sizeof(OamsSwmhCfgSwInstallFailure) ;
             if ((sndPtr = (OamsSwmhCfgSwInstallFailure *)AlocMsgBuf(sndMsgSize)) == NULL)
             {
               LOG_PRINT(LOG_CRITICAL,"Message Allaocation failed");
               return; 
             }

             ((OamsSwmhCfgSwInstallFailure *)sndPtr)->nodeType = ((CsappAbihmSwmhSwInstallFailure *)rcvPtr)->nodeType;
             ((OamsSwmhCfgSwInstallFailure *)sndPtr)->nodeIdentity = ((CsappAbihmSwmhSwInstallFailure *)rcvPtr)->nodeIdentity;
             ((OamsSwmhCfgSwInstallFailure *)sndPtr)->applTei = ((CsappAbihmSwmhSwInstallFailure *)rcvPtr)->applTei;
             strcpy(((OamsSwmhCfgSwInstallFailure *)sndPtr)->softPack,((CsappAbihmSwmhSwInstallFailure *)rcvPtr)->softPack);
             ((OamsSwmhCfgSwInstallFailure *)sndPtr)->nackCause = ((CsappAbihmSwmhSwInstallFailure *)rcvPtr)->nackCause;
             FILL_SYS_HDR((sndPtr) , OAMS_SWMH_CFG_SW_INSTALL_FAILURE  , MSG_SUB_TYPE, PRCR_CP,ENT_OAMS_SWMH, ZERO , PRCR_CP, ENT_OAMS_CFG, ZERO); 

             if (SendMsg(sndPtr, MSG_ORD_PRIO, sndMsgSize) == SND_FAIL)
             {
               LOG_PRINT(CRITICAL,"\n SENDING FAILED \n");
               DalocMsgBuf((I_PVoid)rcvPtr) ;
               return;
             }
             else
             {
               LOG_PRINT(INFO,"Successfully sent message out \n");
               DalocMsgBuf((I_PVoid)rcvPtr) ;
               return;
             }
           }
           rcvr.LocalPId =(xLocalPIdNode)lclPidPtr;         
           S = xGetSignal( sig_CSAPP_ABIHM_SWMH_INSTALL_FAILURE, rcvr, xEnv);
           (((yPDP_sig_CSAPP_ABIHM_SWMH_INSTALL_FAILURE)S)->Param1) = rcvPtr;
           break ;
         }
         case CSAPP_ABIHM_SWMH_CV_ACT_NACK:
         {
           applTei  = ((CsappAbihmSwmhCvActNack *)rcvPtr)->applTei ; 
            LOG_PRINT(INFO,"CSAPP_ABIHM_SWMH_CV_ACT_NACK Signal received from ABIHM  applTei = %u\n", applTei) ;  
            if (SearchAlocatedInst(&lclPidPtr, &instId, ENT_OAMS_SWMH,SWMH_ACTIVATE, 0, 0, applTei, 0, 0) != INST_SUCCESS)
            {
              LOG_PRINT(CRITICAL,"No SWMH_ACTIVATE Instance found for  applTei = %u switchover or reboot condition\n",  applTei) ;
              //prepare and send message to CFG 
              sndMsgSize = sizeof(OamsSwmhCfgCvActNack) ;
              if ((sndPtr = (OamsSwmhCfgCvActNack *)AlocMsgBuf(sndMsgSize)) == NULL)
              {
                LOG_PRINT(LOG_CRITICAL,"Message Allaocation failed");
                return; 
              }
              FILL_SYS_HDR((sndPtr) , OAMS_SWMH_CFG_CV_ACT_NACK , MSG_SUB_TYPE, PRCR_CP,ENT_OAMS_SWMH, ZERO , PRCR_CP, ENT_OAMS_CFG, ZERO); 

                ((OamsSwmhCfgCvActNack *)sndPtr)->nodeType = ((CsappAbihmSwmhCvActNack *)rcvPtr)->nodeType;
                ((OamsSwmhCfgCvActNack *)sndPtr)->nodeIdentity = ((CsappAbihmSwmhCvActNack *)rcvPtr)->nodeIdentity;
                strcpy(((OamsSwmhCfgCvActNack *)sndPtr)->softPack, ((CsappAbihmSwmhCvActNack *)rcvPtr)->softPack);   
                strcpy(((OamsSwmhCfgCvActNack *)sndPtr)->cfgData, ((CsappAbihmSwmhCvActNack *)rcvPtr)->cfgData);   
                ((OamsSwmhCfgCvActNack *)sndPtr )->nackCause = ((CsappAbihmSwmhCvActNack *)rcvPtr)->nackCause ; 
                if (SendMsg(sndPtr, MSG_ORD_PRIO, sndMsgSize) == SND_FAIL)
                {
                  LOG_PRINT(CRITICAL,"\n SENDING FAILED \n");
                  DalocMsgBuf((I_PVoid)rcvPtr) ;
                  return;
                }
                else
                {
                  LOG_PRINT(INFO,"Successfully sent message out \n");
                  DalocMsgBuf((I_PVoid)rcvPtr) ;
                  return;
                }
            }
            rcvr.LocalPId =(xLocalPIdNode)lclPidPtr;         
            S = xGetSignal( sig_CSAPP_ABIHM_SWMH_CV_ACT_NACK, rcvr, xEnv);
            (((yPDP_sig_CSAPP_ABIHM_SWMH_CV_ACT_NACK)S)->Param1) = rcvPtr;
            break ;
         }
         case CSAPP_ABIHM_SWMH_CV_STATUS_REPORT:
         {
           applTei = ((CsappAbihmSwmhCvStatusReport *)rcvPtr)->applTei;
           LOG_PRINT(INFO,"CSAPP_ABIHM_SWMH_CV_STATUS_REPORT Signal received from ABIHM  applTei = %u\n", applTei) ;  
           if (SearchAlocatedInst(&lclPidPtr, &instId, ENT_OAMS_SWMH,SWMH_ACTIVATE, 0, 0, applTei, 0, 0) != INST_SUCCESS)
           {
             LOG_PRINT(CRITICAL,"No SWMH_ACTIVATE Instance found for  applTei = %u creating a new one (switchover or reboot condition )\n",  applTei) ;
             // now create  a new instance  
             nodeType = ((CsappAbihmSwmhCvStatusReport *)rcvPtr)->nodeType;
             nodeId = ((CsappAbihmSwmhCvStatusReport *)rcvPtr)->nodeIdentity;
             applTei = ((CsappAbihmSwmhCvStatusReport *)rcvPtr)->applTei;
             if (nodeType == SYS_NODE_TYPE_R3_BTS || nodeType == SYS_NODE_TYPE_R2_BTS_IP || nodeType == SYS_NODE_TYPE_R2_BTS_IP_TRX || nodeType == SYS_NODE_TYPE_R3_BTS_TRX  )
             {
               LOG_PRINT(INFO,"OAMS_CFG_SWMH_CV_STATUS_REPORT Signal received from CFG with nodeType = %u, nodeIdentity = %u, applTei = %u\n", nodeType, nodeId, applTei );
               if (AlocNewInst(&lclPidPtr, &instId, ENT_OAMS_SWMH, SWMH_ACTIVATE, nodeType, nodeId, applTei, 0, 0) != INST_SUCCESS)
               {
                 LOG_PRINT(CRITICAL,"Unable to Allocate New Instance for nodeType = %u, nodeIdentity = %u, applTei = %u\n", nodeType, nodeId, applTei) ;           
                 DalocMsgBuf((I_PVoid)rcvPtr) ;
                 return ;
               }
               LOG_PRINT(INFO,"Successfully Allocated New Instance for nodeType = %u, nodeIdentity = %u, applTei = %u\n", nodeType, nodeId, applTei) ;
               LOG_PRINT(INFO, "lclPidPtr = %x", lclPidPtr) ;
               rcvr.LocalPId =(xLocalPIdNode)lclPidPtr;
               S = xGetSignal( sig_CSAPP_ABIHM_SWMH_CV_STATUS_REPORT, rcvr, xEnv);
               (((yPDP_sig_CSAPP_ABIHM_SWMH_CV_STATUS_REPORT)S)->Param1) = rcvPtr;
               break;
             }
             else
             {
               LOG_PRINT(CRITICAL,"CV Activation Report with unknown nodeType received \n") ;
							  /*Changed for mantis #32285 & mantis #32284
                Gaurav Sinha
                21-10-2016
               */
               if(rcvPtr != NULL)
               {
                  DalocMsgBuf((I_PVoid)rcvPtr) ;
               }
              /*Changes end for mantis #32285 & mantis #32284 */
               return ;
             }
           } // instance not found 
           rcvr.LocalPId =(xLocalPIdNode)lclPidPtr;         
           S = xGetSignal( sig_CSAPP_ABIHM_SWMH_CV_STATUS_REPORT, rcvr, xEnv);
           (((yPDP_sig_CSAPP_ABIHM_SWMH_CV_STATUS_REPORT)S)->Param1) = rcvPtr;
           break ;
         }
         case CSAPP_ABIHM_SWMH_CV_COMMIT_IND:
         {
           applTei  = ((CsappAbihmSwmhCvCommitInd *)rcvPtr)->applTei ; 
           LOG_PRINT(INFO,"CSAPP_ABIHM_SWMH_CV_COMMIT_IND Signal received from ABIHM  applTei = %u\n", applTei) ;  
           /*if (SearchAlocatedInst(&lclPidPtr, &instId, ENT_OAMS_SWMH,SWMH_ACTIVATE, 0, 0, applTei, 0, 0) != INST_SUCCESS)
             {
             LOG_PRINT(CRITICAL,"No SWMH_ACTIVATE Instance found for  applTei = %u switchover or reboot condition\n",  applTei) ;
           //prepare and send message to CFG 
           sndMsgSize = sizeof(OamsSwmhCfgCvCommitInd) ;
           if ((sndPtr = (OamsSwmhCfgCvCommitInd *)AlocMsgBuf(sndMsgSize)) == NULL)
           {
           LOG_PRINT(LOG_CRITICAL,"Message Allaocation failed");
           return; 
           }
           FILL_SYS_HDR((sndPtr) , OAMS_SWMH_CFG_CV_COMMIT_IND  , MSG_SUB_TYPE, PRCR_CP,ENT_OAMS_SWMH, ZERO , PRCR_CP, ENT_OAMS_CFG, ZERO); 
           ((OamsSwmhCfgCvCommitInd *)sndPtr)->nodeType = ((CsappAbihmSwmhCvCommitInd *)rcvPtr)->nodeType; 
           ((OamsSwmhCfgCvCommitInd *)sndPtr)->nodeIdentity = ((CsappAbihmSwmhCvCommitInd *)rcvPtr)->nodeIdentity ;

           strcpy(((OamsSwmhCfgCvCommitInd *)sndPtr)->softPack, ((CsappAbihmSwmhCvCommitInd *)rcvPtr)->softPack);   
           strcpy(((OamsSwmhCfgCvCommitInd *)sndPtr)->cfgData, ((CsappAbihmSwmhCvCommitInd *)rcvPtr)->cfgData)   ;
           if (SendMsg(sndPtr, MSG_ORD_PRIO, sndMsgSize) == SND_FAIL)
           {
           LOG_PRINT(CRITICAL,"\n SENDING FAILED \n");
           DalocMsgBuf((I_PVoid)rcvPtr) ;
           xReleaseSignal(SignalOut);
           return;
           }
           else
           {
           LOG_PRINT(INFO,"Successfully sent message out \n");
           DalocMsgBuf((I_PVoid)rcvPtr) ;
           xReleaseSignal(SignalOut);
           return;
           }

           }
           rcvr.LocalPId =(xLocalPIdNode)lclPidPtr;         
           S = xGetSignal( sig_CSAPP_ABIHM_SWMH_CV_ACT_COMMIT_IND, rcvr, xEnv);
           (((yPDP_sig_CSAPP_ABIHM_SWMH_CV_ACT_COMMIT_IND)S)->Param1) = rcvPtr; 
            */
           LOG_PRINT(CRITICAL," Ignoring this message \n") ;
           DalocMsgBuf((I_PVoid)rcvPtr) ;
           return ;
         }
         /*new messages added to for IP _ BTS  ends */
         case OAMS_CFG_SWMH_SW_DNLD_REQ:
         {
            applTei = ((OamsCfgSwmhSwDnldReq *)rcvPtr)->applTei;
            nodeType = ((OamsCfgSwmhSwDnldReq *)rcvPtr)->nodeType;
            nodeId = ((OamsCfgSwmhSwDnldReq *)rcvPtr)->nodeIdentity;
            if (nodeType == SYS_NODE_TYPE_TRX || nodeType == SYS_NODE_TYPE_BIC || nodeType == SYS_NODE_TYPE_R2_BTS )
            {
               LOG_PRINT(INFO,"OAMS_CFG_SWMH_DNLD_REQ Signal received from CFG with nodeType = %u, nodeIdentity = %u, applTei = %u\n", nodeType, nodeId, applTei );
               if (AlocNewInst(&lclPidPtr, &instId, ENT_OAMS_SWMH, SWMH_DOWNLOAD, nodeType, nodeId,  applTei, 0, 0) != INST_SUCCESS)
               {
                  LOG_PRINT(CRITICAL,"Unable to Allocate New Instance for nodeType = %u, nodeIdentity = %u, applTei = %u\n", nodeType, nodeId, applTei) ;
                  DalocMsgBuf((I_PVoid)rcvPtr) ;
                  return ;
               }
               LOG_PRINT(INFO,"Successfully Allocated New Instance for nodeType = %u, nodeIdentity = %u, applTei = %u\n", nodeType, nodeId, applTei) ;
               LOG_PRINT(INFO, "lclPidPtr = %x", lclPidPtr) ;
               rcvr.LocalPId =(xLocalPIdNode)lclPidPtr;
               S = xGetSignal( sig_OAMS_CFG_SWMH_SW_DNLD_REQ, rcvr, xEnv);
               (((yPDP_sig_OAMS_CFG_SWMH_SW_DNLD_REQ)S)->Param1) = rcvPtr;
               break;
            }
            else
            {
               LOG_PRINT(CRITICAL,"Download request with unknown nodeType received \n") ;
               DalocMsgBuf((I_PVoid)rcvPtr) ;
               return ;
            }
         }

         case OAMS_CFG_SWMH_SW_ACT_REQ:
         {
           applTei = ((OamsCfgSwmhSwActReq *)rcvPtr)->applTei;
            nodeType = ((OamsCfgSwmhSwActReq *)rcvPtr)->nodeType;
            nodeId = ((OamsCfgSwmhSwActReq *)rcvPtr)->nodeIdentity;
            if (nodeType == SYS_NODE_TYPE_TRX || nodeType == SYS_NODE_TYPE_BIC || nodeType == SYS_NODE_TYPE_R2_BTS)
            {
               LOG_PRINT(INFO,"OAMS_CFG_SWMH_SW_ACT_REQ Signal received from CFG with nodeType = %u, nodeIdentity = %u, applTei = %u\n", nodeType, nodeId, applTei );
               if (AlocNewInst(&lclPidPtr, &instId, ENT_OAMS_SWMH, SWMH_ACTIVATE, nodeType, nodeId, applTei, 0, 0) != INST_SUCCESS)
               {
                  LOG_PRINT(CRITICAL,"Unable to Allocate New Instance for nodeType = %u, nodeIdentity = %u, applTei = %u\n", nodeType, nodeId, applTei) ;           
                  DalocMsgBuf((I_PVoid)rcvPtr) ;
                  return ;
               }
               LOG_PRINT(INFO,"Successfully Allocated New Instance for nodeType = %u, nodeIdentity = %u, applTei = %u\n", nodeType, nodeId, applTei) ;
               LOG_PRINT(INFO, "lclPidPtr = %x", lclPidPtr) ;
               rcvr.LocalPId =(xLocalPIdNode)lclPidPtr;
               S = xGetSignal( sig_OAMS_CFG_SWMH_SW_ACT_REQ, rcvr, xEnv);
               (((yPDP_sig_OAMS_CFG_SWMH_SW_ACT_REQ)S)->Param1) = rcvPtr;
               break;
            }
            else
            {
               LOG_PRINT(CRITICAL,"Activation request with unknown nodeType received \n") ;
               DalocMsgBuf((I_PVoid)rcvPtr) ;
               return ;
            }
         }

       /* Interface to ABIHM */

         case CSAPP_ABIHM_SWMH_LOAD_DATA_INIT_ACK:
         {
            if (((CsappAbihmSwmhLoadDataInitAck *)rcvPtr)->objClass == OBJ_CLASS_TRX)
            {
               nodeType = SYS_NODE_TYPE_TRX ;
               applTei  = ((CsappAbihmSwmhLoadDataInitAck *)rcvPtr)->tei ; 
               nodeId   = 0 ;
            }
            else if (((CsappAbihmSwmhLoadDataInitAck *)rcvPtr)->objClass == OBJ_CLASS_BIC)
            {
               nodeType = SYS_NODE_TYPE_BIC ;
               applTei  = ((CsappAbihmSwmhLoadDataInitAck *)rcvPtr)->tei; 
               nodeId   = ((CsappAbihmSwmhLoadDataInitAck *)rcvPtr)->bicId ;
            }      
            else if (((CsappAbihmSwmhLoadDataInitAck *)rcvPtr)->objClass == OBJ_CLASS_BM)
            {
               nodeType = SYS_NODE_TYPE_R2_BTS ;
               applTei  = ((CsappAbihmSwmhLoadDataInitAck *)rcvPtr)->tei;
               nodeId   = 0 ;
            }

            else
            {
               LOG_PRINT(INFO, "Received CSAPP_ABIHM_SWMH_LOAD_DATA_INIT_ACK with wrong nodeType. Dropping Message.") ;
               DalocMsgBuf((I_PVoid)rcvPtr) ;
               return ;
            }                 
            LOG_PRINT(INFO,"CSAPP_ABIHM_SWMH_LOAD_DATA_INIT_ACK Signal received from ABIHM with nodeType = %u, nodeIdentity = %u, applTei = %u\n", nodeType, nodeId, applTei) ;
           
            if (SearchAlocatedInst(&lclPidPtr, &instId, ENT_OAMS_SWMH,SWMH_DOWNLOAD, nodeType, nodeId, applTei, 0, 0) != INST_SUCCESS)
            {
               LOG_PRINT(CRITICAL,"No SWMH_DOWNLOAD Instance found for nodeType = %u, nodeIdentity = %u, applTei = %u\n", nodeType, nodeId, applTei) ;
               DalocMsgBuf((I_PVoid)rcvPtr) ;
               return ;
            }
            rcvr.LocalPId =(xLocalPIdNode)lclPidPtr;  
            S = xGetSignal( sig_CSAPP_ABIHM_SWMH_LOAD_DATA_INIT_ACK, rcvr, xEnv);
            (((yPDP_sig_CSAPP_ABIHM_SWMH_LOAD_DATA_INIT_ACK)S)->Param1) = rcvPtr;
            break;
         }

         case CSAPP_ABIHM_SWMH_LOAD_DATA_INIT_NACK:
         {
            if (((CsappAbihmSwmhLoadDataInitNack *)rcvPtr)->objClass == OBJ_CLASS_TRX)
            {
               nodeType = SYS_NODE_TYPE_TRX;
               applTei  = ((CsappAbihmSwmhLoadDataInitNack *)rcvPtr)->tei; 
               nodeId   = 0;
            }
            else if (((CsappAbihmSwmhLoadDataInitNack *)rcvPtr)->objClass == OBJ_CLASS_BIC)
            {
               nodeType = SYS_NODE_TYPE_BIC;
               applTei  = ((CsappAbihmSwmhLoadDataInitNack *)rcvPtr)->tei; 
               nodeId   = ((CsappAbihmSwmhLoadDataInitNack *)rcvPtr)->bicId;
            }                        
            else if (((CsappAbihmSwmhLoadDataInitNack *)rcvPtr)->objClass == OBJ_CLASS_BM)
            {
               nodeType = SYS_NODE_TYPE_R2_BTS ;
               applTei  = ((CsappAbihmSwmhLoadDataInitNack *)rcvPtr)->tei;
               nodeId   = 0 ;
            }
            else
            {
               LOG_PRINT(INFO, "Received CSAPP_ABIHM_SWMH_LOAD_DATA_INIT_NACK with wrong nodeType. Dropping Message.") ;
               DalocMsgBuf((I_PVoid)rcvPtr) ;
               return ;
            }
            LOG_PRINT(INFO,"CSAPP_ABIHM_SWMH_LOAD_DATA_INIT_NACK Signal received from ABIHM with nodeType = %u, nodeIdentity = %u, applTei = %u\n", nodeType, nodeId, applTei) ;  
            if (SearchAlocatedInst(&lclPidPtr, &instId, ENT_OAMS_SWMH,SWMH_DOWNLOAD, nodeType, nodeId, applTei, 0, 0) != INST_SUCCESS)
            {
               LOG_PRINT(CRITICAL,"No SWMH_DOWNLOAD Instance found for nodeType = %u, nodeIdentity = %u, applTei = %u\n", nodeType, nodeId, applTei) ;
               DalocMsgBuf((I_PVoid)rcvPtr) ;
               return ;
            }
            rcvr.LocalPId =(xLocalPIdNode)lclPidPtr;         
            S = xGetSignal( sig_CSAPP_ABIHM_SWMH_LOAD_DATA_INIT_NACK, rcvr, xEnv);
            (((yPDP_sig_CSAPP_ABIHM_SWMH_LOAD_DATA_INIT_NACK)S)->Param1) = rcvPtr;
            break ;
         }  
         case CSAPP_ABIHM_SWMH_LOAD_DATA_SEG_ACK:
         {
            if (((CsappAbihmSwmhLoadDataSegAck *)rcvPtr)->objClass == OBJ_CLASS_TRX)
            {
               nodeType = SYS_NODE_TYPE_TRX;
               applTei  = ((CsappAbihmSwmhLoadDataSegAck *)rcvPtr)->tei; 
               nodeId   = 0;
            }
            else if (((CsappAbihmSwmhLoadDataSegAck *)rcvPtr)->objClass == OBJ_CLASS_BIC)
            {
               nodeType = SYS_NODE_TYPE_BIC;
               applTei  = ((CsappAbihmSwmhLoadDataSegAck *)rcvPtr)->tei; 
               nodeId   = ((CsappAbihmSwmhLoadDataSegAck *)rcvPtr)->bicId;
            }                     
            else if (((CsappAbihmSwmhLoadDataSegAck *)rcvPtr)->objClass == OBJ_CLASS_BM)
            {
               nodeType = SYS_NODE_TYPE_R2_BTS ;
               applTei  = ((CsappAbihmSwmhLoadDataSegAck *)rcvPtr)->tei;
               nodeId   = 0 ;
            }
            else
            {
               LOG_PRINT(INFO, "Received CSAPP_ABIHM_SWMH_LOAD_DATA_SEG_ACK with wrong nodeType. Dropping Message.") ;
               DalocMsgBuf((I_PVoid)rcvPtr) ;
               return ;
            }
            LOG_PRINT(INFO,"CSAPP_ABIHM_SWMH_LOAD_DATA_SEG_ACK Signal received from ABIHM with nodeType = %u, nodeIdentity = %u, applTei = %u\n", nodeType, nodeId, applTei) ; 
           
            if (SearchAlocatedInst(&lclPidPtr, &instId, ENT_OAMS_SWMH,SWMH_DOWNLOAD, nodeType, nodeId, applTei, 0, 0) != INST_SUCCESS)
            { 
               LOG_PRINT(CRITICAL,"No SWMH_DOWNLOAD Instance found for nodeType = %u, nodeIdentity = %u, applTei = %u\n", nodeType, nodeId, applTei) ;
               DalocMsgBuf((I_PVoid)rcvPtr) ;
               return ;
            }
            rcvr.LocalPId =(xLocalPIdNode)lclPidPtr;         
            S = xGetSignal( sig_CSAPP_ABIHM_SWMH_LOAD_DATA_SEG_ACK, rcvr, xEnv);
            (((yPDP_sig_CSAPP_ABIHM_SWMH_LOAD_DATA_SEG_ACK)S)->Param1) = rcvPtr;
            break;
         }
         
         case CSAPP_ABIHM_SWMH_LOAD_DATA_END_ACK:
         {
            if (((CsappAbihmSwmhLoadDataEndAck *)rcvPtr)->objClass == OBJ_CLASS_TRX)
            {
               nodeType = SYS_NODE_TYPE_TRX;
               applTei  = ((CsappAbihmSwmhLoadDataEndAck *)rcvPtr)->tei; 
               nodeId   = 0;
            }
            else if (((CsappAbihmSwmhLoadDataEndAck *)rcvPtr)->objClass == OBJ_CLASS_BIC)
            {
               nodeType = SYS_NODE_TYPE_BIC;
               applTei  = ((CsappAbihmSwmhLoadDataEndAck *)rcvPtr)->tei; 
               nodeId   = ((CsappAbihmSwmhLoadDataEndAck *)rcvPtr)->bicId;
            }                        
            else if (((CsappAbihmSwmhLoadDataEndAck *)rcvPtr)->objClass == OBJ_CLASS_BM)
            {
               nodeType = SYS_NODE_TYPE_R2_BTS ;
               applTei  = ((CsappAbihmSwmhLoadDataEndAck *)rcvPtr)->tei;
               nodeId   = 0 ;
            }
            else
            {
               LOG_PRINT(INFO, "Received CSAPP_ABIHM_SWMH_LOAD_DATA_END_ACK with wrong nodeType. Dropping Message.") ;
               DalocMsgBuf((I_PVoid)rcvPtr) ;
               return ;
            }
            LOG_PRINT(INFO,"CSAPP_ABIHM_SWMH_LOAD_DATA_END_ACK Signal received from ABIHM with nodeType = %u, nodeIdentity = %u, applTei = %u\n", nodeType, nodeId, applTei) ;  
            if (SearchAlocatedInst(&lclPidPtr, &instId, ENT_OAMS_SWMH,SWMH_DOWNLOAD, nodeType, nodeId, applTei, 0, 0) != INST_SUCCESS)
            {
               LOG_PRINT(CRITICAL,"No SWMH_DOWNLOAD Instance found for nodeType = %u, nodeIdentity = %u, applTei = %u\n", nodeType, nodeId, applTei) ;
               DalocMsgBuf((I_PVoid)rcvPtr) ;
               return ;
            }
            rcvr.LocalPId =(xLocalPIdNode)lclPidPtr;
            S = xGetSignal( sig_CSAPP_ABIHM_SWMH_LOAD_DATA_END_ACK, rcvr, xEnv);
            (((yPDP_sig_CSAPP_ABIHM_SWMH_LOAD_DATA_END_ACK)S)->Param1) = rcvPtr;
            break;
         }
         case CSAPP_ABIHM_SWMH_LOAD_DATA_END_NACK:
         {
            if (((CsappAbihmSwmhLoadDataEndNack *)rcvPtr)->objClass == OBJ_CLASS_TRX)
            {
               nodeType = SYS_NODE_TYPE_TRX;
               applTei  = ((CsappAbihmSwmhLoadDataEndNack *)rcvPtr)->tei; 
               nodeId   = 0;
            }
            else if (((CsappAbihmSwmhLoadDataEndNack *)rcvPtr)->objClass == OBJ_CLASS_BIC)
            {
               nodeType = SYS_NODE_TYPE_BIC;
               applTei  = ((CsappAbihmSwmhLoadDataEndNack *)rcvPtr)->tei; 
               nodeId   = ((CsappAbihmSwmhLoadDataEndNack *)rcvPtr)->bicId;
            }                        
            else if (((CsappAbihmSwmhLoadDataEndNack *)rcvPtr)->objClass == OBJ_CLASS_BM)
            {
               nodeType = SYS_NODE_TYPE_R2_BTS ;
               applTei  = ((CsappAbihmSwmhLoadDataEndNack *)rcvPtr)->tei;
               nodeId   = 0 ;
            }
            else
            {
               LOG_PRINT(INFO, "Received CSAPP_ABIHM_SWMH_LOAD_DATA_END_NACK with wrong nodeType. Dropping Message.") ;
               DalocMsgBuf((I_PVoid)rcvPtr) ;
               return ;
            }
            LOG_PRINT(INFO,"CSAPP_ABIHM_SWMH_LOAD_DATA_END_NACK Signal received from ABIHM with nodeType = %u, nodeIdentity = %u, applTei = %u\n", nodeType, nodeId, applTei) ;

            if (SearchAlocatedInst(&lclPidPtr, &instId, ENT_OAMS_SWMH,SWMH_DOWNLOAD, nodeType, nodeId, applTei, 0, 0) != INST_SUCCESS)
            {
               LOG_PRINT(CRITICAL,"No SWMH_DOWNLOAD Instance found for nodeType = %u, nodeIdentity = %u, applTei = %u\n", nodeType, nodeId, applTei) ;
               DalocMsgBuf((I_PVoid)rcvPtr) ;
               return ;
            }
            rcvr.LocalPId =(xLocalPIdNode)lclPidPtr;      
            S = xGetSignal( sig_CSAPP_ABIHM_SWMH_LOAD_DATA_END_NACK, rcvr, xEnv);
            (((yPDP_sig_CSAPP_ABIHM_SWMH_LOAD_DATA_END_NACK)S)->Param1) = rcvPtr;
            break;
         }
         case CSAPP_ABIHM_SWMH_LOAD_DATA_ABORT:
         {
            if (((CsappAbihmSwmhLoadDataAbort *)rcvPtr)->objClass == OBJ_CLASS_TRX)
            {
               nodeType = SYS_NODE_TYPE_TRX;
               applTei  = ((CsappAbihmSwmhLoadDataAbort *)rcvPtr)->tei; 
               nodeId   = 0;
            }
            else if (((CsappAbihmSwmhLoadDataAbort *)rcvPtr)->objClass == OBJ_CLASS_BIC)
            {
               nodeType = SYS_NODE_TYPE_BIC;
               applTei  = ((CsappAbihmSwmhLoadDataAbort *)rcvPtr)->tei; 
               nodeId   = ((CsappAbihmSwmhLoadDataAbort *)rcvPtr)->bicId;
            }    
            else if (((CsappAbihmSwmhLoadDataAbort *)rcvPtr)->objClass == OBJ_CLASS_BM)
            {
               nodeType = SYS_NODE_TYPE_R2_BTS;
               applTei  = ((CsappAbihmSwmhLoadDataAbort *)rcvPtr)->tei; 
               nodeId   = 0;
            }
      
            else
            {
               LOG_PRINT(INFO, "Received CSAPP_ABIHM_SWMH_LOAD_DATA_ABORT with wrong nodeType. Dropping Message.") ;
               DalocMsgBuf((I_PVoid)rcvPtr) ;
               return ;
            }
            LOG_PRINT(INFO,"CSAPP_ABIHM_SWMH_LOAD_DATA_ABORT Signal received from ABIHM with nodeType = %u, nodeIdentity = %u, applTei = %u\n", nodeType, nodeId, applTei) ;              
           
            if (SearchAlocatedInst(&lclPidPtr, &instId, ENT_OAMS_SWMH,SWMH_DOWNLOAD, nodeType, nodeId, applTei, 0, 0) != INST_SUCCESS)
            {
               LOG_PRINT(CRITICAL,"No SWMH_DOWNLOAD Instance found for nodeType = %u, nodeIdentity = %u, applTei = %u\n", nodeType, nodeId, applTei) ;
               DalocMsgBuf((I_PVoid)rcvPtr) ;
               return ;
            }
            rcvr.LocalPId =(xLocalPIdNode)lclPidPtr;
            S = xGetSignal( sig_CSAPP_ABIHM_SWMH_LOAD_DATA_ABORT, rcvr, xEnv);
            (((yPDP_sig_CSAPP_ABIHM_SWMH_LOAD_DATA_ABORT)S)->Param1) = rcvPtr;
            break;
         }
         case CSAPP_ABIHM_SWMH_ACT_SW_NACK:
         {
            if (((CsappAbihmSwmhActSwNack *)rcvPtr)->objClass == OBJ_CLASS_TRX)
            {
               nodeType = SYS_NODE_TYPE_TRX;
               applTei  = ((CsappAbihmSwmhActSwNack *)rcvPtr)->tei; 
               nodeId   = 0;
            }
            else if (((CsappAbihmSwmhActSwNack *)rcvPtr)->objClass == OBJ_CLASS_BIC)
            {
               nodeType = SYS_NODE_TYPE_BIC;
               applTei  = ((CsappAbihmSwmhActSwNack *)rcvPtr)->tei; 
               nodeId   = ((CsappAbihmSwmhActSwNack *)rcvPtr)->bicId;
            }         
            else if (((CsappAbihmSwmhActSwNack *)rcvPtr)->objClass == OBJ_CLASS_BM)
            {
               nodeType = SYS_NODE_TYPE_R2_BTS;
               applTei  = ((CsappAbihmSwmhActSwNack *)rcvPtr)->tei; 
               nodeId   = 0;
            }
               
            else
            {
               LOG_PRINT(INFO, "Received CSAPP_ABIHM_SWMH_ACT_SW_NACK with wrong nodeType. Dropping Message.") ;
               DalocMsgBuf((I_PVoid)rcvPtr) ;
               return ;
            }
            LOG_PRINT(INFO,"CSAPP_ABIHM_SWMH_ACT_SW_NACK received from ABIHM with nodeType = %u, nodeIdentity = %u, applTei = %u\n", nodeType, nodeId, applTei) ;

            if (SearchAlocatedInst(&lclPidPtr, &instId, ENT_OAMS_SWMH,SWMH_ACTIVATE, nodeType, nodeId, applTei, 0, 0) != INST_SUCCESS)
            {
               LOG_PRINT(CRITICAL,"No SWMH_ACTIVATE Instance found for nodeType = %u, nodeIdentity = %u, applTei = %u\n", nodeType, nodeId, applTei) ;
               DalocMsgBuf((I_PVoid)rcvPtr) ;
               return ;
            }
            rcvr.LocalPId =(xLocalPIdNode)lclPidPtr;        
            S = xGetSignal( sig_CSAPP_ABIHM_SWMH_ACT_SW_NACK, rcvr, xEnv);
            (((yPDP_sig_CSAPP_ABIHM_SWMH_ACT_SW_NACK)S)->Param1) = rcvPtr;
            break;
         }
         case CSAPP_ABIHM_SWMH_SW_ACTIVATED_REPORT:
         {
            LOG_PRINT(INFO,"Dropping CSAPP_ABIHM_SWMH_SW_ACTIVATED_REPORT Signal received from ABIHM"); 
            DalocMsgBuf((I_PVoid)rcvPtr) ;
            return ;
         }

      /* Interface to BICH */

         case OAMS_BICH_SWMH_BIC_HELLO:
         {
            nodeType = ((OamsBichSwmhBicHello *)rcvPtr)->nodeType;
            nodeId   = ((OamsBichSwmhBicHello *)rcvPtr)->nodeIdentity;
            applTei  = ((OamsBichSwmhBicHello *)rcvPtr)->bicTei;
            LOG_PRINT(INFO,"OAMS_BICH_SWMH_BIC_HELLO: received from BICH with nodeType = %u, nodeIdentity = %u, applTei = %u\n", nodeType, nodeId, applTei) ;

            if (SearchAlocatedInst(&lclPidPtr, &instId, ENT_OAMS_SWMH,SWMH_ACTIVATE, nodeType, nodeId, applTei, 0, 0) != INST_SUCCESS)
            {
               LOG_PRINT(INFO,"Failed to find SWMH_ACTIVATE instance for BIC_HELLO with nodeType = %u, nodeIdentity = %u, applTei = %u\n", nodeType, nodeId, applTei) ;
               /*lclPidPtr = getPidPtr();*/
               rcvr.LocalPId =(xLocalPIdNode)sysClassLclPid;
               S = xGetSignal( sig_OAMS_BICH_SWMH_BIC_HELLO, rcvr, xEnv);
               ((yPDP_sig_OAMS_BICH_SWMH_BIC_HELLO)S)->Param1 = rcvPtr;
               break;
            }
            else
            {
               rcvr.LocalPId =(xLocalPIdNode)lclPidPtr;
               S = xGetSignal( sig_OAMS_BICH_SWMH_BIC_HELLO, rcvr, xEnv);
               (((yPDP_sig_OAMS_BICH_SWMH_BIC_HELLO)S)->Param1) = rcvPtr;
               break;
            }
         }
         case OAMS_BICH_SWMH_LAPD_LINK_DOWN:
         { 
            nodeType = ((OamsBichSwmhLapdLinkDown *)rcvPtr)->nodeType;
            nodeId   = ((OamsBichSwmhLapdLinkDown *)rcvPtr)->nodeIdentity;
            applTei  = 0;
            LOG_PRINT(INFO,"OAMS_BICH_SWMH_LAPD_LINK_DOWN received from BICH with nodeType = %u, nodeIdentity = %u, applTei = %u\n", nodeType, nodeId, applTei) ;
            if (SearchAlocatedInst(&lclPidPtr, &instId, ENT_OAMS_SWMH, SWMH_DOWNLOAD, nodeType, nodeId, applTei, 0, 0) == INST_SUCCESS)
            {
               LOG_PRINT(INFO,"Found SWMH_DOWNLOAD instance for OAMS_BICH_SWMH_LAPD_LINK_DOWN with nodeType = %u, nodeIdentity = %u, applTei = %u\n", nodeType, nodeId, applTei) ;
               rcvr.LocalPId =(xLocalPIdNode)lclPidPtr;        
               S = xGetSignal( sig_OAMS_BICH_SWMH_LAPD_LINK_DOWN, rcvr, xEnv);
               (((yPDP_sig_OAMS_BICH_SWMH_LAPD_LINK_DOWN)S)->Param1) = rcvPtr;
               break;        
            }
            else if (SearchAlocatedInst(&lclPidPtr, &instId, ENT_OAMS_SWMH,SWMH_ACTIVATE, nodeType, nodeId, applTei, 0, 0) == INST_SUCCESS)
            {
               LOG_PRINT(INFO,"Found SWMH_ACTIVATE instance for OAMS_BICH_SWMH_LAPD_LINK_DOWN with nodeType = %u, nodeIdentity = %u, applTei = %u\n", nodeType, nodeId, applTei) ;
               rcvr.LocalPId =(xLocalPIdNode)lclPidPtr;        
               S = xGetSignal( sig_OAMS_BICH_SWMH_LAPD_LINK_DOWN, rcvr, xEnv);
               (((yPDP_sig_OAMS_BICH_SWMH_LAPD_LINK_DOWN)S)->Param1) = rcvPtr;
               break;        
            }
            else
            {
               LOG_PRINT(INFO,"Failed to find SWMH_ACTIVATE or SWMH_DOWNLOAD instance for OAMS_BICH_SWMH_LAPD_LINK_DOWN with nodeType = %u, nodeIdentity = %u, applTei = %u\n", nodeType, nodeId, applTei) ;
               LOG_PRINT(INFO,"Dropping the message OAMS_BICH_SWMH_LAPD_LINK_DOWN \n");
               DalocMsgBuf((I_PVoid)rcvPtr);
               return ;
            }
         }
         case OAMS_BICH_SWMH_LAPD_LINK_UP:
         {
            LOG_PRINT(INFO,"Dropping OAMS_BICH_SWMH_LAPD_LINK_UP Signal received from BICH"); 
            DalocMsgBuf((I_PVoid)rcvPtr) ;
            return ;
         }

      /* Interface to TRXH */

         case OAMS_TRXH_SWMH_TRX_HELLO:
         {
            nodeType = ((OamsTrxhSwmhTrxHello *)rcvPtr)->nodeType;
            nodeId   = ((OamsTrxhSwmhTrxHello *)rcvPtr)->nodeIdentity;
            applTei  = ((OamsTrxhSwmhTrxHello *)rcvPtr)->tei;
            LOG_PRINT(INFO,"OAMS_TRXH_SWMH_TRX_HELLO: received from TRXH with nodeType = %u, nodeIdentity = %u, applTei = %u\n", nodeType, nodeId, applTei) ;
            if (SearchAlocatedInst(&lclPidPtr, &instId, ENT_OAMS_SWMH,SWMH_ACTIVATE, nodeType, nodeId, applTei, 0, 0) != INST_SUCCESS)
            {
               LOG_PRINT(INFO,"Failed to find SWMH_ACTIVATE instance for TRX_HELLO with nodeType = %u, nodeIdentity = %u, applTei = %u\n", nodeType, nodeId, applTei) ;
               LOG_PRINT(INFO, "Sending TRX_HELLO to the SwmHandler class.\n");
               rcvr.LocalPId =(xLocalPIdNode)sysClassLclPid;
               S = xGetSignal( sig_OAMS_TRXH_SWMH_TRX_HELLO, rcvr, xEnv);
               ((yPDP_sig_OAMS_TRXH_SWMH_TRX_HELLO)S)->Param1 = rcvPtr;
               break ;
            }
            else
            {
               LOG_PRINT(INFO,"Found SWMH_ACTIVATE instance for TRX_HELLO with nodeType = %u, nodeIdentity = %u, applTei = %u\n", nodeType, nodeId, applTei) ;
               rcvr.LocalPId =(xLocalPIdNode)lclPidPtr;                
               S = xGetSignal( sig_OAMS_TRXH_SWMH_TRX_HELLO, rcvr, xEnv);
               (((yPDP_sig_OAMS_TRXH_SWMH_TRX_HELLO)S)->Param1) = rcvPtr;
               break;
            }
         }
         case OAMS_BICH_SWMH_BM_HELLO:
         {
            nodeType = ((OamsBichSwmhBmHello *)rcvPtr)->nodeType;
            nodeId   = ((OamsBichSwmhBmHello *)rcvPtr)->nodeIdentity;
            applTei  = ((OamsBichSwmhBmHello *)rcvPtr)->bicTei;
            LOG_PRINT(INFO,"OAMS_BICH_SWMH_BM_HELLO: received from BICH with nodeType = %u, nodeIdentity = %u, applTei = %u\n", nodeType, nodeId, applTei) ;
            if (SearchAlocatedInst(&lclPidPtr, &instId, ENT_OAMS_SWMH,SWMH_ACTIVATE, nodeType, nodeId, applTei, 0, 0) != INST_SUCCESS)
            {
               LOG_PRINT(INFO,"Failed to find SWMH_ACTIVATE instance for BM_HELLO with nodeType = %u, nodeIdentity = %u, applTei = %u\n", nodeType, nodeId, applTei) ;
               LOG_PRINT(INFO, "Sending BM_HELLO to the SwmHandler class.\n");
               rcvr.LocalPId =(xLocalPIdNode)sysClassLclPid;
               S = xGetSignal( sig_OAMS_BICH_SWMH_BM_HELLO, rcvr, xEnv);
               ((yPDP_sig_OAMS_BICH_SWMH_BM_HELLO)S)->Param1 = rcvPtr;
               break ;
            }
            else
            {
               LOG_PRINT(INFO,"Found SWMH_ACTIVATE instance for BM_HELLO with nodeType = %u, nodeIdentity = %u, applTei = %u\n", nodeType, nodeId, applTei) ;
               rcvr.LocalPId =(xLocalPIdNode)lclPidPtr;                
               S = xGetSignal( sig_OAMS_BICH_SWMH_BM_HELLO, rcvr, xEnv);
               (((yPDP_sig_OAMS_BICH_SWMH_BM_HELLO)S)->Param1) = rcvPtr;
               break;
            }
         }
         case OAMS_TRXH_SWMH_LAPD_LINK_DOWN:
         {
            nodeType = ((OamsTrxhSwmhLapdLinkDown *)rcvPtr)->nodeType;
            nodeId   = ((OamsTrxhSwmhLapdLinkDown *)rcvPtr)->nodeIdentity;
            applTei  = 0;
            LOG_PRINT(INFO,"OAMS_TRXH_SWMH_LAPD_LINK_DOWN received from TRXH with nodeType = %u, nodeIdentity = %u, applTei = %u\n", nodeType, nodeId, applTei) ;
            if (SearchAlocatedInst(&lclPidPtr, &instId, ENT_OAMS_SWMH,SWMH_DOWNLOAD, nodeType, nodeId, applTei, 0, 0) == INST_SUCCESS)
            {
               LOG_PRINT(INFO,"Found SWMH_DOWNLOAD instance for OAMS_TRXH_SWMH_LAPD_LINK_DOWN with nodeType = %u, nodeIdentity = %u, applTei = %u\n", nodeType, nodeId, applTei) ;
               rcvr.LocalPId =(xLocalPIdNode)lclPidPtr;        
               S = xGetSignal( sig_OAMS_TRXH_SWMH_LAPD_LINK_DOWN, rcvr, xEnv);
               (((yPDP_sig_OAMS_TRXH_SWMH_LAPD_LINK_DOWN)S)->Param1) = rcvPtr;
               break;        
            }
            else if (SearchAlocatedInst(&lclPidPtr, &instId, ENT_OAMS_SWMH,SWMH_ACTIVATE, nodeType, nodeId, applTei, 0, 0) == INST_SUCCESS)
            {
               LOG_PRINT(INFO,"Found SWMH_ACTIVATE instance for OAMS_TRXH_SWMH_LAPD_LINK_DOWN with nodeType = %u, nodeIdentity = %u, applTei = %u\n", nodeType, nodeId, applTei) ;
               rcvr.LocalPId =(xLocalPIdNode)lclPidPtr;        
               S = xGetSignal( sig_OAMS_TRXH_SWMH_LAPD_LINK_DOWN, rcvr, xEnv);
               (((yPDP_sig_OAMS_TRXH_SWMH_LAPD_LINK_DOWN)S)->Param1) = rcvPtr;
               break;        
            }
            else
            {
               LOG_PRINT(INFO,"Failed to find SWMH_ACTIVATE or SWMH_DOWNLOAD instance for OAMS_TRXH_SWMH_LAPD_LINK_DOWN with nodeType = %u, nodeIdentity = %u, applTei = %u\n", nodeType, nodeId, applTei) ;
               LOG_PRINT(INFO,"Dropping the message OAMS_TRXH_SWMH_LAPD_LINK_DOWN \n");
               DalocMsgBuf((I_PVoid)rcvPtr);
               return ;
            }
         }
         case OAMS_TRXH_SWMH_LAPD_LINK_UP:
         {
            LOG_PRINT(INFO,"Dropping OAMS_TRXH_SWMH_LAPD_LINK_UP Signal received from TRXH"); 
            DalocMsgBuf((I_PVoid)rcvPtr) ;
            return ;
         }
         /* Changes For Mantis 16838 */
         case OAMS_CFG_SWMH_LOAD_ABORT_IND:
         {
            nodeType = ((OamsCfgSwmhLoadAbortInd *)rcvPtr)->nodeType;
            nodeId = ((OamsCfgSwmhLoadAbortInd *)rcvPtr)->nodeIdentity;
            applTei = ((OamsCfgSwmhLoadAbortInd *)rcvPtr)->applTei;
            if (nodeType == SYS_NODE_TYPE_TRX || nodeType == SYS_NODE_TYPE_BIC || nodeType == SYS_NODE_TYPE_R2_BTS)
            {
               LOG_PRINT(INFO,"OAMS_CFG_SWMH_LOAD_ABORT_IND Signal received from CFG with nodeType = %u, nodeIdentity = %u, applTei = %u\n", nodeType, nodeId, applTei );
               slfAddr.entity= ENT_OAMS_SWMH;
               memcpy(&(tmrPayLoad.payLoad[0]),&(nodeType),sizeof(I_U32));
               memcpy(&(tmrPayLoad.payLoad[4]),&(nodeId),sizeof(I_U32));
               memcpy(&(tmrPayLoad.payLoad[8]),&(applTei),sizeof(I_U32));
               StartTimerFrmwrk(&slfAddr,10,&tmrPayLoad,&timerId);
               DalocMsgBuf((I_PVoid)rcvPtr);
               return;
            }
            else
            {
               LOG_PRINT(CRITICAL,"Activation request with wrong nodeType %d received \n",nodeType) ;
               DalocMsgBuf((I_PVoid)rcvPtr) ;
               return ;
            }
         }
         
         /* CS4.0: Changes for HA Start */
         #if BPM_PRESENT != 1
         case BPM_SELFCARD_STATE_CHANGE:
         {
            LOG_PRINT(DEBUG,"[ENV]BPM_SELFCARD_STATE_CHANGE: signal received from BPM");
            param = (struct sAisParam *)(rcvPtr+sizeof(SysHdr));
            cardStateChangeHandler(param); 
            DalocMsgBuf((I_Void *)rcvPtr) ;
            return;
         }
         #endif 
         /* CS4.0: Changes for HA End */
     /* Default */
         default:
            LOG_PRINT(INFO," Entered Default Case : xInEnv \n");
            DalocMsgBuf((I_PVoid)rcvPtr) ;
            return ;

      }
      SDL_Output( S xSigPrioPar(xDefaultPrioSignal), (xIdNode *)0 );
      LOG_PRINT(INFO," Exiting XInEnv......... \n");
     }
     else
     {
         #if BPM_PRESENT != 1
         if ( msgType == BPM_SELFCARD_STATE_CHANGE )
         {
            LOG_PRINT(DEBUG,"[ENV]BPM_SELFCARD_STATE_CHANGE: signal received from BPM");
            param = (struct sAisParam *)(rcvPtr+sizeof(SysHdr));
            cardStateChangeHandler(param); 
            DalocMsgBuf((I_Void *)rcvPtr) ;
            return;
         }
         #endif 
          if( msgType == OAMS_CFG_SWMH_LOAD_ABORT_IND)
          {
            nodeType = ((OamsCfgSwmhLoadAbortInd *)rcvPtr)->nodeType;
            nodeId = ((OamsCfgSwmhLoadAbortInd *)rcvPtr)->nodeIdentity;
            applTei = ((OamsCfgSwmhLoadAbortInd *)rcvPtr)->applTei;
            if (nodeType == SYS_NODE_TYPE_TRX || nodeType == SYS_NODE_TYPE_BIC || nodeType == SYS_NODE_TYPE_R2_BTS)
            {
               LOG_PRINT(INFO,"OAMS_CFG_SWMH_LOAD_ABORT_IND Signal received from CFG with nodeType = %u, nodeIdentity = %u, applTei = %u\n", nodeType, nodeId, applTei );
               slfAddr.entity= ENT_OAMS_SWMH;
               memcpy(&(tmrPayLoad.payLoad[0]),&(nodeType),sizeof(I_U32));
               memcpy(&(tmrPayLoad.payLoad[4]),&(nodeId),sizeof(I_U32));
               memcpy(&(tmrPayLoad.payLoad[8]),&(applTei),sizeof(I_U32));
               StartTimerFrmwrk(&slfAddr,10,&tmrPayLoad,&timerId);
               DalocMsgBuf((I_PVoid)rcvPtr);
               return;
            }
            else
            {
               LOG_PRINT(CRITICAL,"Activation request with wrong nodeType %d received \n",nodeType) ;
               DalocMsgBuf((I_PVoid)rcvPtr) ;
               return ;
            }
         }
         else
         {   

           LOG_PRINT(DEBUG," Card is not in Active..... Dalocating message.");
           DalocMsgBuf((I_Void *)rcvPtr) ;
           return ;
         }  
     }

   }

#ifdef XTENV
   return SDL_Time_Lit((xint32)0,(xint32)0);
#endif

}
/* Added For Issue 16838 */
I_Void sendLoadDataAbort(I_U32 nodeType, I_U32 nodeId, I_U32 applTei)
{
    LOG_PRINT(INFO,"Entering into sendLoadDataAbort()");
    I_S32	mSize;
    I_PVoid sndPtr;
    OamsSwmhAbihmLoadDataAbort *msgPtr=NULL ;
    mSize = sizeof(OamsSwmhAbihmLoadDataAbort) ;
    msgPtr = (OamsSwmhAbihmLoadDataAbort *) AlocMsgBuf(mSize) ;
    if(msgPtr==NULL)
    {
       LOG_PRINT(CRITICAL,"Could Not allocate memory ");
       return ;
    }

    FILL_SYS_HDR(msgPtr , OAMS_SWMH_ABIHM_LOAD_DATA_ABORT , MSG_SUB_TYPE, PRCR_CP,
       ENT_OAMS_SWMH, ZERO , PRCR_PP, ENT_CSAPP_ABIHM, ZERO) ;
 
    msgPtr->tei = (I_U8)applTei ; 
    msgPtr->placementInd = PLACEMENT_IND ;
    msgPtr->seqNum = SEQ_NO ;
    if (nodeType == SYS_NODE_TYPE_TRX)
    {
       msgPtr->objClass = OBJ_CLASS_TRX ;
       msgPtr->objInstance.btsNum = OBJ_INSTANCE_BTS_NUM ;  
    }
    else if (nodeType == SYS_NODE_TYPE_BIC)
    {
       msgPtr->objClass = OBJ_CLASS_BIC ; 
       msgPtr->bicId = nodeId ;
       msgPtr->objInstance.btsNum = OBJ_INSTANCE_BTS_NUM ; 
    }
    else if (nodeType == SYS_NODE_TYPE_R2_BTS)
    {
       msgPtr->objClass = OBJ_CLASS_BM ;
       msgPtr->objInstance.btsNum = OBJ_INSTANCE_BTS_NUM_BM ;
      /* No Need to fill bicId in case of BTS */
    }
    else
    {
      LOG_PRINT(MAJOR,"Node Type is neither TRX or BIC or BTS, returning ...") ;
      DalocMsgBuf((I_PVoid)msgPtr);
      return;
    }
    msgPtr->objInstance.baseBandNum = BASE_BAND_NUM ;
    msgPtr->objInstance.timeSlotNum = TIME_SLOT_NUM ;  
    sndPtr = (I_PVoid)msgPtr;
if (SendMsg(sndPtr, MSG_ORD_PRIO, mSize) == SND_FAIL)
   {
      LOG_PRINT(CRITICAL,"\n SENDING FAILED \n");
      return;
   }
   else
   {
      LOG_PRINT(INFO,"Successfully sent LoadDataAbort message to ABIHM \n");
   }

    LOG_PRINT(INFO,"Exiting into sendLoadDataAbort()");
}



I_Void processTimerMsg(I_PVoid rcvPtrMsg)
{
    LOG_PRINT(INFO,"Entering into processTimerMsg()");
    ApplTimer *applTimer = NULL;
    I_U32 nodeId = 0;
    I_U32 applTei = 0;
    I_U32 nodeType = 0;
    applTimer = (ApplTimer *) rcvPtrMsg;
    memcpy(&nodeType, &(applTimer->tmrPayLoad.payLoad[0]), sizeof(I_U32));
    LOG_PRINT(INFO,"Value of nodeType :%u ",nodeType);
    memcpy(&nodeId, &(applTimer->tmrPayLoad.payLoad[4]), sizeof(I_U32));
    LOG_PRINT(INFO,"Value of nodeId :%u ",nodeId);
    memcpy(&applTei, &(applTimer->tmrPayLoad.payLoad[8]), sizeof(I_U32));
    LOG_PRINT(INFO,"Value of applTei :%u ",applTei);
    sendLoadDataAbort(nodeType,nodeId,applTei);
    LOG_PRINT(INFO,"Exiting processTimerMsg()");
}    
